{
  Class[] parmTypes;
  Constructor bestCandidate=null;
  int bestScore=0;
  int score=0;
  Class[] targetParms=new Class[arguments.length];
  for (int i=0; i < arguments.length; i++)   targetParms[i]=arguments[i] != null ? arguments[i].getClass() : Object.class;
  Integer hash=createClassSignatureHash(targetParms);
  if (RESOLVED_CONST_CACHE.containsKey(cls) && RESOLVED_CONST_CACHE.get(cls).containsKey(hash))   return RESOLVED_CONST_CACHE.get(cls).get(hash);
  for (  Constructor construct : getConstructors(cls)) {
    if ((parmTypes=getConstructors(construct)).length != arguments.length)     continue;
 else     if (arguments.length == 0 && parmTypes.length == 0)     return construct;
    for (int i=0; i < arguments.length; i++) {
      if (parmTypes[i].isPrimitive() && boxPrimitive(parmTypes[i]) == targetParms[i])       score+=3;
 else       if (parmTypes[i] == targetParms[i])       score+=4;
 else       if (parmTypes[i].isAssignableFrom(targetParms[i]))       score+=2;
 else       if (canConvert(parmTypes[i],targetParms[i]))       score+=1;
 else {
        score=0;
        break;
      }
    }
    if (score != 0 && score > bestScore) {
      bestCandidate=construct;
      bestScore=score;
    }
    score=0;
  }
  if (bestCandidate != null) {
    if (!RESOLVED_CONST_CACHE.containsKey(cls))     RESOLVED_CONST_CACHE.put(cls,new WeakHashMap<Integer,Constructor>());
    RESOLVED_CONST_CACHE.get(cls).put(hash,bestCandidate);
  }
  return bestCandidate;
}
