{
  final Split split=getSplitNode();
switch (split.getType()) {
case Split.TYPE_AND:
    List outgoing=split.getOutgoingConnections();
  for (final Iterator iterator=outgoing.iterator(); iterator.hasNext(); ) {
    final Connection connection=(Connection)iterator.next();
    getProcessInstance().getNodeInstance(connection.getTo()).trigger(this);
  }
break;
case Split.TYPE_XOR:
outgoing=split.getOutgoingConnections();
int priority=Integer.MAX_VALUE;
Connection selected=null;
RuleFlowGroup systemRuleFlowGroup=getProcessInstance().getAgenda().getRuleFlowGroup("DROOLS_SYSTEM");
for (final Iterator iterator=outgoing.iterator(); iterator.hasNext(); ) {
final Connection connection=(Connection)iterator.next();
Constraint constraint=split.getConstraint(connection);
if (constraint != null && constraint.getPriority() < priority) {
String rule="RuleFlow-" + getProcessInstance().getProcess().getId() + "-"+ getNode().getId()+ "-"+ connection.getTo().getId();
for (Iterator activations=systemRuleFlowGroup.iterator(); activations.hasNext(); ) {
Activation activation=((RuleFlowGroupNode)activations.next()).getActivation();
if (rule.equals(activation.getRule().getName())) {
selected=connection;
priority=constraint.getPriority();
break;
}
}
}
}
if (selected == null) {
throw new IllegalArgumentException("XOR split could not find at least one valid outgoing connection for split " + getSplitNode().getName());
}
getProcessInstance().getNodeInstance(selected.getTo()).trigger(this);
break;
case Split.TYPE_OR:
outgoing=split.getOutgoingConnections();
boolean found=false;
systemRuleFlowGroup=getProcessInstance().getAgenda().getRuleFlowGroup("DROOLS_SYSTEM");
for (final Iterator iterator=outgoing.iterator(); iterator.hasNext(); ) {
final Connection connection=(Connection)iterator.next();
Constraint constraint=split.getConstraint(connection);
if (constraint != null) {
String rule="RuleFlow-" + getProcessInstance().getProcess().getId() + "-"+ getNode().getId()+ "-"+ connection.getTo().getId();
for (Iterator activations=systemRuleFlowGroup.iterator(); activations.hasNext(); ) {
Activation activation=(Activation)activations.next();
if (rule.equals(activation.getRule().getName())) {
getProcessInstance().getNodeInstance(connection.getTo()).trigger(this);
found=true;
break;
}
}
}
if (!found) {
throw new IllegalArgumentException("OR split could not find at least one valid outgoing connection for split " + getSplitNode().getName());
}
}
break;
default :
throw new IllegalArgumentException("Illegal split type " + split.getType());
}
}
