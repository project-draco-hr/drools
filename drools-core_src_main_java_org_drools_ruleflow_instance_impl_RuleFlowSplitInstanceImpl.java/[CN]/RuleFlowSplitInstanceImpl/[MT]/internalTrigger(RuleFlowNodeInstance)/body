{
  final Split split=getSplitNode();
switch (split.getType()) {
case Split.TYPE_AND:
    List outgoing=split.getOutgoingConnections();
  for (final Iterator iterator=outgoing.iterator(); iterator.hasNext(); ) {
    final Connection connection=(Connection)iterator.next();
    getProcessInstance().getNodeInstance(connection.getTo()).trigger(this);
  }
break;
case Split.TYPE_XOR:
outgoing=split.getOutgoingConnections();
int priority=Integer.MAX_VALUE;
Connection selected=null;
for (final Iterator iterator=outgoing.iterator(); iterator.hasNext(); ) {
final Connection connection=(Connection)iterator.next();
Constraint constraint=split.getConstraint(connection);
if (constraint != null && constraint.getPriority() < priority) {
if (constraint.getConstraintDelegate().evaluate(this,connection,constraint)) {
selected=connection;
priority=constraint.getPriority();
break;
}
}
}
if (selected == null) {
throw new IllegalArgumentException("XOR split could not find at least one valid outgoing connection for split " + getSplitNode().getName());
}
getProcessInstance().getNodeInstance(selected.getTo()).trigger(this);
break;
case Split.TYPE_OR:
outgoing=split.getOutgoingConnections();
boolean found=false;
for (final Iterator iterator=outgoing.iterator(); iterator.hasNext(); ) {
final Connection connection=(Connection)iterator.next();
Constraint constraint=split.getConstraint(connection);
if (constraint != null && constraint.getConstraintDelegate().evaluate(this,connection,constraint)) {
getProcessInstance().getNodeInstance(connection.getTo()).trigger(this);
found=true;
}
if (!found) {
throw new IllegalArgumentException("OR split could not find at least one valid outgoing connection for split " + getSplitNode().getName());
}
}
break;
default :
throw new IllegalArgumentException("Illegal split type " + split.getType());
}
}
