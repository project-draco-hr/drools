{
  boolean tupleMemory=true;
  RightTupleMemory rtm=bm.getRightTupleMemory();
  LeftTupleMemory ltm=bm.getLeftTupleMemory();
  ContextEntry[] contextEntry=bm.getContext();
  BetaConstraints constraints=existsNode.getRawConstraints();
  FastIterator it=existsNode.getRightIterator(rtm);
  for (RightTuple rightTuple=srcRightTuples.getDeleteFirst(); rightTuple != null; ) {
    RightTuple next=rightTuple.getStagedNext();
    boolean useComparisonIndex=rtm.getIndexType().isComparison();
    RightTuple rootBlocker=useComparisonIndex ? null : (RightTuple)it.next(rightTuple);
    if (rightTuple.getMemory() != null) {
      rtm.remove(rightTuple);
    }
    if (rightTuple.getBlocked() != null) {
      PropagationContext context=rightTuple.getPropagationContext();
      for (LeftTuple leftTuple=rightTuple.getBlocked(); leftTuple != null; ) {
        LeftTuple temp=leftTuple.getBlockedNext();
        leftTuple.clearBlocker();
        if (leftTuple.getStagedType() == LeftTuple.UPDATE) {
          leftTuple=temp;
          continue;
        }
        constraints.updateFromTuple(contextEntry,wm,leftTuple);
        if (useComparisonIndex) {
          rootBlocker=rtm.getFirst(leftTuple,(InternalFactHandle)context.getFactHandle(),it);
        }
        for (RightTuple newBlocker=rootBlocker; newBlocker != null; newBlocker=(RightTuple)it.next(newBlocker)) {
          if (constraints.isAllowedCachedLeft(contextEntry,newBlocker.getFactHandle())) {
            leftTuple.setBlocker(newBlocker);
            newBlocker.addBlocked(leftTuple);
            break;
          }
        }
        if (leftTuple.getBlocker() == null) {
          ltm.add(leftTuple);
          LeftTuple childLeftTuple=leftTuple.getFirstChild();
          if (childLeftTuple != null) {
            childLeftTuple=deleteLeftChild(childLeftTuple,trgLeftTuples,stagedLeftTuples);
          }
        }
        leftTuple=temp;
      }
    }
    rightTuple.nullBlocked();
    rightTuple.clearStaged();
    rightTuple=next;
  }
}
