{
  boolean tupleMemory=true;
  LeftTupleMemory ltm=bm.getLeftTupleMemory();
  RightTupleMemory rtm=bm.getRightTupleMemory();
  ContextEntry[] contextEntry=bm.getContext();
  BetaConstraints constraints=existsNode.getRawConstraints();
  FastIterator rightIt=existsNode.getRightIterator(rtm);
  for (LeftTuple leftTuple=srcLeftTuples.getUpdateFirst(); leftTuple != null; ) {
    LeftTuple next=leftTuple.getStagedNext();
    PropagationContext context=leftTuple.getPropagationContext();
    RightTuple firstRightTuple=existsNode.getFirstRightTuple(leftTuple,rtm,context,rightIt);
    RightTuple blocker=leftTuple.getBlocker();
    if (blocker == null) {
      if (leftTuple.getMemory().isStagingMemory()) {
        leftTuple.getMemory().remove(leftTuple);
      }
 else {
        ltm.remove(leftTuple);
      }
      leftTuple.setMemory(null);
    }
 else {
      if (rtm.isIndexed() && !rightIt.isFullIterator()) {
        if (firstRightTuple == null || firstRightTuple.getMemory() != blocker.getMemory()) {
          removeBlocker(leftTuple,blocker);
          blocker=null;
        }
      }
    }
    constraints.updateFromTuple(contextEntry,wm,leftTuple);
    if (blocker == null || !constraints.isAllowedCachedLeft(contextEntry,blocker.getFactHandle())) {
      if (blocker != null) {
        removeBlocker(leftTuple,blocker);
      }
      for (RightTuple newBlocker=firstRightTuple; newBlocker != null; newBlocker=(RightTuple)rightIt.next(newBlocker)) {
        if (constraints.isAllowedCachedLeft(contextEntry,newBlocker.getFactHandle())) {
          leftTuple.setBlocker(newBlocker);
          newBlocker.addBlocked(leftTuple);
          break;
        }
      }
    }
    if (leftTuple.getBlocker() == null) {
      ltm.add(leftTuple);
      if (leftTuple.getFirstChild() != null) {
        if (leftTuple.getFirstChild() != null) {
          LeftTuple childLeftTuple=leftTuple.getFirstChild();
          while (childLeftTuple != null) {
            childLeftTuple=deleteLeftChild(trgLeftTuples,childLeftTuple,stagedLeftTuples);
          }
        }
      }
    }
 else     if (leftTuple.getFirstChild() == null) {
      trgLeftTuples.addInsert(sink.createLeftTuple(leftTuple,sink,tupleMemory));
    }
 else {
      if (leftTuple.getFirstChild() != null) {
        LeftTuple childLeftTuple=leftTuple.getFirstChild();
        while (childLeftTuple != null) {
switch (childLeftTuple.getStagedType()) {
case LeftTuple.INSERT:
            stagedLeftTuples.removeInsert(childLeftTuple);
          break;
case LeftTuple.UPDATE:
        stagedLeftTuples.removeUpdate(childLeftTuple);
      break;
  }
  trgLeftTuples.addUpdate(childLeftTuple);
  childLeftTuple.reAddRight();
  childLeftTuple=childLeftTuple.getLeftParentNext();
}
}
}
leftTuple.clearStaged();
leftTuple=next;
}
srcLeftTuples.setUpdate(null);
constraints.resetTuple(contextEntry);
}
