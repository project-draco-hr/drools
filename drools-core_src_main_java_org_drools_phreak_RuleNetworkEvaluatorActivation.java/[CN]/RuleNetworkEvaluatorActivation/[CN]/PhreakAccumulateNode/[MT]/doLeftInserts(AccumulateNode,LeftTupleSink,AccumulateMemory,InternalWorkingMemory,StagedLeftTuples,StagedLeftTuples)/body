{
  boolean tupleMemory=true;
  boolean tupleMemoryEnabled=true;
  Accumulate accumulate=accNode.getAccumulate();
  BetaMemory bm=am.getBetaMemory();
  LeftTupleMemory ltm=bm.getLeftTupleMemory();
  RightTupleMemory rtm=bm.getRightTupleMemory();
  ContextEntry[] contextEntry=bm.getContext();
  BetaConstraints constraints=accNode.getRawConstraints();
  FastIterator it=accNode.getRightIterator(rtm);
  for (LeftTuple leftTuple=srcLeftTuples.getInsertFirst(); leftTuple != null; ) {
    LeftTuple next=leftTuple.getStagedNext();
    PropagationContext context=leftTuple.getPropagationContext();
    AccumulateContext accresult=new AccumulateContext();
    boolean useLeftMemory=true;
    if (!tupleMemoryEnabled) {
      Object object=((InternalFactHandle)leftTuple.get(0)).getObject();
      if (!(object instanceof DroolsQuery) || !((DroolsQuery)object).isOpen()) {
        useLeftMemory=false;
      }
    }
    if (useLeftMemory) {
      ltm.add(leftTuple);
      leftTuple.setObject(accresult);
    }
    accresult.context=accumulate.createContext();
    accumulate.init(am.workingMemoryContext,accresult.context,leftTuple,wm);
    constraints.updateFromTuple(contextEntry,wm,leftTuple);
    FastIterator rightIt=accNode.getRightIterator(rtm);
    for (RightTuple rightTuple=accNode.getFirstRightTuple(leftTuple,rtm,context,rightIt); rightTuple != null; rightTuple=(RightTuple)rightIt.next(rightTuple)) {
      InternalFactHandle handle=rightTuple.getFactHandle();
      if (constraints.isAllowedCachedLeft(contextEntry,handle)) {
        addMatch(accNode,accumulate,leftTuple,rightTuple,null,null,wm,am,accresult,useLeftMemory);
      }
    }
    leftTuple.clearStaged();
    trgLeftTuples.addInsert(leftTuple);
    constraints.resetTuple(contextEntry);
    leftTuple=next;
  }
  srcLeftTuples.setInsert(null,0);
  constraints.resetTuple(contextEntry);
}
