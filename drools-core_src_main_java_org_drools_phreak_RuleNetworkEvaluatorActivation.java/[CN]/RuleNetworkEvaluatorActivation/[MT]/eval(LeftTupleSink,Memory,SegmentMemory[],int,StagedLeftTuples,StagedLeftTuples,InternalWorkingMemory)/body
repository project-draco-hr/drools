{
  StagedLeftTuples srcTuples=null;
  boolean foundSegmentTip=false;
  SegmentMemory smem=smems[smemIndex];
  while (true) {
    srcTuples=trgTuples;
    if (NodeTypeEnums.isTerminalNode(node)) {
      RuleTerminalNode rtn=rmem.getRuleTerminalNode();
      pRtnNode.doNode(rtn,wm,srcTuples);
      break;
    }
 else     if (NodeTypeEnums.RightInputAdaterNode == node.getType()) {
      return trgTuples;
    }
 else     if (nodeMem == null) {
      SegmentPropagator.propagate(smem,trgTuples,wm);
      smem=smems[smemIndex++];
      node=(LeftTupleSink)smem.getRootNode();
      nodeMem=smem.getNodeMemories().getFirst();
    }
    if (node == smem.getTipNode() && smem.getFirst() != null) {
      stagedLeftTuples=smem.getFirst().getStagedLeftTuples();
    }
 else {
      stagedLeftTuples=null;
    }
    trgTuples=new StagedLeftTuples();
    if (NodeTypeEnums.isBetaNode(node)) {
      BetaNode betaNode=(BetaNode)node;
      BetaMemory bm=(BetaMemory)nodeMem;
      if (betaNode.isRightInputIsRiaNode()) {
        srcTuples=doRiaNode(wm,srcTuples,betaNode,bm);
      }
switch (node.getType()) {
case NodeTypeEnums.JoinNode:
        pJoinNode.doNode((JoinNode)node,((LeftTupleSource)node).getSinkPropagator().getFirstLeftTupleSink(),bm,wm,srcTuples,trgTuples,stagedLeftTuples);
      break;
case NodeTypeEnums.NotNode:
    pNotNode.doNode((NotNode)node,((LeftTupleSource)node).getSinkPropagator().getFirstLeftTupleSink(),bm,wm,srcTuples,trgTuples,stagedLeftTuples);
  break;
case NodeTypeEnums.ExistsNode:
pExistsNode.doNode((ExistsNode)node,((LeftTupleSource)node).getSinkPropagator().getFirstLeftTupleSink(),bm,wm,srcTuples,trgTuples,stagedLeftTuples);
break;
case NodeTypeEnums.AccumulateNode:
break;
}
}
if (node == smem.getTipNode()) {
nodeMem=null;
continue;
}
LeftTupleSinkPropagator sink=((LeftTupleSource)node).getSinkPropagator();
LeftTupleSinkNode firstSink=(LeftTupleSinkNode)sink.getFirstLeftTupleSink();
LeftTupleSinkNode secondSink=firstSink.getNextLeftTupleSinkNode();
if (sink.size() == 2 && NodeTypeEnums.isBetaNode(secondSink) && ((BetaNode)secondSink).isRightInputIsRiaNode()) {
node=(LeftTupleSink)secondSink;
}
 else {
node=(LeftTupleSink)firstSink;
}
nodeMem=nodeMem.getNext();
}
return null;
}
