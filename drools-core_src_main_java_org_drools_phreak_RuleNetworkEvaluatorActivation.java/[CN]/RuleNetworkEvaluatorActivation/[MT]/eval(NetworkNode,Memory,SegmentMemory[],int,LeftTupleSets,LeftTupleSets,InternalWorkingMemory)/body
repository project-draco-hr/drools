{
  LeftTupleSets srcTuples;
  SegmentMemory smem=smems[smemIndex];
  while (true) {
    srcTuples=trgTuples;
    if (NodeTypeEnums.isTerminalNode(node)) {
      RuleTerminalNode rtn=rmem.getRuleTerminalNode();
      pRtnNode.doNode(rtn,wm,srcTuples);
      return null;
    }
 else     if (NodeTypeEnums.RightInputAdaterNode == node.getType()) {
      return trgTuples;
    }
    if (node == smem.getTipNode() && smem.getFirst() != null) {
      stagedLeftTuples=smem.getFirst().getStagedLeftTuples();
    }
 else {
      stagedLeftTuples=null;
    }
    LeftTupleSinkNode sink=((LeftTupleSource)node).getSinkPropagator().getFirstLeftTupleSink();
    trgTuples=new LeftTupleSets();
    if (NodeTypeEnums.isBetaNode(node)) {
      BetaNode betaNode=(BetaNode)node;
      BetaMemory bm=null;
      AccumulateMemory am=null;
      if (NodeTypeEnums.AccumulateNode == node.getType()) {
        am=(AccumulateMemory)nodeMem;
        bm=am.getBetaMemory();
      }
 else {
        bm=(BetaMemory)nodeMem;
      }
      if (betaNode.isRightInputIsRiaNode()) {
        srcTuples=doRiaNode(wm,srcTuples,betaNode,bm);
      }
switch (node.getType()) {
case NodeTypeEnums.JoinNode:
        pJoinNode.doNode((JoinNode)node,sink,bm,wm,srcTuples,trgTuples,stagedLeftTuples);
      break;
case NodeTypeEnums.NotNode:
    pNotNode.doNode((NotNode)node,sink,bm,wm,srcTuples,trgTuples,stagedLeftTuples);
  break;
case NodeTypeEnums.ExistsNode:
pExistsNode.doNode((ExistsNode)node,sink,bm,wm,srcTuples,trgTuples,stagedLeftTuples);
break;
case NodeTypeEnums.AccumulateNode:
pAccNode.doNode((AccumulateNode)node,sink,am,wm,srcTuples,trgTuples,stagedLeftTuples);
break;
}
}
 else if (node.getType() == NodeTypeEnums.EvalConditionNode) {
pEvalNode.doNode((EvalConditionNode)node,(EvalMemory)nodeMem,sink,wm,srcTuples,trgTuples,stagedLeftTuples);
}
 else if (node.getType() == NodeTypeEnums.FromNode) {
pFromNode.doNode((FromNode)node,(FromMemory)nodeMem,sink,wm,srcTuples,trgTuples,stagedLeftTuples);
}
 else if (true) {
pBranchNode.doNode((ConditionalBranchNode)node,(ConditionalBranchMemory)nodeMem,sink,wm,srcTuples,trgTuples,stagedLeftTuples);
}
if (node != smem.getTipNode()) {
LeftTupleSink nextSink=sink.getNextLeftTupleSinkNode();
if (nextSink == null) {
node=sink;
}
 else {
node=nextSink;
}
nodeMem=nodeMem.getNext();
}
 else {
SegmentPropagator.propagate(smem,trgTuples,wm);
smem=smems[++smemIndex];
trgTuples=smem.getStagedLeftTuples();
node=(LeftTupleSink)smem.getRootNode();
nodeMem=smem.getNodeMemories().getFirst();
}
}
}
