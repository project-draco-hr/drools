{
  LeftTupleSets srcTuples;
  SegmentMemory smem=smems[smemIndex];
  while (true) {
    srcTuples=trgTuples;
    if (NodeTypeEnums.isTerminalNode(node)) {
      RuleTerminalNode rtn=rmem.getRuleTerminalNode();
      pRtnNode.doNode(rtn,wm,srcTuples);
      return null;
    }
 else     if (NodeTypeEnums.RightInputAdaterNode == node.getType()) {
      return trgTuples;
    }
    if (node == smem.getTipNode() && smem.getFirst() != null) {
      stagedLeftTuples=smem.getFirst().getStagedLeftTuples();
    }
 else {
      stagedLeftTuples=null;
    }
    LeftTupleSinkNode sink=((LeftTupleSource)node).getSinkPropagator().getFirstLeftTupleSink();
    trgTuples=new LeftTupleSets();
    if (NodeTypeEnums.isBetaNode(node)) {
      BetaNode betaNode=(BetaNode)node;
      BetaMemory bm=null;
      AccumulateMemory am=null;
      if (NodeTypeEnums.AccumulateNode == node.getType()) {
        am=(AccumulateMemory)nodeMem;
      }
 else {
        bm=(BetaMemory)nodeMem;
      }
      if (betaNode.isRightInputIsRiaNode()) {
        srcTuples=doRiaNode(wm,srcTuples,betaNode,bm);
      }
switch (node.getType()) {
case NodeTypeEnums.JoinNode:
        pJoinNode.doNode((JoinNode)node,sink,bm,wm,srcTuples,trgTuples,stagedLeftTuples);
      break;
case NodeTypeEnums.NotNode:
    pNotNode.doNode((NotNode)node,sink,bm,wm,srcTuples,trgTuples,stagedLeftTuples);
  break;
case NodeTypeEnums.ExistsNode:
pExistsNode.doNode((ExistsNode)node,sink,bm,wm,srcTuples,trgTuples,stagedLeftTuples);
break;
case NodeTypeEnums.AccumulateNode:
pAccNode.doNode((AccumulateNode)node,sink,am,wm,srcTuples,trgTuples,stagedLeftTuples);
break;
}
}
if (node != smem.getTipNode()) {
LeftTupleSink nextSink=sink.getNextLeftTupleSinkNode();
if (nextSink == null) {
node=sink;
}
 else {
node=nextSink;
}
nodeMem=nodeMem.getNext();
}
 else {
SegmentPropagator.propagate(smem,trgTuples,wm);
smem=smems[smemIndex++];
trgTuples=smem.getStagedLeftTuples();
node=(LeftTupleSink)smem.getRootNode();
nodeMem=smem.getNodeMemories().getFirst();
}
}
}
