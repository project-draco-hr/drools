{
  int counter=0;
  long allLinkedTestMask=0;
  if (tupleSource.getSinkPropagator().size() > 1) {
    counter++;
  }
  ConditionalBranchNode cen=getConditionalBranchNode(tupleSource);
  boolean updateBitInNewSegment=true;
  boolean updateAllLinkedTest=(cen == null) ? true : false;
  boolean subnetworkBoundaryCrossed=false;
  while (tupleSource.getType() != NodeTypeEnums.LeftInputAdapterNode) {
    if (!subnetworkBoundaryCrossed && tupleSource.getType() == NodeTypeEnums.ConditionalBranchNode) {
      updateAllLinkedTest=true;
    }
    if (updateAllLinkedTest && updateBitInNewSegment && NodeTypeEnums.isBetaNode(tupleSource)) {
      updateBitInNewSegment=false;
      BetaNode bn=(BetaNode)tupleSource;
      if (bn.isRightInputIsRiaNode()) {
        RiaNodeMemory rnmem=(RiaNodeMemory)wm.getNodeMemory((MemoryFactory)bn.getRightInput());
        if (rnmem.getRiaPathMemory().getAllLinkedMaskTest() != 0) {
          allLinkedTestMask=allLinkedTestMask | 1;
        }
      }
 else       if ((!(NodeTypeEnums.NotNode == bn.getType() && !((NotNode)bn).isEmptyBetaConstraints()) && NodeTypeEnums.AccumulateNode != bn.getType())) {
        allLinkedTestMask=allLinkedTestMask | 1;
      }
    }
    if (!SegmentUtilities.parentInSameSegment(tupleSource)) {
      updateBitInNewSegment=true;
      allLinkedTestMask=allLinkedTestMask << 1;
      counter++;
    }
    tupleSource=tupleSource.getLeftTupleSource();
    if (tupleSource == startTupleSource) {
      subnetworkBoundaryCrossed=true;
      updateAllLinkedTest=false;
    }
  }
  if (!subnetworkBoundaryCrossed) {
    allLinkedTestMask=allLinkedTestMask | 1;
  }
  pmem.setAllLinkedMaskTest(allLinkedTestMask);
  pmem.setSegmentMemories(new SegmentMemory[counter + 1]);
}
