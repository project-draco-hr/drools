{
  LeftTupleSink lts=startNode;
  while (!NodeTypeEnums.isTerminalNode(lts) && lts.getLeftTupleSource().getType() != NodeTypeEnums.RightInputAdaterNode) {
    if (NodeTypeEnums.isBetaNode(lts)) {
      BetaNode bn=(BetaNode)lts;
      if (!bn.isRightInputIsRiaNode()) {
        BetaMemory bm;
        if (bn.getType() == NodeTypeEnums.AccumulateNode) {
          bm=((AccumulateMemory)wm.getNodeMemory(bn)).getBetaMemory();
        }
 else {
          bm=(BetaMemory)wm.getNodeMemory(bn);
        }
        TupleMemory rtm=bm.getRightTupleMemory();
        FastIterator it=rtm.fullFastIterator();
        for (RightTuple rightTuple=BetaNode.getFirstRightTuple(rtm,it); rightTuple != null; ) {
          RightTuple next=(RightTuple)it.next(rightTuple);
          rtm.remove(rightTuple);
          rightTuple.unlinkFromRightParent();
          rightTuple=next;
        }
        if (!bm.getStagedRightTuples().isEmpty()) {
          bm.setNodeDirtyWithoutNotify();
        }
        TupleSets<RightTuple> srcRightTuples=bm.getStagedRightTuples().takeAll();
        unlinkRightTuples(srcRightTuples.getInsertFirst());
        unlinkRightTuples(srcRightTuples.getUpdateFirst());
        unlinkRightTuples(srcRightTuples.getDeleteFirst());
        deleteFactsFromRightInput(bn,wm);
      }
 else {
        deleteSubnetworkFacts(bn,wm);
      }
    }
 else     if (lts.getType() == NodeTypeEnums.RightInputAdaterNode) {
      return;
    }
    lts=((LeftTupleSource)lts).getSinkPropagator().getFirstLeftTupleSink();
  }
}
