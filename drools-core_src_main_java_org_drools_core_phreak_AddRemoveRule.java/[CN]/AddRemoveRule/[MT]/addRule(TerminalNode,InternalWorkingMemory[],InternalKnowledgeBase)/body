{
  if (log.isTraceEnabled()) {
    log.trace("Adding Rule {}",tn.getRule().getName());
  }
  LeftTupleSource splitStartLeftTupleSource=getNetworkSplitPoint(tn);
  kBase.invalidateSegmentPrototype(splitStartLeftTupleSource,false);
  for (  InternalWorkingMemory wm : wms) {
    if (splitStartLeftTupleSource.getAssociationsSize() > 1) {
      List<PathMemory> pathMems=new ArrayList<PathMemory>();
      collectRtnPathMemories(splitStartLeftTupleSource,wm,pathMems,tn);
      PathMemory newPmem=wm.getNodeMemory(tn);
      int s=getSegmentPos(splitStartLeftTupleSource,null);
      LeftTupleSink[] sinks=splitStartLeftTupleSource.getSinkPropagator().getSinks();
      if (sinks.length == 2 || (sinks.length == 3 && NodeTypeEnums.isBetaNode(sinks[2])) && ((BetaNode)sinks[2]).isRightInputIsRiaNode()) {
        List<SegmentMemory[]> previousSmems=reInitPathMemories(wm,pathMems,null);
        int p=0;
        SegmentMemory splitSmem=null;
        for (        PathMemory pmem : pathMems) {
          pmem.setlinkedSegmentMask(0);
          SegmentMemory[] smems=previousSmems.get(p);
          for (int i=0; i < smems.length; i++) {
            SegmentMemory sm=smems[i];
            if (sm == null) {
              continue;
            }
            if (i < s) {
              correctSegmentBeforeSplitOnAdd(wm,newPmem,p,pmem,sm);
            }
 else             if (i == s) {
              splitSmem=correctSegmentOnSplitOnAdd(splitStartLeftTupleSource,wm,newPmem,p,splitSmem,pmem,sm);
            }
 else             if (i > s) {
              correctSegmentAfterSplitOnAdd(wm,pmem,i,sm);
            }
          }
          p++;
        }
      }
 else {
        SegmentMemory sm=pathMems.get(0).getSegmentMemories()[s];
        if (sm == null) {
          continue;
        }
        initNewSegment(splitStartLeftTupleSource,wm,sm);
        correctSegmentBeforeSplitOnAdd(wm,newPmem,pathMems.get(0),sm);
      }
    }
    if (NodeTypeEnums.LeftInputAdapterNode == splitStartLeftTupleSource.getType() && splitStartLeftTupleSource.getAssociationsSize() == 1) {
      insertLiaFacts(splitStartLeftTupleSource,wm);
    }
    correctMemoryOnSplitsChanged(splitStartLeftTupleSource,wm);
    insertFacts(splitStartLeftTupleSource.getSinkPropagator().getLastLeftTupleSink(),wm);
  }
}
