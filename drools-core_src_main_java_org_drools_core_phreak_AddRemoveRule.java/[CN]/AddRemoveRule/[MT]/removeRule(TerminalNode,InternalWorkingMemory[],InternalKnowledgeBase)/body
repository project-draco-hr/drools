{
  if (log.isTraceEnabled()) {
    log.trace("Removing Rule {}",tn.getRule().getName());
  }
  boolean hasProtos=kBase.hasSegmentPrototypes();
  boolean hasWms=wms.length > 0;
  if (!hasProtos && !hasWms) {
    return;
  }
  RuleImpl rule=tn.getRule();
  LeftTupleNode firstSplit=getNetworkSplitPoint(tn,rule);
  PathEndNodes pathEndNodes=getPathEndNodes(kBase,firstSplit,tn,rule,hasProtos,hasWms);
  for (  InternalWorkingMemory wm : wms) {
    wm.flushPropagations();
    PathEndNodeMemories tnms=getPathEndMemories(wm,pathEndNodes,true);
    if (NodeTypeEnums.LeftInputAdapterNode == firstSplit.getType() && firstSplit.getAssociatedRuleSize() == 1) {
      if (tnms.subjectPmem != null) {
        flushStagedTuples(firstSplit,tnms.subjectPmem,wm);
      }
      processLeftTuples(firstSplit,wm,false,tn.getRule());
      removeNewPaths(wm,tnms.subjectPmems);
    }
 else {
      for (      PathMemory pmem : tnms.pmemsToBeFlushed) {
        flushStagedTuples(firstSplit,pmem,wm);
      }
      processLeftTuples(firstSplit,wm,false,tn.getRule());
      Map<PathMemory,SegmentMemory[]> prevSmemsLookup=reInitPathMemories(wm,tnms.otherPmems,rule);
      Set<SegmentMemory> smemsToNotify=handleExistingPaths(rule,prevSmemsLookup,tnms.otherPmems,wm,ExistingPathStrategy.REMOVE_STRATEGY);
      removeNewPaths(wm,tnms.subjectPmems);
      notifySegments(smemsToNotify,wm);
    }
    if (tnms.subjectPmem != null && tnms.subjectPmem.getRuleAgendaItem() != null && tnms.subjectPmem.getRuleAgendaItem().isQueued()) {
      tnms.subjectPmem.getRuleAgendaItem().dequeue();
    }
  }
}
