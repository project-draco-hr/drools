{
  if (log.isTraceEnabled()) {
    log.trace("Removing Rule {}",tn.getRule().getName());
  }
  boolean hasProtos=kBase.hasSegmentPrototypes();
  boolean hasWms=wms.length > 0;
  if (!hasProtos && !hasWms) {
    return;
  }
  RuleImpl rule=tn.getRule();
  LeftTupleNode firstSplit=getNetworkSplitPoint(tn,rule);
  PathEndNodes pathEndNodes=getPathEndNodes(kBase,firstSplit,tn,rule,hasProtos,hasWms);
  for (  InternalWorkingMemory wm : wms) {
    wm.flushPropagations();
    PathEndNodeMemories tnms=getPathEndMemories(wm,pathEndNodes,true);
    if (!tnms.subjectPmems.isEmpty()) {
      if (NodeTypeEnums.LeftInputAdapterNode == firstSplit.getType() && firstSplit.getAssociatedRuleSize() == 1) {
        if (tnms.subjectPmem != null) {
          flushStagedTuples(firstSplit,tnms.subjectPmem,wm);
        }
        processLeftTuples(firstSplit,wm,false,tn.getRule());
        removeNewPaths(wm,tnms.subjectPmems);
      }
 else {
        flushStagedTuples(tnms.subjectPmem,pathEndNodes,wm);
        processLeftTuples(firstSplit,wm,false,tn.getRule());
        removeNewPaths(wm,tnms.subjectPmems);
        Map<PathMemory,SegmentMemory[]> prevSmemsLookup=reInitPathMemories(wm,tnms.otherPmems,rule);
        Set<SegmentMemory> smemsToNotify=handleExistingPaths(rule,prevSmemsLookup,tnms.otherPmems,wm,ExistingPathStrategy.REMOVE_STRATEGY);
        notifySegments(smemsToNotify,wm);
      }
    }
    if (tnms.subjectPmem != null && tnms.subjectPmem.isInitialized() && tnms.subjectPmem.getRuleAgendaItem().isQueued()) {
      tnms.subjectPmem.getRuleAgendaItem().dequeue();
    }
  }
}
