{
  int smemIndex=getSegmentPos(splitStartNode,null);
  SegmentMemory[] smems=pmem.getSegmentMemories();
  SegmentMemory sm;
  LeftTupleSink sink;
  Memory mem;
  long bit=1;
  if (smems.length == 1) {
    sm=smems[0];
    if (sm == null) {
      return;
    }
    sink=((LeftInputAdapterNode)sm.getRootNode()).getSinkPropagator().getFirstLeftTupleSink();
    mem=sm.getNodeMemories().get(1);
    bit=2;
  }
 else {
    sm=smems[++smemIndex];
    if (sm == null) {
      return;
    }
    sink=(LeftTupleSink)sm.getRootNode();
    mem=sm.getNodeMemories().get(0);
  }
  if (removeTuples) {
    processLeftTuples(splitStartNode,sink,sm,wm,false);
  }
  if (!sm.getStagedLeftTuples().isEmpty() && pmem.isRuleLinked()) {
    new RuleNetworkEvaluator().outerEval((LeftInputAdapterNode)smems[0].getRootNode(),pmem,sink,bit,mem,smems,smemIndex,sm.getStagedLeftTuples().takeAll(),wm,new LinkedList<StackEntry>(),true,pmem.getRuleAgendaItem().getRuleExecutor());
  }
}
