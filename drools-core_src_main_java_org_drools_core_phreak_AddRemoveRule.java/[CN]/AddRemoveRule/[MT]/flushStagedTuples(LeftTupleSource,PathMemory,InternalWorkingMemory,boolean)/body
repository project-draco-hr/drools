{
  int smemIndex=getSegmentPos(splitStartNode,null);
  SegmentMemory[] smems=pmem.getSegmentMemories();
  SegmentMemory sm;
  LeftTupleSink sink;
  Memory mem;
  long bit=1;
  if (smems.length == 1) {
    sm=smems[0];
    if (sm == null) {
      return;
    }
    sink=((LeftInputAdapterNode)sm.getRootNode()).getSinkPropagator().getFirstLeftTupleSink();
    mem=sm.getNodeMemories().get(1);
    bit=2;
  }
 else {
    sm=smems[smemIndex + 1];
    if (sm == null) {
      return;
    }
    sink=(LeftTupleSink)sm.getRootNode();
    mem=sm.getNodeMemories().get(0);
  }
  if (removeTuples) {
    processLeftTuples(splitStartNode,sink,sm,wm,false);
  }
  RuleNetworkEvaluator rne=new RuleNetworkEvaluator();
  LeftInputAdapterNode lian=(LeftInputAdapterNode)smems[0].getRootNode();
  LinkedList<StackEntry> stack=new LinkedList<StackEntry>();
  LinkedList<StackEntry> outerStack=new LinkedList<StackEntry>();
  Set<String> visitedRules=new HashSet<String>();
  if (!sm.getStagedLeftTuples().isEmpty() && pmem.isRuleLinked()) {
    rne.outerEval(lian,pmem,sink,bit,mem,smems,smemIndex,sm.getStagedLeftTuples(),wm,stack,outerStack,visitedRules,true,pmem.getRuleAgendaItem().getRuleExecutor());
  }
}
