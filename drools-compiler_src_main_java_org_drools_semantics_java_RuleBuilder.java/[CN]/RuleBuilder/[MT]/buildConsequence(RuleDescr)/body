{
  final String className="consequence";
  StringTemplate st=RuleBuilder.ruleGroup.getInstanceOf("consequenceMethod");
  st.setAttribute("methodName",className);
  final List[] usedIdentifiers=getUsedCIdentifiers(ruleDescr,ruleDescr.getConsequence());
  final Declaration[] declarations=new Declaration[usedIdentifiers[0].size()];
  for (int i=0, size=usedIdentifiers[0].size(); i < size; i++) {
    declarations[i]=(Declaration)this.declarations.get((String)usedIdentifiers[0].get(i));
  }
  setStringTemplateAttributes(st,declarations,(String[])usedIdentifiers[1].toArray(new String[usedIdentifiers[1].size()]),ruleDescr.getConsequence());
  st.setAttribute("text",this.functionFixer.fix(RuleBuilder.knowledgeHelperFixer.fix(ruleDescr.getConsequence()),variables));
  this.methods.add(st.toString());
  st=RuleBuilder.invokerGroup.getInstanceOf("consequenceInvoker");
  st.setAttribute("package",this.pkg.getName());
  st.setAttribute("ruleClassName",ucFirst(this.ruleDescr.getClassName()));
  st.setAttribute("invokerClassName",ruleDescr.getClassName() + ucFirst(className) + "Invoker");
  st.setAttribute("methodName",className);
  setStringTemplateAttributes(st,declarations,(String[])usedIdentifiers[1].toArray(new String[usedIdentifiers[1].size()]),ruleDescr.getConsequence());
  final List list=Arrays.asList(this.rule.getDeclarations());
  final int[] indexes=new int[declarations.length];
  for (int i=0, length=declarations.length; i < length; i++) {
    indexes[i]=list.indexOf(declarations[i]);
    if (indexes[i] == -1) {
      throw new RuntimeDroolsException("Unable to find declaration in list while generating the consequence invoker");
    }
  }
  st.setAttribute("indexes",indexes);
  st.setAttribute("text",ruleDescr.getConsequence());
  final String invokerClassName=this.pkg.getName() + "." + ruleDescr.getClassName()+ ucFirst(className)+ "Invoker";
  this.invokers.put(invokerClassName,st.toString());
  this.invokerLookups.put(invokerClassName,this.rule);
  this.descrLookups.put(invokerClassName,ruleDescr);
}
