{
  ObjectOutputStream stream=context.stream;
  InternalRuleBase ruleBase=context.ruleBase;
  InternalWorkingMemory wm=context.wm;
  LeftTupleSink sink=leftTuple.getLeftTupleSink();
switch (sink.getType()) {
case NodeTypeEnums.JoinNode:
{
      for (LeftTuple childLeftTuple=leftTuple.getFirstChild(); childLeftTuple != null; childLeftTuple=(LeftTuple)childLeftTuple.getLeftParentNext()) {
        stream.writeShort(PersisterEnums.RIGHT_TUPLE);
        int childSinkId=childLeftTuple.getLeftTupleSink().getId();
        stream.writeInt(childSinkId);
        stream.writeInt(childLeftTuple.getRightParent().getFactHandle().getId());
        writeLeftTuple(childLeftTuple,context,recurse);
      }
      stream.writeShort(PersisterEnums.END);
      break;
    }
case NodeTypeEnums.QueryRiaFixerNode:
case NodeTypeEnums.EvalConditionNode:
{
    for (LeftTuple childLeftTuple=leftTuple.getFirstChild(); childLeftTuple != null; childLeftTuple=(LeftTuple)childLeftTuple.getLeftParentNext()) {
      stream.writeShort(PersisterEnums.LEFT_TUPLE);
      stream.writeInt(childLeftTuple.getLeftTupleSink().getId());
      writeLeftTuple(childLeftTuple,context,recurse);
    }
    stream.writeShort(PersisterEnums.END);
    break;
  }
case NodeTypeEnums.NotNode:
case NodeTypeEnums.ForallNotNode:
{
  if (leftTuple.getBlocker() == null) {
    stream.writeShort(PersisterEnums.LEFT_TUPLE_NOT_BLOCKED);
    for (LeftTuple childLeftTuple=leftTuple.getFirstChild(); childLeftTuple != null; childLeftTuple=(LeftTuple)childLeftTuple.getLeftParentNext()) {
      stream.writeShort(PersisterEnums.LEFT_TUPLE);
      stream.writeInt(childLeftTuple.getLeftTupleSink().getId());
      writeLeftTuple(childLeftTuple,context,recurse);
    }
    stream.writeShort(PersisterEnums.END);
  }
 else {
    stream.writeShort(PersisterEnums.LEFT_TUPLE_BLOCKED);
    stream.writeInt(leftTuple.getBlocker().getFactHandle().getId());
  }
  break;
}
case NodeTypeEnums.ExistsNode:
{
if (leftTuple.getBlocker() == null) {
  stream.writeShort(PersisterEnums.LEFT_TUPLE_NOT_BLOCKED);
}
 else {
  stream.writeShort(PersisterEnums.LEFT_TUPLE_BLOCKED);
  stream.writeInt(leftTuple.getBlocker().getFactHandle().getId());
  for (LeftTuple childLeftTuple=leftTuple.getFirstChild(); childLeftTuple != null; childLeftTuple=(LeftTuple)childLeftTuple.getLeftParentNext()) {
    stream.writeShort(PersisterEnums.LEFT_TUPLE);
    stream.writeInt(childLeftTuple.getLeftTupleSink().getId());
    writeLeftTuple(childLeftTuple,context,recurse);
  }
  stream.writeShort(PersisterEnums.END);
}
break;
}
case NodeTypeEnums.AccumulateNode:
{
AccumulateMemory memory=(AccumulateMemory)context.wm.getNodeMemory((BetaNode)sink);
AccumulateContext accctx=(AccumulateContext)leftTuple.getObject();
writeFactHandle(context,stream,context.objectMarshallingStrategyStore,accctx.result.getFactHandle());
stream.writeObject(accctx.context);
stream.writeBoolean(accctx.propagated);
for (LeftTuple childLeftTuple=leftTuple.getFirstChild(); childLeftTuple != null; childLeftTuple=(LeftTuple)childLeftTuple.getLeftParentNext()) {
if (leftTuple.getLeftTupleSink().getId() == childLeftTuple.getLeftTupleSink().getId()) {
  stream.writeShort(PersisterEnums.RIGHT_TUPLE);
  stream.writeInt(childLeftTuple.getRightParent().getFactHandle().getId());
}
 else {
  stream.writeShort(PersisterEnums.LEFT_TUPLE);
  int sinkId=childLeftTuple.getLeftTupleSink().getId();
  stream.writeInt(sinkId);
  writeLeftTuple(childLeftTuple,context,recurse);
}
}
stream.writeShort(PersisterEnums.END);
break;
}
case NodeTypeEnums.RightInputAdaterNode:
{
ObjectHashMap memory=(ObjectHashMap)context.wm.getNodeMemory((MemoryFactory)sink);
InternalFactHandle ifh=(InternalFactHandle)memory.get(leftTuple);
stream.writeInt(ifh.getId());
stream.writeLong(ifh.getRecency());
writeRightTuples(ifh,context);
stream.writeShort(PersisterEnums.END);
break;
}
case NodeTypeEnums.FromNode:
{
FromMemory memory=(FromMemory)context.wm.getNodeMemory((MemoryFactory)sink);
Map<Object,RightTuple> matches=(Map<Object,RightTuple>)leftTuple.getObject();
for (RightTuple rightTuples : matches.values()) {
stream.writeShort(PersisterEnums.FACT_HANDLE);
writeFactHandle(context,stream,context.objectMarshallingStrategyStore,rightTuples.getFactHandle());
writeRightTuples(rightTuples.getFactHandle(),context);
}
stream.writeShort(PersisterEnums.END);
for (LeftTuple childLeftTuple=leftTuple.getFirstChild(); childLeftTuple != null; childLeftTuple=(LeftTuple)childLeftTuple.getLeftParentNext()) {
stream.writeShort(PersisterEnums.RIGHT_TUPLE);
stream.writeInt(childLeftTuple.getLeftTupleSink().getId());
stream.writeInt(childLeftTuple.getRightParent().getFactHandle().getId());
writeLeftTuple(childLeftTuple,context,recurse);
}
stream.writeShort(PersisterEnums.END);
break;
}
case NodeTypeEnums.UnificationNode:
{
QueryElementNode node=(QueryElementNode)sink;
boolean isOpen=node.isOpenQuery();
context.writeBoolean(isOpen);
if (isOpen) {
InternalFactHandle factHandle=(InternalFactHandle)leftTuple.getObject();
DroolsQuery query=(DroolsQuery)factHandle.getObject();
factHandle.setObject(null);
writeFactHandle(context,stream,context.objectMarshallingStrategyStore,0,factHandle);
factHandle.setObject(query);
writeLeftTuples(context,new InternalFactHandle[]{factHandle});
}
 else {
for (LeftTuple childLeftTuple=leftTuple.getFirstChild(); childLeftTuple != null; childLeftTuple=(LeftTuple)childLeftTuple.getLeftParentNext()) {
stream.writeShort(PersisterEnums.LEFT_TUPLE);
stream.writeInt(childLeftTuple.getLeftTupleSink().getId());
InternalFactHandle factHandle=childLeftTuple.getLastHandle();
writeFactHandle(context,stream,context.objectMarshallingStrategyStore,1,factHandle);
writeLeftTuple(childLeftTuple,context,recurse);
}
stream.writeShort(PersisterEnums.END);
}
break;
}
case NodeTypeEnums.RuleTerminalNode:
{
int pos=context.terminalTupleMap.size();
context.terminalTupleMap.put(leftTuple,pos);
break;
}
case NodeTypeEnums.QueryTerminalNode:
{
context.writeBoolean(true);
RightTuple rightTuple=(RightTuple)leftTuple.getObject();
writeFactHandle(context,stream,context.objectMarshallingStrategyStore,1,rightTuple.getFactHandle());
for (LeftTuple childLeftTuple=rightTuple.firstChild; childLeftTuple != null; childLeftTuple=(LeftTuple)childLeftTuple.getRightParentNext()) {
stream.writeShort(PersisterEnums.LEFT_TUPLE);
stream.writeInt(childLeftTuple.getLeftTupleSink().getId());
writeLeftTuple(childLeftTuple,context,recurse);
}
stream.writeShort(PersisterEnums.END);
break;
}
}
}
