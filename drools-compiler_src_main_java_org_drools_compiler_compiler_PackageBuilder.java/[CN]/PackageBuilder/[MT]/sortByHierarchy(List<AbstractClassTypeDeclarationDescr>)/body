{
  HierarchySorter<QualifiedName> sorter=new HierarchySorter<QualifiedName>();
  Map<QualifiedName,Collection<QualifiedName>> taxonomy=new HashMap<QualifiedName,Collection<QualifiedName>>();
  Map<QualifiedName,AbstractClassTypeDeclarationDescr> cache=new HashMap<QualifiedName,AbstractClassTypeDeclarationDescr>();
  for (  AbstractClassTypeDeclarationDescr tdescr : typeDeclarations) {
    QualifiedName name=tdescr.getType();
    cache.put(name,tdescr);
    if (taxonomy.get(name) == null) {
      taxonomy.put(name,new ArrayList<QualifiedName>());
    }
 else {
      this.results.add(new TypeDeclarationError(tdescr,"Found duplicate declaration for type " + tdescr.getTypeName()));
    }
    Collection<QualifiedName> supers=taxonomy.get(name);
    supers.addAll(tdescr.getSuperTypes());
    for (    TypeFieldDescr field : tdescr.getFields().values()) {
      QualifiedName typeName=new QualifiedName(field.getPattern().getObjectType());
      if (!typeName.equals(name) && !hasCircularDependency(name,typeName,taxonomy)) {
        supers.add(typeName);
      }
    }
  }
  List<QualifiedName> sorted=sorter.sort(taxonomy);
  ArrayList list=new ArrayList(sorted.size());
  for (  QualifiedName name : sorted) {
    list.add(cache.get(name));
  }
  return list;
}
