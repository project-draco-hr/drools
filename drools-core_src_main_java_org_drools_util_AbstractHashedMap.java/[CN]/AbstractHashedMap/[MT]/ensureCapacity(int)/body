{
  final int oldCapacity=this.data.length;
  if (newCapacity <= oldCapacity) {
    return;
  }
  if (this.size == 0) {
    this.threshold=calculateThreshold(newCapacity,this.loadFactor);
    this.data=new HashEntry[newCapacity];
  }
 else {
    final HashEntry oldEntries[]=this.data;
    final HashEntry newEntries[]=new HashEntry[newCapacity];
    this.modCount++;
    for (int i=oldCapacity - 1; i >= 0; i--) {
      HashEntry entry=oldEntries[i];
      if (entry != null) {
        oldEntries[i]=null;
        do {
          final HashEntry next=entry.next;
          final int index=hashIndex(entry.hashCode,newCapacity);
          entry.next=newEntries[index];
          newEntries[index]=entry;
          entry=next;
        }
 while (entry != null);
      }
    }
    this.threshold=calculateThreshold(newCapacity,this.loadFactor);
    this.data=newEntries;
  }
}
