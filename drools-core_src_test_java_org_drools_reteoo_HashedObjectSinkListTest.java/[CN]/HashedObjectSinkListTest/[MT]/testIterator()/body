{
  WorkingMemoryImpl workingMemory=new WorkingMemoryImpl(new RuleBaseImpl());
  MockObjectSource source=new MockObjectSource(15);
  MockObjectSink sink=new MockObjectSink();
  FieldExtractor extractor=new ClassFieldExtractor(Cheese.class,"type");
  FieldExtractor extractor2=new ClassFieldExtractor(Cheese.class,"price");
  FieldValue field1=new MockField("cheddar");
  FieldValue field2=new MockField("mussarela");
  Evaluator evaluator=EvaluatorFactory.getEvaluator(Evaluator.OBJECT_TYPE,Evaluator.EQUAL);
  LiteralConstraint constraint1=new LiteralConstraint(field1,extractor,evaluator);
  LiteralConstraint constraint2=new LiteralConstraint(field2,extractor,evaluator);
  LiteralConstraint constraint3=new LiteralConstraint(field2,extractor2,evaluator);
  AlphaNode alphaNode1=new AlphaNode(2,constraint1,source);
  alphaNode1.addObjectSink(sink);
  AlphaNode alphaNode2=new AlphaNode(2,constraint2,source);
  alphaNode2.addObjectSink(sink);
  Cheese cheddar=new Cheese("mussarela",5);
  FactHandleImpl f0=new FactHandleImpl(0);
  workingMemory.putObject(f0,cheddar);
  MockObjectSink mock=new MockObjectSink();
  list.add(mock);
  list.add(alphaNode1);
  list.add(alphaNode2);
  int flag=0;
  for (Iterator i=list.iterator(workingMemory,f0); i.hasNext(); ) {
    ObjectSink objsink=(ObjectSink)i.next();
    if (objsink == alphaNode2) {
      flag+=1;
    }
 else     if (objsink == mock) {
      flag+=2;
    }
 else {
      flag+=32;
    }
  }
  Assert.assertEquals("Iterator is returning wrong objects",3,flag);
}
