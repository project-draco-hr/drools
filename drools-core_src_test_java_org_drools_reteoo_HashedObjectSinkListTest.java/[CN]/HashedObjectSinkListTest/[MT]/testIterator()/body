{
  final ReteooWorkingMemory workingMemory=new ReteooWorkingMemory(1,(ReteooRuleBase)RuleBaseFactory.newRuleBase());
  final MockObjectSource source=new MockObjectSource(15);
  final MockObjectSink sink=new MockObjectSink();
  final FieldExtractor extractor=new ClassFieldExtractor(Cheese.class,"type");
  final FieldExtractor extractor2=new ClassFieldExtractor(Cheese.class,"price");
  final FieldValue field1=new MockField("cheddar");
  final FieldValue field2=new MockField("mussarela");
  final Evaluator evaluator=ValueType.OBJECT_TYPE.getEvaluator(Operator.EQUAL);
  final LiteralConstraint constraint1=new LiteralConstraint(extractor,evaluator,field1);
  final LiteralConstraint constraint2=new LiteralConstraint(extractor,evaluator,field2);
  final LiteralConstraint constraint3=new LiteralConstraint(extractor2,evaluator,field2);
  final AlphaNode alphaNode1=new AlphaNode(2,constraint1,source);
  alphaNode1.addObjectSink(sink);
  final AlphaNode alphaNode2=new AlphaNode(2,constraint2,source);
  alphaNode2.addObjectSink(sink);
  final Cheese cheddar=new Cheese("mussarela",5);
  final DefaultFactHandle f0=new DefaultFactHandle(0,cheddar);
  final MockObjectSink mock=new MockObjectSink();
  this.list.add(mock);
  this.list.add(alphaNode1);
  this.list.add(alphaNode2);
  int flag=0;
  for (final Iterator i=this.list.iterator(workingMemory,f0); i.hasNext(); ) {
    final ObjectSink objsink=(ObjectSink)i.next();
    if (objsink == alphaNode2) {
      flag+=1;
    }
 else     if (objsink == mock) {
      flag+=2;
    }
 else {
      flag+=32;
    }
  }
  Assert.assertEquals("Iterator is returning wrong objects",3,flag);
}
