{
  this.workingMemories=(WorkingMemoryImpl[])this.ruleBase.getWorkingMemories().toArray(new WorkingMemoryImpl[this.ruleBase.getWorkingMemories().size()]);
  And[] and=rule.getTransformedLhs();
  for (int i=0; i < and.length; i++) {
    addRule(and[i],rule);
  }
  BaseNode node=null;
  if (!(rule instanceof Query)) {
    node=new TerminalNode(this.id++,this.tupleSource,rule);
  }
 else {
    node=new QueryTerminalNode(this.id++,this.tupleSource,rule);
  }
  this.rules.put(rule,new BaseNode[]{node});
  if (this.workingMemories.length == 0) {
    node.attach();
  }
 else {
    node.attach(workingMemories,null);
  }
}
