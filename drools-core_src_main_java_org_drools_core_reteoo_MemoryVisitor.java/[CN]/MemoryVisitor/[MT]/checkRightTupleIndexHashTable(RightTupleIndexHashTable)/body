{
  final Entry[] entries=memory.getTable();
  int factCount=0;
  int bucketCount=0;
  FastIterator it=LinkedList.fastIterator;
  for (int i=0, length=entries.length; i < length; i++) {
    if (entries[i] != null) {
      RightTupleList rightTupleList=(RightTupleList)entries[i];
      while (rightTupleList != null) {
        if (rightTupleList.first != null) {
          Entry entry=rightTupleList.first;
          while (entry != null) {
            entry=it.next(entry);
            factCount++;
          }
        }
 else {
          logger.info("error : fieldIndexHashTable cannot have empty FieldIndexEntry objects");
        }
        rightTupleList=(RightTupleList)rightTupleList.getNext();
        bucketCount++;
      }
    }
  }
  try {
    final Field field=AbstractHashTable.class.getDeclaredField("size");
    field.setAccessible(true);
    logger.info(indent() + "FieldIndexBuckets: " + ((Integer)field.get(memory)).intValue()+ ":"+ bucketCount);
    if (((Integer)field.get(memory)).intValue() != bucketCount) {
      logger.info(indent() + "error");
    }
  }
 catch (  final Exception e) {
    e.printStackTrace();
  }
  logger.info(indent() + "FieldIndexFacts: " + memory.size()+ ":"+ factCount);
  if (memory.size() != factCount) {
    logger.info(indent() + "error");
  }
}
