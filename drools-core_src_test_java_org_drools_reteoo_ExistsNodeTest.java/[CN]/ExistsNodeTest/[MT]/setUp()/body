{
  constraint=mockery.mock(BetaNodeFieldConstraint.class);
  final ContextEntry c=mockery.mock(ContextEntry.class);
  mockery.checking(new Expectations(){
{
      allowing(constraint).createContextEntry();
      will(returnValue(c));
      allowing(c).updateFromFactHandle(with(any(InternalWorkingMemory.class)),with(any(InternalFactHandle.class)));
      allowing(c).updateFromTuple(with(any(InternalWorkingMemory.class)),with(any(LeftTuple.class)));
      allowing(c).resetTuple();
      allowing(c).resetFactHandle();
    }
  }
);
  this.rule=new Rule("test-rule");
  this.context=new PropagationContextImpl(0,PropagationContext.ASSERTION,null,null,null);
  ReteooRuleBase ruleBase=(ReteooRuleBase)RuleBaseFactory.newRuleBase();
  BuildContext buildContext=new BuildContext(ruleBase,ruleBase.getReteooBuilder().getIdGenerator());
  this.workingMemory=(ReteooWorkingMemory)ruleBase.newStatefulSession();
  final RuleBaseConfiguration configuration=new RuleBaseConfiguration();
  this.node=new ExistsNode(15,new MockTupleSource(5),new MockObjectSource(8),new DefaultBetaConstraints(new BetaNodeFieldConstraint[]{this.constraint},configuration),Behavior.EMPTY_BEHAVIOR_LIST,buildContext);
  this.sink=new MockLeftTupleSink();
  this.node.addTupleSink(this.sink);
  this.memory=(BetaMemory)this.workingMemory.getNodeMemory(this.node);
}
