{
  try {
    startOperation();
    this.ruleBase.readLock();
    this.lock.lock();
    final PropagationContext pCtx=pctxFactory.createPropagationContext(getNextPropagationIdCounter(),PropagationContext.INSERTION,null,null,factHandle,getEntryPoint());
    LeftInputAdapterNode lian=(LeftInputAdapterNode)factHandle.getFirstLeftTuple().getLeftTupleSink().getLeftTupleSource();
    LiaNodeMemory lmem=(LiaNodeMemory)getNodeMemory((MemoryFactory)lian);
    SegmentMemory lsmem=lmem.getSegmentMemory();
    LeftTuple childLeftTuple=factHandle.getFirstLeftTuple();
    LeftInputAdapterNode.doDeleteObject(childLeftTuple,childLeftTuple.getPropagationContext(),lsmem,this,lian,false,lmem);
    List<PathMemory> pmems=lmem.getSegmentMemory().getPathMemories();
    for (int i=0, length=pmems.size(); i < length; i++) {
      PathMemory rm=pmems.get(i);
      RuleAgendaItem evaluator=agenda.createRuleAgendaItem(Integer.MAX_VALUE,rm,(TerminalNode)rm.getNetworkNode());
      evaluator.getRuleExecutor().setDirty(true);
      evaluator.getRuleExecutor().evaluateNetworkAndFire(this,null,0,-1);
    }
    getFactHandleFactory().destroyFactHandle(factHandle);
  }
  finally {
    this.lock.unlock();
    this.ruleBase.readUnlock();
    endOperation();
  }
}
