{
  BaseNode[] tnodes=(BaseNode[])ruleBase.getReteooBuilder().getTerminalNodes(queryName);
  if (tnodes == null) {
    throw new RuntimeException("Query '" + queryName + "' does not exist");
  }
  QueryTerminalNode tnode=(QueryTerminalNode)tnodes[0];
  LeftTupleSource lts=tnode.getLeftTupleSource();
  while (lts.getType() != NodeTypeEnums.LeftInputAdapterNode) {
    lts=lts.getLeftTupleSource();
  }
  LeftInputAdapterNode lian=(LeftInputAdapterNode)lts;
  LiaNodeMemory lmem=(LiaNodeMemory)getNodeMemory((MemoryFactory)lts);
  SegmentMemory lsmem=lmem.getSegmentMemory();
  if (lsmem == null) {
    lsmem=SegmentUtilities.createSegmentMemory(lts,this);
  }
  LeftInputAdapterNode.doInsertObject(handle,pCtx,lian,this,lmem,false,queryObject.isOpen());
  RuleBaseConfiguration conf=this.ruleBase.getConfiguration();
  if (conf.isPhreakEnabled() && lmem.getSegmentMemory().getTupleQueue() != null) {
    RuleExecutor.flushTupleQueue(lmem.getSegmentMemory().getTupleQueue());
  }
  List<PathMemory> pmems=lmem.getSegmentMemory().getPathMemories();
  for (int i=0, length=pmems.size(); i < length; i++) {
    PathMemory rm=pmems.get(i);
    RuleAgendaItem evaluator=agenda.createRuleAgendaItem(Integer.MAX_VALUE,rm,(TerminalNode)rm.getNetworkNode());
    evaluator.getRuleExecutor().setDirty(true);
    evaluator.getRuleExecutor().evaluateNetworkAndFire(this,null,0,-1);
  }
  return tnodes;
}
