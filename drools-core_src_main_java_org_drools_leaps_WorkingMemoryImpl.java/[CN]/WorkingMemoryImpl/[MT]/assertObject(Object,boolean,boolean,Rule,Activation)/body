{
  FactHandleImpl handle=(FactHandleImpl)this.identityMap.get(object);
  if ((handle != null) && (logical)) {
    return handle;
  }
  Object logicalState=this.equalsMap.get(object);
  if ((handle != null) && (!logical) && logicalState == AbstractWorkingMemory.STATED) {
    return handle;
  }
  if (!logical) {
    if (logicalState instanceof FactHandleImpl) {
      handle=(FactHandleImpl)logicalState;
      handle.removeAllLogicalDependencies();
    }
 else {
      handle=(FactHandleImpl)newFactHandle(object);
    }
    putObject(handle,object);
    this.equalsMap.put(object,AbstractWorkingMemory.STATED);
    if (dynamic) {
      addPropertyChangeListener(object);
    }
  }
 else {
    if (logicalState == AbstractWorkingMemory.STATED) {
      return null;
    }
    handle=(FactHandleImpl)logicalState;
    if (handle == null) {
      handle=(FactHandleImpl)newFactHandle(object);
      putObject(handle,object);
      this.equalsMap.put(object,handle);
    }
    LeapsTuple tuple=(LeapsTuple)activation.getTuple();
    tuple.addLogicalDependency(handle);
    handle.addLogicalDependency(tuple);
  }
  Class objectClass=object.getClass();
  for (Iterator tables=this.getFactTablesList(objectClass).iterator(); tables.hasNext(); ) {
    FactTable factTable=(FactTable)tables.next();
    factTable.add(handle);
    for (Iterator tuples=factTable.getTuplesIterator(); tuples.hasNext(); ) {
      LeapsTuple tuple=(LeapsTuple)tuples.next();
      if (!tuple.isActivationNull()) {
        ColumnConstraints[] not=tuple.getLeapsRule().getNotColumnConstraints();
        for (int i=0, length=not.length; i < length; i++) {
          ColumnConstraints constraint=not[i];
          if (!tuple.isBlockingNotFactHandle(i) && constraint.getClassType().isAssignableFrom(objectClass) && constraint.isAllowed(handle,tuple,this)) {
            tuple.setBlockingNotFactHandle(handle,i);
            handle.addNotTuple(tuple,i);
          }
        }
        if (!tuple.isReadyForActivation()) {
          if (tuple.getLeapsRule().getRule() instanceof Query) {
            removeFromQueryResults(tuple.getLeapsRule().getRule().getName(),tuple);
          }
 else {
            invalidateActivation(tuple);
          }
        }
      }
 else {
        ColumnConstraints[] exists=tuple.getLeapsRule().getExistsColumnConstraints();
        for (int i=0, length=exists.length; i < length; i++) {
          ColumnConstraints constraint=exists[i];
          if (!tuple.isExistsFactHandle(i) && constraint.getClassType().isAssignableFrom(objectClass) && constraint.isAllowed(handle,tuple,this)) {
            tuple.setExistsFactHandle(handle,i);
            handle.addExistsTuple(tuple,i);
          }
        }
        if (tuple.isReadyForActivation()) {
          this.assertTuple(tuple);
        }
      }
    }
  }
  PropagationContextImpl context=new PropagationContextImpl(nextPropagationIdCounter(),PropagationContext.ASSERTION,rule,activation);
  this.pushTokenOnStack(handle,new Token(this,handle,context));
  this.workingMemoryEventSupport.fireObjectAsserted(context,handle,object);
  return handle;
}
