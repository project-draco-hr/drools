{
  this.getLock().lock();
  try {
    removePropertyChangeListener(handle);
    Object oldObject=removeObject(handle);
    if (removeLogical) {
      removeLogicalDependencies(handle);
    }
    if (removeLogical || updateEqualsMap) {
      FactStatus status=(FactStatus)this.equalsMap.get(oldObject);
      if (status != null) {
        status.decCounter();
        if (status.getCounter() <= 0) {
          this.equalsMap.remove(oldObject);
        }
      }
    }
    for (Iterator it=this.getFactTablesList(((FactHandleImpl)handle).getObject().getClass()).iterator(); it.hasNext(); ) {
      ((FactTable)it.next()).remove(handle);
    }
    Iterator tuples=((FactHandleImpl)handle).getActivatedTuples();
    for (; tuples != null && tuples.hasNext(); ) {
      LeapsTuple tuple=(LeapsTuple)tuples.next();
      if (tuple.getLeapsRule().getRule() instanceof Query) {
        removeFromQueryResults(tuple.getLeapsRule().getRule().getName(),tuple);
      }
 else {
        invalidateActivation(tuple);
      }
    }
    IdentityMap tuplesNotReadyForActivation=new IdentityMap();
    FactHandleTupleAssembly assembly;
    LeapsTuple tuple;
    Iterator it;
    it=((FactHandleImpl)handle).getNotTupleAssemblies();
    if (it != null) {
      for (; it.hasNext(); ) {
        assembly=(FactHandleTupleAssembly)it.next();
        tuple=assembly.getTuple();
        if (!tuple.isReadyForActivation()) {
          tuplesNotReadyForActivation.put(tuple,tuple);
        }
        tuple.removeBlockingNotFactHandle(assembly.getIndex());
        TokenEvaluator.evaluateNotCondition(new FactHandleImpl(((FactHandleImpl)handle).getId() + 1,null),assembly.getIndex(),tuple,this);
      }
    }
    it=((FactHandleImpl)handle).getExistsTupleAssemblies();
    if (it != null) {
      for (; it.hasNext(); ) {
        assembly=(FactHandleTupleAssembly)it.next();
        tuple=assembly.getTuple();
        if (!tuple.isReadyForActivation()) {
          tuplesNotReadyForActivation.put(tuple,tuple);
        }
        tuple.removeExistsFactHandle(assembly.getIndex());
        TokenEvaluator.evaluateExistsCondition(new FactHandleImpl(((FactHandleImpl)handle).getId() + 1,null),assembly.getIndex(),tuple,this);
      }
    }
    IteratorChain chain=new IteratorChain();
    it=((FactHandleImpl)handle).getNotTupleAssemblies();
    if (it != null) {
      chain.addIterator(it);
    }
    it=((FactHandleImpl)handle).getExistsTupleAssemblies();
    if (it != null) {
      chain.addIterator(it);
    }
    for (; chain.hasNext(); ) {
      tuple=((FactHandleTupleAssembly)chain.next()).getTuple();
      if (tuple.isReadyForActivation() && tuple.isActivationNull() && tuplesNotReadyForActivation.containsKey(tuple)) {
        tuple.setContext(new PropagationContextImpl(nextPropagationIdCounter(),PropagationContext.ASSERTION,tuple.getLeapsRule().getRule(),null));
        this.assertTuple(tuple);
      }
 else {
        if (tuple.getLeapsRule().getRule() instanceof Query) {
          removeFromQueryResults(tuple.getLeapsRule().getRule().getName(),tuple);
        }
 else {
          invalidateActivation(tuple);
        }
      }
    }
    this.removeTokenFromStack((FactHandleImpl)handle);
    PropagationContextImpl context=new PropagationContextImpl(nextPropagationIdCounter(),PropagationContext.RETRACTION,rule,activation);
    this.workingMemoryEventSupport.fireObjectRetracted(context,handle,oldObject);
  }
  finally {
    this.getLock().unlock();
  }
}
