{
  final BetaMemory memory=(BetaMemory)workingMemory.getNodeMemory(this);
  FastIterator it=memory.getRightTupleMemory().fastIterator();
  final RightTuple rootBlocker=(RightTuple)it.next(rightTuple);
  if (rightTuple.getMemory() == memory.getStagedAssertRightTupleList()) {
    memory.getStagedAssertRightTupleList().remove(rightTuple);
  }
 else {
    memory.getRightTupleMemory().remove(rightTuple);
  }
  rightTuple.setMemory(null);
  if (isUnlinkingEnabled() && memory.getAndDecCounter() == 0 && !isRightInputIsRiaNode()) {
    memory.unlinkNode(workingMemory);
  }
  if (rightTuple.getBlocked() == null) {
    return;
  }
  for (LeftTuple leftTuple=(LeftTuple)rightTuple.getBlocked(); leftTuple != null; ) {
    LeftTuple temp=leftTuple.getBlockedNext();
    leftTuple.setBlocker(null);
    leftTuple.setBlockedPrevious(null);
    leftTuple.setBlockedNext(null);
    this.constraints.updateFromTuple(memory.getContext(),workingMemory,leftTuple);
    for (RightTuple newBlocker=rootBlocker; newBlocker != null; newBlocker=(RightTuple)it.next(newBlocker)) {
      if (this.constraints.isAllowedCachedLeft(memory.getContext(),newBlocker.getFactHandle())) {
        leftTuple.setBlocker(newBlocker);
        newBlocker.addBlocked(leftTuple);
        break;
      }
    }
    if (leftTuple.getBlocker() == null) {
      memory.getLeftTupleMemory().add(leftTuple);
      this.sink.propagateRetractLeftTuple(leftTuple,context,workingMemory);
    }
    leftTuple=temp;
  }
  rightTuple.nullBlocked();
  this.constraints.resetTuple(memory.getContext());
}
