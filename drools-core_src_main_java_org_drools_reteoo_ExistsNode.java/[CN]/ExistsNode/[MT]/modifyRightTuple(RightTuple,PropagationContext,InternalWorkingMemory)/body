{
  final BetaMemory memory=(BetaMemory)workingMemory.getNodeMemory(this);
  if (memory.getLeftTupleMemory() == null || (memory.getLeftTupleMemory().size() == 0 && rightTuple.getBlocked() == null)) {
    memory.getRightTupleMemory().remove(rightTuple);
    memory.getRightTupleMemory().add(rightTuple);
    return;
  }
  this.constraints.updateFromFactHandle(memory.getContext(),workingMemory,rightTuple.getFactHandle());
  LeftTupleMemory leftMemory=memory.getLeftTupleMemory();
  LeftTuple firstLeftTuple=leftMemory.getFirst(rightTuple);
  LeftTuple firstBlocked=rightTuple.getBlocked();
  rightTuple.nullBlocked();
  FastIterator leftIt=memory.getRightTupleMemory().fastIterator();
  for (LeftTuple leftTuple=firstLeftTuple; leftTuple != null; ) {
    LeftTuple temp=(LeftTuple)leftIt.next(leftTuple);
    if (this.constraints.isAllowedCachedRight(memory.getContext(),leftTuple)) {
      leftTuple.setBlocker(rightTuple);
      rightTuple.addBlocked(leftTuple);
      leftMemory.remove(leftTuple);
      this.sink.propagateAssertLeftTuple(leftTuple,context,workingMemory,true);
    }
    leftTuple=temp;
  }
  if (firstBlocked != null) {
    FastIterator rightIt=memory.getRightTupleMemory().fastIterator();
    RightTuple rootBlocker=(RightTuple)rightIt.next(rightTuple);
    if (rootBlocker == null) {
      rootBlocker=rightTuple;
    }
    memory.getRightTupleMemory().remove(rightTuple);
    memory.getRightTupleMemory().add(rightTuple);
    for (LeftTuple leftTuple=(LeftTuple)firstBlocked; leftTuple != null; ) {
      LeftTuple temp=leftTuple.getBlockedNext();
      leftTuple.setBlockedPrevious(null);
      leftTuple.setBlockedNext(null);
      leftTuple.setBlocker(null);
      this.constraints.updateFromTuple(memory.getContext(),workingMemory,leftTuple);
      for (RightTuple newBlocker=rootBlocker; newBlocker != null; newBlocker=(RightTuple)rightIt.next(newBlocker)) {
        if (this.constraints.isAllowedCachedLeft(memory.getContext(),newBlocker.getFactHandle())) {
          leftTuple.setBlocker(newBlocker);
          newBlocker.addBlocked(leftTuple);
          break;
        }
      }
      if (leftTuple.getBlocker() == null) {
        memory.getLeftTupleMemory().add(leftTuple);
        this.sink.propagateRetractLeftTuple(leftTuple,context,workingMemory);
      }
      leftTuple=temp;
    }
  }
 else {
    memory.getRightTupleMemory().remove(rightTuple);
    memory.getRightTupleMemory().add(rightTuple);
  }
  this.constraints.resetFactHandle(memory.getContext());
  this.constraints.resetTuple(memory.getContext());
}
