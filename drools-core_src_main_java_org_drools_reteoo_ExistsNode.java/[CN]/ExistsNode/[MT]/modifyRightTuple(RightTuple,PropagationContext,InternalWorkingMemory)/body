{
  final BetaMemory memory=(BetaMemory)workingMemory.getNodeMemory(this);
  if (memory.getLeftTupleMemory() == null || (memory.getLeftTupleMemory().size() == 0 && rightTuple.getBlocked() == null)) {
    memory.getRightTupleMemory().removeAdd(rightTuple);
    return;
  }
  this.constraints.updateFromFactHandle(memory.getContext(),workingMemory,rightTuple.getFactHandle());
  LeftTupleMemory leftMemory=memory.getLeftTupleMemory();
  FastIterator leftIt=getLeftIterator(leftMemory);
  LeftTuple firstLeftTuple=getFirstLeftTuple(rightTuple,leftMemory,context,leftIt);
  LeftTuple firstBlocked=rightTuple.getBlocked();
  rightTuple.nullBlocked();
  for (LeftTuple leftTuple=firstLeftTuple; leftTuple != null; ) {
    LeftTuple temp=(LeftTuple)leftIt.next(leftTuple);
    if (this.constraints.isAllowedCachedRight(memory.getContext(),leftTuple)) {
      leftTuple.setBlocker(rightTuple);
      rightTuple.addBlocked(leftTuple);
      leftMemory.remove(leftTuple);
      this.sink.propagateAssertLeftTuple(leftTuple,context,workingMemory,true);
    }
    leftTuple=temp;
  }
  if (firstBlocked != null) {
    boolean useComparisonIndex=memory.getRightTupleMemory().getIndexType().isComparison();
    FastIterator rightIt=getRightIterator(memory.getRightTupleMemory());
    RightTuple rootBlocker=useComparisonIndex ? null : (RightTuple)rightIt.next(rightTuple);
    RightTupleList list=rightTuple.getMemory();
    memory.getRightTupleMemory().removeAdd(rightTuple);
    if (!useComparisonIndex && rootBlocker == null && list == rightTuple.getMemory()) {
      rootBlocker=rightTuple;
    }
    for (LeftTuple leftTuple=(LeftTuple)firstBlocked; leftTuple != null; ) {
      LeftTuple temp=leftTuple.getBlockedNext();
      leftTuple.setBlockedPrevious(null);
      leftTuple.setBlockedNext(null);
      leftTuple.setBlocker(null);
      this.constraints.updateFromTuple(memory.getContext(),workingMemory,leftTuple);
      if (useComparisonIndex) {
        rootBlocker=getFirstRightTuple(leftTuple,memory.getRightTupleMemory(),context,rightIt);
      }
      for (RightTuple newBlocker=rootBlocker; newBlocker != null; newBlocker=(RightTuple)rightIt.next(newBlocker)) {
        if (this.constraints.isAllowedCachedLeft(memory.getContext(),newBlocker.getFactHandle())) {
          leftTuple.setBlocker(newBlocker);
          newBlocker.addBlocked(leftTuple);
          break;
        }
      }
      if (leftTuple.getBlocker() == null) {
        memory.getLeftTupleMemory().add(leftTuple);
        this.sink.propagateRetractLeftTuple(leftTuple,context,workingMemory);
      }
      leftTuple=temp;
    }
  }
 else {
    memory.getRightTupleMemory().removeAdd(rightTuple);
  }
  this.constraints.resetFactHandle(memory.getContext());
  this.constraints.resetTuple(memory.getContext());
}
