{
  ObjectType objectType=data.getClassByPackageAndName(descr.getObjectType());
  if (objectType == null) {
    objectType=new ObjectType();
    objectType.setName(descr.getObjectType());
    data.add(objectType);
  }
  currentClass=objectType;
  Pattern pattern=new Pattern();
  pattern.setRuleId(currentRule.getId());
  pattern.setRuleName(currentRule.getRuleName());
  pattern.setClassId(objectType.getId());
  pattern.setName(objectType.getName());
  pattern.setPatternNot(solvers.getRuleSolver().isChildNot());
  pattern.setPatternExists(solvers.getRuleSolver().isExists());
  pattern.setPatternForall(solvers.getRuleSolver().isForall());
  pattern.setOrderNumber(orderNumber);
  pattern.setParent(parent);
  data.add(pattern);
  currentPattern=pattern;
  if (descr.getIdentifier() != null) {
    Variable variable=new Variable();
    variable.setRuleId(currentRule.getId());
    variable.setRuleName(currentRule.getRuleName());
    variable.setName(descr.getIdentifier());
    variable.setObjectType(VerifierComponentType.CLASS);
    variable.setObjectId(objectType.getId());
    variable.setObjectName(descr.getObjectType());
    data.add(variable);
  }
  if (descr.getSource() != null) {
    VerifierComponent source=flatten(descr.getSource(),pattern);
    pattern.setSourceId(source.getId());
    pattern.setSourceType(source.getComponentType());
  }
 else {
    pattern.setSourceId(0);
    pattern.setSourceType(VerifierComponentType.NOTHING);
  }
  solvers.startPatternSolver(pattern);
  flatten(descr.getConstraint(),pattern,0);
  solvers.endPatternSolver();
  return pattern.getId();
}
