{
  WorkingMemoryImpl workingMemory=(WorkingMemoryImpl)token.getWorkingMemory();
  LeapsRule leapsRule=token.getCurrentRuleHandle().getLeapsRule();
  int numberOfColumns=leapsRule.getNumberOfColumns();
  if (numberOfColumns > 0) {
    int dominantFactPosition=token.getCurrentRuleHandle().getDominantPosition();
    if (leapsRule.getColumnConstraintsAtPosition(dominantFactPosition).isAllowedAlpha(token.getDominantFactHandle(),token,workingMemory)) {
      TableIterator[] iterators=new TableIterator[numberOfColumns];
      for (int i=0; i < numberOfColumns; i++) {
        if (i == dominantFactPosition) {
          iterators[i]=Table.singleItemIterator(token.getDominantFactHandle());
        }
 else {
          if (i > 0 && leapsRule.getColumnConstraintsAtPosition(i).isAlphaPresent()) {
            iterators[i]=workingMemory.getFactTable(leapsRule.getColumnClassObjectTypeAtPosition(i)).tailConstrainedIterator(workingMemory,leapsRule.getColumnConstraintsAtPosition(i),token.getDominantFactHandle(),(token.isResume() ? token.get(i) : token.getDominantFactHandle()));
          }
 else {
            iterators[i]=workingMemory.getFactTable(leapsRule.getColumnClassObjectTypeAtPosition(i)).tailIterator(token.getDominantFactHandle(),(token.isResume() ? token.get(i) : token.getDominantFactHandle()));
          }
        }
      }
      boolean someIteratorsEmpty=false;
      boolean doReset=false;
      boolean skip=token.isResume();
      TableIterator currentIterator;
      for (int i=0; i < numberOfColumns && !someIteratorsEmpty; i++) {
        currentIterator=iterators[i];
        if (currentIterator.isEmpty()) {
          someIteratorsEmpty=true;
        }
 else {
          if (!doReset) {
            if (skip && currentIterator.hasNext() && !currentIterator.peekNext().equals(token.get(i))) {
              skip=false;
              doReset=true;
            }
          }
 else {
            currentIterator.reset();
          }
        }
      }
      if (someIteratorsEmpty) {
        throw new NoMatchesFoundException();
      }
      int jj=0;
      boolean done=false;
      while (!done) {
        currentIterator=iterators[jj];
        if (!currentIterator.hasNext()) {
          if (jj == 0) {
            done=true;
          }
 else {
            currentIterator.reset();
            token.set(jj,(FactHandleImpl)null);
            jj=jj - 1;
            if (skip) {
              skip=false;
            }
          }
        }
 else {
          currentIterator.next();
          token.set(jj,(FactHandleImpl)iterators[jj].current());
          boolean localMatch=false;
          if (jj == 0 && jj != dominantFactPosition) {
            localMatch=leapsRule.getColumnConstraintsAtPosition(jj).isAllowed(token.get(jj),token,workingMemory);
          }
 else {
            localMatch=leapsRule.getColumnConstraintsAtPosition(jj).isAllowedBeta(token.get(jj),token,workingMemory);
          }
          if (localMatch) {
            if (jj == (numberOfColumns - 1)) {
              if (!skip) {
                if (processAfterAllPositiveConstraintOk(token,leapsRule,workingMemory)) {
                  return;
                }
              }
 else {
                skip=false;
              }
            }
 else {
              jj=jj + 1;
            }
          }
 else {
            if (skip) {
              skip=false;
            }
          }
        }
      }
    }
  }
 else {
    if (processAfterAllPositiveConstraintOk(token,leapsRule,workingMemory)) {
      return;
    }
  }
  throw new NoMatchesFoundException();
}
