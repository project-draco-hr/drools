{
  boolean found=false;
  WorkingMemoryImpl workingMemory=(WorkingMemoryImpl)token.getWorkingMemory();
  int dominantFactPosition=token.getCurrentRuleHandle().getDominantPosition();
  LeapsRule leapsRule=token.getCurrentRuleHandle().getLeapsRule();
  if (leapsRule.getColumnConstraintsAtPosition(dominantFactPosition).isAllowedAlpha(token.getDominantFactHandle(),token,workingMemory)) {
    int numberOfColumns=leapsRule.getNumberOfColumns();
    TableIterator[] iterators=new TableIterator[numberOfColumns];
    for (int i=0; i < numberOfColumns; i++) {
      if (i == dominantFactPosition) {
        iterators[i]=Table.singleItemIterator(token.getDominantFactHandle());
      }
 else {
        if (i > 0 && leapsRule.getColumnConstraintsAtPosition(i).isAlphaPresent()) {
          iterators[i]=workingMemory.getFactTable(leapsRule.getColumnClassObjectTypeAtPosition(i).getClassType()).tailConstrainedIterator(workingMemory,leapsRule.getColumnConstraintsAtPosition(i),token.getDominantFactHandle(),(token.isResume() ? token.get(i) : token.getDominantFactHandle()));
        }
 else {
          iterators[i]=workingMemory.getFactTable(leapsRule.getColumnClassObjectTypeAtPosition(i).getClassType()).tailIterator(token.getDominantFactHandle(),(token.isResume() ? token.get(i) : token.getDominantFactHandle()));
        }
      }
    }
    boolean someIteratorsEmpty=false;
    boolean doReset=false;
    boolean skip=token.isResume();
    TableIterator currentIterator;
    for (int i=0; i < numberOfColumns && !someIteratorsEmpty; i++) {
      currentIterator=iterators[i];
      if (currentIterator.isEmpty()) {
        someIteratorsEmpty=true;
      }
 else {
        if (!doReset) {
          if (skip && currentIterator.hasNext() && !currentIterator.peekNext().equals(token.get(i))) {
            skip=false;
            doReset=true;
          }
        }
 else {
          currentIterator.reset();
        }
      }
    }
    if (someIteratorsEmpty) {
      throw new NoMatchesFoundException();
    }
    int jj=0;
    boolean done=false;
    while (!done) {
      currentIterator=iterators[jj];
      if (!currentIterator.hasNext()) {
        if (jj == 0) {
          done=true;
        }
 else {
          currentIterator.reset();
          token.set(jj,(FactHandleImpl)null);
          jj=jj - 1;
          if (skip) {
            skip=false;
          }
        }
      }
 else {
        currentIterator.next();
        token.set(jj,(FactHandleImpl)iterators[jj].current());
        boolean localMatch=false;
        if (jj == 0 && jj != dominantFactPosition) {
          localMatch=leapsRule.getColumnConstraintsAtPosition(jj).isAllowed(token.get(jj),token,workingMemory);
        }
 else {
          localMatch=leapsRule.getColumnConstraintsAtPosition(jj).isAllowedBeta(token.get(jj),token,workingMemory);
        }
        if (localMatch) {
          if (jj == (numberOfColumns - 1)) {
            if (!skip) {
              LeapsTuple tuple=token.getTuple(new PropagationContextImpl(workingMemory.increamentPropagationIdCounter(),PropagationContext.ASSERTION,leapsRule.getRule(),(Activation)null));
              if (tuple.isExistsConstraintsPresent()) {
                TokenEvaluator.evaluateExistsConditions(tuple,workingMemory);
              }
              if (tuple.isNotConstraintsPresent()) {
                TokenEvaluator.evaluateNotConditions(tuple,workingMemory);
              }
              if (tuple.isReadyForActivation()) {
                workingMemory.assertTuple(tuple,leapsRule.getRule());
                done=true;
                found=true;
              }
            }
 else {
              skip=false;
            }
          }
 else {
            jj=jj + 1;
          }
        }
 else {
          if (skip) {
            skip=false;
          }
        }
      }
    }
  }
  if (!found) {
    throw new NoMatchesFoundException();
  }
}
