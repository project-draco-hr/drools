{
  if (kProject instanceof ClasspathKieProject) {
    throw new UnsupportedOperationException("It is not possible to update a classpath container to a new version.");
  }
  ReleaseId currentReleaseId=kProject.getGAV();
  InternalKieModule currentKM=currentReleaseId.equals(newReleaseId) && !currentReleaseId.equals(kr.getDefaultReleaseId()) ? (InternalKieModule)((KieRepositoryImpl)kr).getOldKieModule(currentReleaseId) : (InternalKieModule)kr.getKieModule(currentReleaseId);
  InternalKieModule newKM=(InternalKieModule)kr.getKieModule(newReleaseId);
  ChangeSetBuilder csb=new ChangeSetBuilder();
  KieJarChangeSet cs=csb.build(currentKM,newKM);
  ((KieModuleKieProject)kProject).updateToModule(newKM);
  List<String> kbasesToRemove=new ArrayList<String>();
  for (  Map.Entry<String,KieBase> kBaseEntry : kBases.entrySet()) {
    String kbaseName=kBaseEntry.getKey();
    KieBaseModel kieBaseModel=kProject.getKieBaseModel(kbaseName);
    if (kieBaseModel == null) {
      kbasesToRemove.add(kbaseName);
    }
 else {
      KnowledgeBuilder kbuilder=KnowledgeBuilderFactory.newKnowledgeBuilder((KnowledgeBase)kBaseEntry.getValue());
      PackageBuilder pkgbuilder=kbuilder instanceof PackageBuilder ? ((PackageBuilder)kbuilder) : ((KnowledgeBuilderImpl)kbuilder).getPackageBuilder();
      CompositeKnowledgeBuilder ckbuilder=kbuilder.batch();
      List<String> modifiedClasses=new ArrayList<String>();
      int fileCount=0;
      for (      ResourceChangeSet rcs : cs.getChanges().values()) {
        if (rcs.getChangeType() != ChangeType.REMOVED) {
          String resourceName=rcs.getResourceName();
          if (!resourceName.endsWith(".properties") && filterFileInKBase(newKM,kieBaseModel,resourceName)) {
            Resource resource=currentKM.getResource(resourceName);
            List<ResourceChange> changes=rcs.getChanges();
            if (!changes.isEmpty()) {
              fileCount+=AbstractKieModule.updateResource(ckbuilder,newKM,resourceName,rcs) ? 1 : 0;
            }
 else {
              if (rcs.getChangeType() == ChangeType.UPDATED) {
                pkgbuilder.removeObjectsGeneratedFromResource(resource);
              }
              fileCount+=AbstractKieModule.addFile(ckbuilder,newKM,resourceName) ? 1 : 0;
            }
          }
 else           if (resourceName.endsWith(".class")) {
            modifiedClasses.add(resourceName);
            fileCount++;
          }
        }
        KieBase kBase=kBaseEntry.getValue();
        for (        ResourceChangeSet.RuleLoadOrder loadOrder : rcs.getLoadOrder()) {
          Rule rule=(Rule)((KnowledgePackageImp)kBase.getKiePackage(loadOrder.getPkgName())).getRule(loadOrder.getRuleName());
          if (rule != null) {
            rule.setLoadOrder(loadOrder.getLoadOrder());
          }
        }
      }
      pkgbuilder.startPackageUpdate();
      try {
        for (        ResourceChangeSet rcs : cs.getChanges().values()) {
          if (rcs.getChangeType() == ChangeType.REMOVED) {
            String resourceName=rcs.getResourceName();
            if (!resourceName.endsWith(".properties") && filterFileInKBase(newKM,kieBaseModel,resourceName)) {
              pkgbuilder.removeObjectsGeneratedFromResource(currentKM.getResource(resourceName));
            }
          }
        }
        if (fileCount > 0) {
          Set<String> modifiedPackages=new HashSet<String>();
          if (!modifiedClasses.isEmpty()) {
            ClassLoader rootClassLoader=pkgbuilder.getRootClassLoader();
            if (rootClassLoader instanceof ProjectClassLoader) {
              ProjectClassLoader projectClassLoader=(ProjectClassLoader)rootClassLoader;
              projectClassLoader.reinitTypes();
              for (              String resourceName : modifiedClasses) {
                String className=convertResourceToClassName(resourceName);
                byte[] bytes=newKM.getBytes(resourceName);
                Class<?> clazz=projectClassLoader.defineClass(className,resourceName,bytes);
                modifiedPackages.add(clazz.getPackage().getName());
              }
              pkgbuilder.setAllRuntimesDirty(modifiedPackages);
            }
          }
          ckbuilder.build();
          if (!modifiedClasses.isEmpty()) {
            pkgbuilder.rewireClassObjectTypes(modifiedPackages);
          }
        }
      }
  finally {
        pkgbuilder.completePackageUpdate();
      }
    }
  }
  for (  String kbaseToRemove : kbasesToRemove) {
    kBases.remove(kbaseToRemove);
  }
  for (Iterator<Map.Entry<String,KieSession>> it=this.kSessions.entrySet().iterator(); it.hasNext(); ) {
    Entry<String,KieSession> ksession=it.next();
    if (kProject.getKieSessionModel(ksession.getKey()) == null) {
      it.remove();
    }
  }
  for (Iterator<Map.Entry<String,StatelessKieSession>> it=this.statelessKSessions.entrySet().iterator(); it.hasNext(); ) {
    Entry<String,StatelessKieSession> ksession=it.next();
    if (kProject.getKieSessionModel(ksession.getKey()) == null) {
      it.remove();
    }
  }
}
