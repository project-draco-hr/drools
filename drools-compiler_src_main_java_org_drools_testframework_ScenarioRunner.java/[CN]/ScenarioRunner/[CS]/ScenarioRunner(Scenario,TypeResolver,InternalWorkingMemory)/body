{
  this.scenario=scenario;
  this.workingMemory=wm;
  scenario.lastRunResult=new Date();
  HashSet<String> ruleList=new HashSet<String>();
  ruleList.addAll(scenario.rules);
  TestingEventListener.stubOutRules(ruleList,wm.getRuleBase(),scenario.inclusive);
  TestingEventListener listener=null;
  for (Iterator iterator=scenario.globals.iterator(); iterator.hasNext(); ) {
    FactData fact=(FactData)iterator.next();
    Object f=eval("new " + resolver.getFullTypeName(fact.type) + "()");
    populateFields(fact,globalData,f);
    globalData.put(fact.name,f);
    wm.setGlobal(fact.name,f);
  }
  for (Iterator<Fixture> iterator=scenario.fixtures.iterator(); iterator.hasNext(); ) {
    Fixture fx=iterator.next();
    if (fx instanceof FactData) {
      FactData fact=(FactData)fx;
      Object f=(fact.isModify) ? this.populatedData.get(fact.name) : eval("new " + resolver.getFullTypeName(fact.type) + "()");
      if (fact.isModify) {
        if (!this.factHandles.containsKey(fact.name)) {
          throw new IllegalArgumentException("Was not a previously inserted fact. [" + fact.name + "]");
        }
        populateFields(fact,populatedData,f);
        this.workingMemory.update(this.factHandles.get(fact.name),f);
      }
 else {
        populateFields(fact,populatedData,f);
        populatedData.put(fact.name,f);
        this.factHandles.put(fact.name,wm.insert(f));
      }
    }
 else     if (fx instanceof RetractFact) {
      RetractFact f=(RetractFact)fx;
      this.workingMemory.retract(this.factHandles.get(f.name));
      this.populatedData.remove(f.name);
    }
 else     if (fx instanceof ExecutionTrace) {
      ExecutionTrace executionTrace=(ExecutionTrace)fx;
      if (listener != null)       wm.removeEventListener(listener);
      listener=new TestingEventListener();
      wm.addEventListener(listener);
      applyTimeMachine(wm,executionTrace);
      long time=System.currentTimeMillis();
      wm.fireAllRules(scenario.maxRuleFirings);
      executionTrace.executionTimeResult=System.currentTimeMillis() - time;
      executionTrace.numberOfRulesFired=listener.totalFires;
    }
 else     if (fx instanceof Expectation) {
      Expectation assertion=(Expectation)fx;
      if (assertion instanceof VerifyFact) {
        verify((VerifyFact)assertion);
      }
 else       if (assertion instanceof VerifyRuleFired) {
        verify((VerifyRuleFired)assertion,(listener.firingCounts != null) ? listener.firingCounts : new HashMap<String,Integer>());
      }
    }
 else {
      throw new IllegalArgumentException("Not sure what to do with " + fx);
    }
  }
}
