{
  context.visitTupleSource(this);
  if (!node.isInUse()) {
    removeTupleSink((LeftTupleSink)node);
  }
  if (!this.isInUse()) {
    for (int i=0, length=workingMemories.length; i < length; i++) {
      BetaMemory memory=null;
      Object object=workingMemories[i].getNodeMemory(this);
      if (object instanceof CollectMemory) {
        ((CollectNode)this).doRemove(workingMemories[i],(CollectMemory)object);
        memory=((CollectMemory)object).betaMemory;
      }
 else       if (object instanceof AccumulateMemory) {
        ((AccumulateNode)this).doRemove(workingMemories[i],(AccumulateMemory)object);
        memory=((AccumulateMemory)object).betaMemory;
      }
 else {
        memory=(BetaMemory)object;
      }
      Iterator it=memory.getLeftTupleMemory().iterator();
      for (LeftTuple leftTuple=(LeftTuple)it.next(); leftTuple != null; leftTuple=(LeftTuple)it.next()) {
        leftTuple.unlinkFromLeftParent();
        leftTuple.unlinkFromRightParent();
      }
      it=memory.getRightTupleMemory().iterator();
      for (RightTuple rightTuple=(RightTuple)it.next(); rightTuple != null; rightTuple=(RightTuple)it.next()) {
        if (rightTuple.getBlocked() != null) {
          for (LeftTuple leftTuple=(LeftTuple)rightTuple.getBlocked(); leftTuple != null; ) {
            LeftTuple temp=leftTuple.getBlockedNext();
            leftTuple.setBlocker(null);
            leftTuple.setBlockedPrevious(null);
            leftTuple.setBlockedNext(null);
            leftTuple.unlinkFromLeftParent();
            leftTuple=temp;
          }
        }
        if (rightTuple.getRightTupleSink() == null) {
          workingMemories[i].getFactHandleFactory().destroyFactHandle(rightTuple.getFactHandle());
        }
        rightTuple.unlinkFromRightParent();
      }
      workingMemories[i].clearNodeMemory(this);
    }
  }
  this.rightInput.remove(context,builder,this,workingMemories);
  if (!context.alreadyVisited(this.leftInput)) {
    this.leftInput.remove(context,builder,this,workingMemories);
  }
}
