{
  CharStream input;
  if (isFile == true) {
    input=new ANTLRFileStream(testInput);
  }
 else {
    input=new ANTLRStringStream(testInput);
  }
  try {
    DRLLexer lexer=new DRLLexer(input);
    CommonTokenStream tokens=new CommonTokenStream(lexer);
    DRLParser parser=new DRLParser(tokens);
    parser.setTreeAdaptor(new DroolsTreeAdaptor());
    Method ruleName=Class.forName("org.drools.lang.DRLParser").getMethod(testRuleName);
    PipedInputStream pipedIn=new PipedInputStream();
    PipedOutputStream pipedOut=new PipedOutputStream();
    PipedInputStream pipedErrIn=new PipedInputStream();
    PipedOutputStream pipedErrOut=new PipedOutputStream();
    try {
      pipedOut.connect(pipedIn);
      pipedErrOut.connect(pipedErrIn);
    }
 catch (    IOException e) {
      System.err.println("connection failed...");
      System.exit(1);
    }
    PrintStream console=System.out;
    PrintStream consoleErr=System.err;
    PrintStream ps=new PrintStream(pipedOut);
    PrintStream ps2=new PrintStream(pipedErrOut);
    System.setOut(ps);
    System.setErr(ps2);
    Object ruleReturn=ruleName.invoke(parser);
    String astString=null;
    if (ruleReturn != null) {
      if (ruleReturn.toString().indexOf(testRuleName + "_return") > 0) {
        try {
          Class _return=Class.forName("org.drools.lang.DRLParser" + "$" + testRuleName + "_return");
          Method[] methods=_return.getDeclaredMethods();
          for (          Method method : methods) {
            if (method.getName().equals("getTree")) {
              Method returnName=_return.getMethod("getTree");
              CommonTree tree=(CommonTree)returnName.invoke(ruleReturn);
              astString=tree.toStringTree();
            }
          }
        }
 catch (        Exception e) {
          System.err.println(e);
        }
      }
    }
    org.antlr.gunit.gUnitExecuter.StreamVacuum stdoutVacuum=new org.antlr.gunit.gUnitExecuter.StreamVacuum(pipedIn);
    org.antlr.gunit.gUnitExecuter.StreamVacuum stderrVacuum=new org.antlr.gunit.gUnitExecuter.StreamVacuum(pipedErrIn);
    ps.close();
    ps2.close();
    System.setOut(console);
    System.setErr(consoleErr);
    this.stdout=null;
    this.stderr=null;
    stdoutVacuum.start();
    stderrVacuum.start();
    stdoutVacuum.join();
    stderrVacuum.join();
    if (stderrVacuum.toString().length() > 0) {
      this.stderr=stderrVacuum.toString();
      return this.stderr;
    }
    if (parser.hasErrors()) {
      this.stderr=parser.getErrors().toString();
      return this.stderr;
    }
    if (stdoutVacuum.toString().length() > 0) {
      this.stdout=stdoutVacuum.toString();
    }
    if (astString != null) {
      return astString;
    }
    if (ruleReturn != null) {
      return ruleReturn;
    }
    if (stderrVacuum.toString().length() == 0 && stdoutVacuum.toString().length() == 0) {
      return null;
    }
  }
 catch (  ClassNotFoundException e) {
    e.printStackTrace();
    System.exit(1);
  }
catch (  SecurityException e) {
    e.printStackTrace();
    System.exit(1);
  }
catch (  NoSuchMethodException e) {
    e.printStackTrace();
    System.exit(1);
  }
catch (  IllegalAccessException e) {
    e.printStackTrace();
    System.exit(1);
  }
catch (  InvocationTargetException e) {
    this.stderr="error";
    return e.getCause().toString();
  }
catch (  InterruptedException e) {
    e.printStackTrace();
    System.exit(1);
  }
catch (  Exception e) {
    e.printStackTrace();
    System.exit(1);
  }
  return stdout;
}
