{
  final FromMemory memory=(FromMemory)workingMemory.getNodeMemory(this);
  Map<Object,RightTuple> matches=null;
  boolean useLeftMemory=true;
  if (!this.tupleMemoryEnabled) {
    Object object=((InternalFactHandle)leftTuple.get(0)).getObject();
    if (!(object instanceof DroolsQuery) || !((DroolsQuery)object).isOpen()) {
      useLeftMemory=false;
    }
  }
  if (useLeftMemory) {
    memory.betaMemory.getLeftTupleMemory().add(leftTuple);
    matches=new LinkedHashMap<Object,RightTuple>();
    memory.betaMemory.getCreatedHandles().put(leftTuple,matches);
  }
  this.betaConstraints.updateFromTuple(memory.betaMemory.getContext(),workingMemory,leftTuple);
  for (final java.util.Iterator<?> it=this.dataProvider.getResults(leftTuple,workingMemory,context,memory.providerContext); it.hasNext(); ) {
    final Object object=it.next();
    final InternalFactHandle handle=workingMemory.getFactHandleFactory().newFactHandle(object,null,workingMemory,null);
    RightTuple rightTuple=new RightTuple(handle,null);
    checkConstraintsAndPropagate(leftTuple,rightTuple,context,workingMemory,memory);
    if (this.tupleMemoryEnabled) {
      addToCreatedHandlesMap(matches,rightTuple);
    }
  }
  this.betaConstraints.resetTuple(memory.betaMemory.getContext());
}
