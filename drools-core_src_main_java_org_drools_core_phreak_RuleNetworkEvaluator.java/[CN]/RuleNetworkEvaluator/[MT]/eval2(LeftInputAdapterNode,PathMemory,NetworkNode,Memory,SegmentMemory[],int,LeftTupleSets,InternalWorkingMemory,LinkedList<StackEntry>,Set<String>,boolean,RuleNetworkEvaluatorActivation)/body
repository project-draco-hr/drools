{
  LeftTupleSets srcTuples;
  SegmentMemory smem=smems[smemIndex];
  while (true) {
    srcTuples=trgTuples;
    if (log.isTraceEnabled()) {
      int offset=getOffset(node);
      log.trace("{} {} {}",indent(offset),node.toString(),srcTuples.toStringSizes());
    }
    if (NodeTypeEnums.isTerminalNode(node)) {
      TerminalNode rtn=rmem.getRuleTerminalNode();
      if (node.getType() == NodeTypeEnums.QueryTerminalNode) {
        pQtNode.doNode((QueryTerminalNode)rtn,wm,srcTuples,stack);
      }
 else {
        pRtNode.doNode(rtn,wm,srcTuples,activation);
      }
      return;
    }
 else     if (NodeTypeEnums.RightInputAdaterNode == node.getType()) {
      doRiaNode2(wm,srcTuples,(RightInputAdapterNode)node,stack);
      return;
    }
    LeftTupleSets stagedLeftTuples;
    if (node == smem.getTipNode() && smem.getFirst() != null) {
      stagedLeftTuples=smem.getFirst().getStagedLeftTuples();
    }
 else {
      stagedLeftTuples=null;
    }
    LeftTupleSinkNode sink=((LeftTupleSource)node).getSinkPropagator().getFirstLeftTupleSink();
    trgTuples=new LeftTupleSets();
    if (NodeTypeEnums.isBetaNode(node)) {
      BetaNode betaNode=(BetaNode)node;
      BetaMemory bm=null;
      AccumulateMemory am=null;
      if (NodeTypeEnums.AccumulateNode == node.getType()) {
        am=(AccumulateMemory)nodeMem;
        bm=am.getBetaMemory();
      }
 else {
        bm=(BetaMemory)nodeMem;
      }
      if (processRian && betaNode.isRightInputIsRiaNode()) {
        doRiaNode(wm,liaNode,rmem,srcTuples,betaNode,sink,smems,smemIndex,nodeMem,bm,stack,visitedRules,activation);
        return;
      }
switch (node.getType()) {
case NodeTypeEnums.JoinNode:
{
          pJoinNode.doNode((JoinNode)node,sink,bm,wm,srcTuples,trgTuples,stagedLeftTuples);
          break;
        }
case NodeTypeEnums.NotNode:
{
        pNotNode.doNode((NotNode)node,sink,bm,wm,srcTuples,trgTuples,stagedLeftTuples);
        break;
      }
case NodeTypeEnums.ExistsNode:
{
      pExistsNode.doNode((ExistsNode)node,sink,bm,wm,srcTuples,trgTuples,stagedLeftTuples);
      break;
    }
case NodeTypeEnums.AccumulateNode:
{
    pAccNode.doNode((AccumulateNode)node,sink,am,wm,srcTuples,trgTuples,stagedLeftTuples);
    break;
  }
}
}
 else {
switch (node.getType()) {
case NodeTypeEnums.EvalConditionNode:
{
  pEvalNode.doNode((EvalConditionNode)node,(EvalMemory)nodeMem,sink,wm,srcTuples,trgTuples,stagedLeftTuples);
  break;
}
case NodeTypeEnums.FromNode:
{
pFromNode.doNode((FromNode)node,(FromMemory)nodeMem,sink,wm,srcTuples,trgTuples,stagedLeftTuples);
break;
}
case NodeTypeEnums.QueryElementNode:
{
QueryElementNodeMemory qmem=(QueryElementNodeMemory)nodeMem;
if (srcTuples.isEmpty() && qmem.getResultLeftTuples().isEmpty()) {
break;
}
QueryElementNode qnode=(QueryElementNode)node;
if (visitedRules == Collections.<String>emptySet()) {
visitedRules=new HashSet<String>();
}
visitedRules.add(qnode.getQueryElement().getQueryName());
trgTuples.addAll(qmem.getResultLeftTuples());
if (!srcTuples.isEmpty()) {
StackEntry stackEntry=new StackEntry(liaNode,node,sink,rmem,nodeMem,smems,smemIndex,trgTuples,visitedRules,true);
stack.add(stackEntry);
pQueryNode.doNode(qnode,(QueryElementNodeMemory)nodeMem,stackEntry,sink,wm,srcTuples);
SegmentMemory qsmem=((QueryElementNodeMemory)nodeMem).getQuerySegmentMemory();
List<PathMemory> qrmems=qsmem.getPathMemories();
for (int i=qrmems.size() - 1; i >= 0; i--) {
  PathMemory qrmem=qrmems.get(i);
  rmem=qrmem;
  smems=qrmem.getSegmentMemories();
  smemIndex=0;
  smem=smems[smemIndex];
  liaNode=(LeftInputAdapterNode)smem.getRootNode();
  if (liaNode == smem.getTipNode()) {
    smem=smems[++smemIndex];
    node=smem.getRootNode();
    nodeMem=smem.getNodeMemories().getFirst();
  }
 else {
    node=liaNode.getSinkPropagator().getFirstLeftTupleSink();
    nodeMem=smem.getNodeMemories().getFirst().getNext();
  }
  trgTuples=smem.getStagedLeftTuples();
  if (i != 0 && !trgTuples.isEmpty()) {
    stackEntry=new StackEntry(liaNode,node,null,rmem,nodeMem,smems,smemIndex,trgTuples,visitedRules,false);
    if (log.isTraceEnabled()) {
      int offset=getOffset(stackEntry.getNode());
      log.trace("{} ORQueue branch={} {} {}",indent(offset),i,stackEntry.getNode().toString(),trgTuples.toStringSizes());
    }
    stack.add(stackEntry);
  }
}
processRian=true;
continue;
}
break;
}
case NodeTypeEnums.ConditionalBranchNode:
{
pBranchNode.doNode((ConditionalBranchNode)node,(ConditionalBranchMemory)nodeMem,sink,wm,srcTuples,trgTuples,stagedLeftTuples);
break;
}
}
}
if (node != smem.getTipNode()) {
LeftTupleSink nextSink=sink.getNextLeftTupleSinkNode();
if (nextSink == null) {
node=sink;
}
 else {
node=nextSink;
}
nodeMem=nodeMem.getNext();
}
 else {
SegmentPropagator.propagate(smem,trgTuples,wm);
smem=smems[++smemIndex];
trgTuples=smem.getStagedLeftTuples();
if (log.isTraceEnabled()) {
log.trace("Segment {}",smemIndex);
}
node=(LeftTupleSink)smem.getRootNode();
nodeMem=smem.getNodeMemories().getFirst();
}
processRian=true;
}
}
