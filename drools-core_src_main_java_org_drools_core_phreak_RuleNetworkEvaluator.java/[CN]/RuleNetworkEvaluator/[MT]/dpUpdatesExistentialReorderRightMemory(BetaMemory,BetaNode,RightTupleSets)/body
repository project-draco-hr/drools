{
  RightTupleMemory rtm=bm.getRightTupleMemory();
  boolean resumeFromCurrent=!(betaNode.isIndexedUnificationJoin() || rtm.getIndexType().isComparison());
  boolean[] hasMemory=new boolean[srcRightTuples.updateSize()];
  RightTuple[] tempRightTuples=new RightTuple[srcRightTuples.updateSize()];
  RightTupleMemory[] currentRtms=new RightTupleMemory[srcRightTuples.updateSize()];
  int i=0;
  for (RightTuple rightTuple=srcRightTuples.getUpdateFirst(); rightTuple != null; ) {
    RightTuple next=rightTuple.getStagedNext();
    hasMemory[i]=rightTuple.getMemory() != null;
    if (hasMemory[i]) {
      if (resumeFromCurrent) {
        currentRtms[i]=rightTuple.getMemory();
        tempRightTuples[i]=(RightTuple)rightTuple.getPrevious();
        while (tempRightTuples[i] != null && tempRightTuples[i].getStagedType() != LeftTuple.NONE) {
          tempRightTuples[i]=(RightTuple)tempRightTuples[i].getPrevious();
        }
      }
      rtm.remove(rightTuple);
    }
    rightTuple=next;
    i++;
  }
  i=0;
  for (RightTuple rightTuple=srcRightTuples.getUpdateFirst(); rightTuple != null; ) {
    RightTuple next=rightTuple.getStagedNext();
    if (hasMemory[i]) {
      rtm.add(rightTuple);
      if (resumeFromCurrent) {
        if (tempRightTuples[i] == null && rightTuple.getMemory() == currentRtms[i]) {
          tempRightTuples[i]=rightTuple;
        }
        rightTuple.setTempNextRightTuple(tempRightTuples[i]);
      }
      for (LeftTuple childLeftTuple=rightTuple.getFirstChild(); childLeftTuple != null; ) {
        LeftTuple childNext=childLeftTuple.getRightParentNext();
        childLeftTuple.reAddLeft();
        childLeftTuple=childNext;
      }
    }
    rightTuple=next;
    i++;
  }
}
