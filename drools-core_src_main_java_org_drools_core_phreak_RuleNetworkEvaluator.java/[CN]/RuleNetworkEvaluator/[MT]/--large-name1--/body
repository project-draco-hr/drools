{
  BetaNode betaNode=(BetaNode)node;
  BetaMemory bm=null;
  AccumulateMemory am=null;
  if (NodeTypeEnums.AccumulateNode == node.getType()) {
    am=(AccumulateMemory)nodeMem;
    bm=am.getBetaMemory();
  }
 else {
    bm=(BetaMemory)nodeMem;
  }
  if (processRian && betaNode.isRightInputIsRiaNode()) {
    doRiaNode(wm,liaNode,rmem,srcTuples,betaNode,sink,smems,smemIndex,nodeMem,bm,stack,outerStack,visitedRules,executor);
    return true;
  }
  Deque<RightTuple> que=bm.getDequeu();
  if (!que.isEmpty()) {
    RightTupleSets rightTuples=bm.getStagedRightTuples();
    if (rightTuples.isEmpty()) {
      RightTuple rightTuple=que.peekFirst();
      PropagationContext pctx=rightTuple.getPropagationContext();
      loop:       while (rightTuple != null && rightTuple.getPropagationContext() == pctx) {
switch (rightTuple.getPropagationContext().getType()) {
case PropagationContext.INSERTION:
case PropagationContext.RULE_ADDITION:
          rightTuples.addInsert(rightTuple);
        break;
case PropagationContext.MODIFICATION:
      rightTuples.addUpdate(rightTuple);
    break;
case PropagationContext.DELETION:
case PropagationContext.RULE_REMOVAL:
  rightTuples.addDelete(rightTuple);
break;
case PropagationContext.EXPIRATION:
rightTuples.addDelete(rightTuple);
break loop;
}
que.removeFirst();
rightTuple=que.peekFirst();
}
}
if (!que.isEmpty()) {
StackEntry stackEntry=new StackEntry(liaNode,node,sink,rmem,nodeMem,smems,smemIndex,trgTuples,visitedRules,false);
outerStack.add(stackEntry);
}
}
if (stagedLeftTuples != null) {
synchronized (stagedLeftTuples) {
switchOnDoBetaNode(node,trgTuples,wm,srcTuples,stagedLeftTuples,sink,bm,am);
}
}
 else {
switchOnDoBetaNode(node,trgTuples,wm,srcTuples,stagedLeftTuples,sink,bm,am);
}
return false;
}
