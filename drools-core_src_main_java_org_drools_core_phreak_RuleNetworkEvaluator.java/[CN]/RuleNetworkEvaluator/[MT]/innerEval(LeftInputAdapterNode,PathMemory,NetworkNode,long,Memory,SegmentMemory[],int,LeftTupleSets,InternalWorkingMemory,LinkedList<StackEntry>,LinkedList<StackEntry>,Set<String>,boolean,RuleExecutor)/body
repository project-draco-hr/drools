{
  LeftTupleSets srcTuples;
  SegmentMemory smem=smems[smemIndex];
  LeftTupleSets stagedLeftTuples=null;
  while (true) {
    srcTuples=trgTuples;
    if (log.isTraceEnabled()) {
      int offset=getOffset(node);
      log.trace("{} {} {} {}",indent(offset),++cycle,node.toString(),srcTuples.toStringSizes());
    }
    boolean emptySrcTuples=srcTuples.isEmpty();
    if (!(NodeTypeEnums.isBetaNode(node) && ((BetaNode)node).isRightInputIsRiaNode())) {
      if (emptySrcTuples && smem.getDirtyNodeMask() == 0) {
        boolean foundDirty=false;
        for (int i=++smemIndex, length=smems.length; i < length; i++) {
          if (log.isTraceEnabled()) {
            int offset=getOffset(node);
            log.trace("{} Skip Segment {}",indent(offset),smemIndex - 1);
          }
          if (smem.isEmpty()) {
            SegmentUtilities.createChildSegments(wm,smem,((LeftTupleSource)smem.getTipNode()).getSinkPropagator());
          }
          smem=smems[i];
          bit=1;
          srcTuples=smem.getStagedLeftTuples().takeAll();
          emptySrcTuples=srcTuples.isEmpty();
          node=smem.getRootNode();
          nodeMem=smem.getNodeMemories().getFirst();
          if (!emptySrcTuples || smem.getDirtyNodeMask() != 0 || (NodeTypeEnums.isBetaNode(node) && ((BetaNode)node).isRightInputIsRiaNode())) {
            foundDirty=true;
            break;
          }
        }
        if (!foundDirty) {
          break;
        }
      }
      if (log.isTraceEnabled()) {
        int offset=getOffset(node);
        log.trace("{} Segment {}",indent(offset),smemIndex);
        log.trace("{} {} {} {}",indent(offset),cycle,node.toString(),srcTuples.toStringSizes());
      }
    }
    long dirtyMask=smem.getDirtyNodeMask();
    if (emptySrcTuples) {
      while ((dirtyMask & bit) == 0 && node != smem.getTipNode() && !(NodeTypeEnums.isBetaNode(node) && ((BetaNode)node).isRightInputIsRiaNode())) {
        if (log.isTraceEnabled()) {
          int offset=getOffset(node);
          log.trace("{} Skip Node {}",indent(offset),node);
        }
        bit=bit << 1;
        node=((LeftTupleSource)node).getSinkPropagator().getFirstLeftTupleSink();
        nodeMem=nodeMem.getNext();
      }
    }
    if (NodeTypeEnums.isTerminalNode(node)) {
      TerminalNode rtn=(TerminalNode)node;
      if (node.getType() == NodeTypeEnums.QueryTerminalNode) {
        pQtNode.doNode((QueryTerminalNode)rtn,wm,srcTuples,stack);
      }
 else {
        pRtNode.doNode(rtn,wm,srcTuples,executor);
      }
      break;
    }
 else     if (NodeTypeEnums.RightInputAdaterNode == node.getType()) {
      doRiaNode2(wm,srcTuples,(RightInputAdapterNode)node,stack);
      break;
    }
    stagedLeftTuples=getStagedLeftTuples(node,wm,smem);
    LeftTupleSinkNode sink=((LeftTupleSource)node).getSinkPropagator().getFirstLeftTupleSink();
    trgTuples=new LeftTupleSetsImpl();
    if (NodeTypeEnums.isBetaNode(node)) {
      boolean exitInnerEval=evalBetaNode(liaNode,pmem,node,nodeMem,smems,smemIndex,trgTuples,wm,stack,outerStack,visitedRules,processRian,executor,srcTuples,stagedLeftTuples,sink);
      if (exitInnerEval) {
        break;
      }
    }
 else {
switch (node.getType()) {
case NodeTypeEnums.EvalConditionNode:
{
          pEvalNode.doNode((EvalConditionNode)node,(EvalMemory)nodeMem,sink,wm,srcTuples,trgTuples,stagedLeftTuples);
          break;
        }
case NodeTypeEnums.FromNode:
{
        pFromNode.doNode((FromNode)node,(FromMemory)nodeMem,sink,wm,srcTuples,trgTuples,stagedLeftTuples);
        break;
      }
case NodeTypeEnums.QueryElementNode:
{
      boolean exitInnerEval=evalQueryNode(liaNode,pmem,node,bit,nodeMem,smems,smemIndex,trgTuples,wm,stack,visitedRules,srcTuples,sink);
      if (exitInnerEval) {
        break;
      }
      break;
    }
case NodeTypeEnums.TimerConditionNode:
{
    pTimerNode.doNode((TimerNode)node,(TimerNodeMemory)nodeMem,pmem,sink,wm,srcTuples,trgTuples,stagedLeftTuples);
    break;
  }
case NodeTypeEnums.ConditionalBranchNode:
{
  pBranchNode.doNode((ConditionalBranchNode)node,(ConditionalBranchMemory)nodeMem,sink,wm,srcTuples,trgTuples,stagedLeftTuples,executor);
  break;
}
}
}
if (node != smem.getTipNode()) {
node=sink;
nodeMem=nodeMem.getNext();
bit=bit << 1;
}
 else {
synchronized (smem.getFirst().getStagedLeftTuples()) {
smem.getFirst().getStagedLeftTuples().addAll(stagedLeftTuples);
SegmentPropagator.propagate(smem,trgTuples,wm);
bit=1;
smem=smems[++smemIndex];
trgTuples=smem.getStagedLeftTuples().takeAll();
}
if (log.isTraceEnabled()) {
int offset=getOffset(node);
log.trace("{} Segment {}",indent(offset),smemIndex);
}
node=smem.getRootNode();
nodeMem=smem.getNodeMemories().getFirst();
}
processRian=true;
}
if (stagedLeftTuples != null && !stagedLeftTuples.isEmpty()) {
synchronized (smem.getFirst().getStagedLeftTuples()) {
smem.getFirst().getStagedLeftTuples().addAll(stagedLeftTuples);
}
}
}
