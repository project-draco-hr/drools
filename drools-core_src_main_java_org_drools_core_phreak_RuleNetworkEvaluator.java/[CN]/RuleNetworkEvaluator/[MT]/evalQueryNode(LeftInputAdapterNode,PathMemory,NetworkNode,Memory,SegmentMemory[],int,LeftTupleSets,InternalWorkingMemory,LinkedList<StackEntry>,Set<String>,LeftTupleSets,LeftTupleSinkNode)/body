{
  QueryElementNodeMemory qmem=(QueryElementNodeMemory)nodeMem;
  if (srcTuples.isEmpty() && qmem.getResultLeftTuples().isEmpty()) {
    return false;
  }
  QueryElementNode qnode=(QueryElementNode)node;
  if (visitedRules == Collections.<String>emptySet()) {
    visitedRules=new HashSet<String>();
  }
  visitedRules.add(qnode.getQueryElement().getQueryName());
  trgTuples.addAll(qmem.getResultLeftTuples());
  if (!srcTuples.isEmpty()) {
    StackEntry stackEntry=new StackEntry(liaNode,node,sink,pmem,nodeMem,smems,smemIndex,trgTuples,visitedRules,true);
    stack.add(stackEntry);
    pQueryNode.doNode(qnode,(QueryElementNodeMemory)nodeMem,stackEntry,sink,wm,srcTuples);
    SegmentMemory qsmem=((QueryElementNodeMemory)nodeMem).getQuerySegmentMemory();
    List<PathMemory> qpmems=qsmem.getPathMemories();
    for (int i=0; i < qpmems.size(); i++) {
      PathMemory qpmem=qpmems.get(i);
      pmem=qpmem;
      smems=qpmem.getSegmentMemories();
      smemIndex=0;
      SegmentMemory smem=smems[smemIndex];
      liaNode=(LeftInputAdapterNode)smem.getRootNode();
      if (liaNode == smem.getTipNode()) {
        smem=smems[++smemIndex];
        node=smem.getRootNode();
        nodeMem=smem.getNodeMemories().getFirst();
      }
 else {
        node=liaNode.getSinkPropagator().getFirstLeftTupleSink();
        nodeMem=smem.getNodeMemories().getFirst().getNext();
      }
      trgTuples=smem.getStagedLeftTuples();
      stackEntry=new StackEntry(liaNode,node,null,pmem,nodeMem,smems,smemIndex,trgTuples,visitedRules,false);
      if (log.isTraceEnabled()) {
        int offset=getOffset(stackEntry.getNode());
        log.trace("{} ORQueue branch={} {} {}",indent(offset),i,stackEntry.getNode().toString(),trgTuples.toStringSizes());
      }
      stack.add(stackEntry);
    }
    return true;
  }
 else {
    return false;
  }
}
