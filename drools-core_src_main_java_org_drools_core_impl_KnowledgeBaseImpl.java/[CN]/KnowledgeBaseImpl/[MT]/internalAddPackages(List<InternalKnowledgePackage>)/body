{
  for (  StatefulKnowledgeSession session : statefulSessions) {
    ((InternalWorkingMemory)session).flushPropagations();
  }
  for (  InternalKnowledgePackage newPkg : clonedPkgs) {
    newPkg.checkValidity();
    this.eventSupport.fireBeforePackageAdded(newPkg);
    if (newPkg.hasTraitRegistry()) {
      getTraitRegistry().merge(newPkg.getTraitRegistry());
    }
    InternalKnowledgePackage pkg=this.pkgs.get(newPkg.getName());
    if (pkg == null) {
      pkg=new KnowledgePackageImpl(newPkg.getName());
      pkg.setClassFieldAccessorCache(this.classFieldAccessorCache);
      pkgs.put(pkg.getName(),pkg);
    }
    pkg.getDialectRuntimeRegistry().merge(newPkg.getDialectRuntimeRegistry(),this.rootClassLoader,true);
  }
  List<TypeDeclaration> allTypeDeclarations=new ArrayList<TypeDeclaration>();
  for (  InternalKnowledgePackage newPkg : clonedPkgs) {
    if (newPkg.getTypeDeclarations() != null) {
      for (      TypeDeclaration newDecl : newPkg.getTypeDeclarations().values()) {
        allTypeDeclarations.add(newDecl);
      }
    }
  }
  Collections.sort(allTypeDeclarations);
  String lastType=null;
  try {
    for (    TypeDeclaration newDecl : allTypeDeclarations) {
      lastType=newDecl.getTypeClassName();
      InternalKnowledgePackage newPkg=null;
      for (      InternalKnowledgePackage kpkg : clonedPkgs) {
        if (kpkg.getTypeDeclarations().containsKey(newDecl.getTypeName())) {
          newPkg=kpkg;
          break;
        }
      }
      processTypeDeclaration(newDecl,newPkg);
    }
  }
 catch (  ClassNotFoundException e) {
    throw new RuntimeException("unable to resolve Type Declaration class '" + lastType + "'",e);
  }
  for (  InternalKnowledgePackage newPkg : clonedPkgs) {
    try {
      JavaDialectRuntimeData runtime=((JavaDialectRuntimeData)newPkg.getDialectRuntimeRegistry().getDialectData("java"));
      for (      Function function : newPkg.getFunctions().values()) {
        String functionClassName=function.getClassName();
        byte[] def=runtime.getStore().get(convertClassToResourcePath(functionClassName));
        registerAndLoadTypeDefinition(functionClassName,def);
      }
    }
 catch (    ClassNotFoundException e) {
      throw new RuntimeException("unable to resolve Type Declaration class '" + lastType + "'",e);
    }
  }
  for (  InternalKnowledgePackage newPkg : clonedPkgs) {
    InternalKnowledgePackage pkg=this.pkgs.get(newPkg.getName());
    if (newPkg.getFunctions() != null) {
      for (      Map.Entry<String,Function> entry : newPkg.getFunctions().entrySet()) {
        pkg.addFunction(entry.getValue());
      }
    }
    pkg.getDialectRuntimeRegistry().onBeforeExecute();
    pkg.getClassFieldAccessorStore().merge(newPkg.getClassFieldAccessorStore());
  }
  for (  InternalKnowledgePackage newPkg : clonedPkgs) {
    InternalKnowledgePackage pkg=this.pkgs.get(newPkg.getName());
    mergePackage(pkg,newPkg);
    for (    WindowDeclaration window : newPkg.getWindowDeclarations().values()) {
      addWindowDeclaration(newPkg,window);
    }
    for (    String id : newPkg.getEntryPointIds()) {
      addEntryPoint(id);
    }
    for (    Rule rule : newPkg.getRules()) {
      addRule(newPkg,(RuleImpl)rule);
    }
    if (newPkg.getRuleFlows() != null) {
      final Map<String,Process> flows=newPkg.getRuleFlows();
      for (      Process process : flows.values()) {
        addProcess(process);
      }
    }
    if (!newPkg.getResourceTypePackages().isEmpty()) {
      KieWeavers weavers=ServiceRegistryImpl.getInstance().get(KieWeavers.class);
      for (      ResourceTypePackage rtkKpg : newPkg.getResourceTypePackages().values()) {
        ResourceType rt=rtkKpg.getResourceType();
        KieWeaverService factory=weavers.getWeavers().get(rt);
        factory.weave(this,newPkg,rtkKpg);
      }
    }
    this.eventSupport.fireAfterPackageAdded(newPkg);
  }
}
