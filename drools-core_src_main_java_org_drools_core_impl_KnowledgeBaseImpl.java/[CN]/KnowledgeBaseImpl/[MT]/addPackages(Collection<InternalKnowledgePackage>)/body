{
  List<InternalKnowledgePackage> clonedPkgs=new ArrayList<InternalKnowledgePackage>();
  for (  InternalKnowledgePackage newPkg : newPkgs) {
    clonedPkgs.add(newPkg.deepCloneIfAlreadyInUse(rootClassLoader));
  }
  lock();
  try {
    for (    InternalKnowledgePackage newPkg : clonedPkgs) {
      newPkg.checkValidity();
      this.additionsSinceLock++;
      this.eventSupport.fireBeforePackageAdded(newPkg);
      if (newPkg.hasTraitRegistry()) {
        getTraitRegistry().merge(newPkg.getTraitRegistry());
      }
      InternalKnowledgePackage pkg=this.pkgs.get(newPkg.getName());
      if (pkg == null) {
        pkg=new KnowledgePackageImpl(newPkg.getName());
        pkg.setClassFieldAccessorCache(this.classFieldAccessorCache);
        pkgs.put(pkg.getName(),pkg);
      }
      pkg.getDialectRuntimeRegistry().merge(newPkg.getDialectRuntimeRegistry(),this.rootClassLoader,true);
    }
    List<TypeDeclaration> allTypeDeclarations=new ArrayList<TypeDeclaration>();
    for (    InternalKnowledgePackage newPkg : clonedPkgs) {
      if (newPkg.getTypeDeclarations() != null) {
        for (        TypeDeclaration newDecl : newPkg.getTypeDeclarations().values()) {
          allTypeDeclarations.add(newDecl);
        }
      }
    }
    Collections.sort(allTypeDeclarations);
    String lastType=null;
    try {
      for (      TypeDeclaration newDecl : allTypeDeclarations) {
        lastType=newDecl.getTypeClassName();
        InternalKnowledgePackage newPkg=null;
        for (        InternalKnowledgePackage kpkg : clonedPkgs) {
          if (kpkg.getTypeDeclarations().containsKey(newDecl.getTypeName())) {
            newPkg=kpkg;
            break;
          }
        }
        processTypeDeclaration(newDecl,newPkg);
      }
    }
 catch (    ClassNotFoundException e) {
      throw new RuntimeException("unable to resolve Type Declaration class '" + lastType + "'",e);
    }
    for (    InternalKnowledgePackage newPkg : clonedPkgs) {
      try {
        JavaDialectRuntimeData runtime=((JavaDialectRuntimeData)newPkg.getDialectRuntimeRegistry().getDialectData("java"));
        for (        Function function : newPkg.getFunctions().values()) {
          String functionClassName=function.getClassName();
          byte[] def=runtime.getStore().get(convertClassToResourcePath(functionClassName));
          registerAndLoadTypeDefinition(functionClassName,def);
        }
      }
 catch (      ClassNotFoundException e) {
        throw new RuntimeException("unable to resolve Type Declaration class '" + lastType + "'",e);
      }
    }
    for (    InternalKnowledgePackage newPkg : clonedPkgs) {
      InternalKnowledgePackage pkg=this.pkgs.get(newPkg.getName());
      if (newPkg.getFunctions() != null) {
        for (        Map.Entry<String,Function> entry : newPkg.getFunctions().entrySet()) {
          pkg.addFunction(entry.getValue());
        }
      }
      pkg.getDialectRuntimeRegistry().onBeforeExecute();
      pkg.getClassFieldAccessorStore().merge(newPkg.getClassFieldAccessorStore());
    }
    for (    InternalKnowledgePackage newPkg : clonedPkgs) {
      InternalKnowledgePackage pkg=this.pkgs.get(newPkg.getName());
      mergePackage(pkg,newPkg);
      for (      WindowDeclaration window : newPkg.getWindowDeclarations().values()) {
        addWindowDeclaration(newPkg,window);
      }
      for (      String id : newPkg.getEntryPointIds()) {
        addEntryPoint(id);
      }
      for (      Rule rule : newPkg.getRules()) {
        addRule(newPkg,(RuleImpl)rule);
      }
      if (newPkg.getRuleFlows() != null) {
        final Map<String,org.kie.api.definition.process.Process> flows=newPkg.getRuleFlows();
        for (        org.kie.api.definition.process.Process process : flows.values()) {
          addProcess(process);
        }
      }
      this.eventSupport.fireAfterPackageAdded(newPkg);
    }
  }
  finally {
    unlock();
  }
}
