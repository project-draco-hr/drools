{
  try {
    ruleNestingLevel++;
    int _type=WS;
    int _start=getCharIndex();
    int _line=getLine();
    int _charPosition=getCharPositionInLine();
    int _channel=Token.DEFAULT_CHANNEL;
{
      int cnt2=0;
      loop2:       do {
        int alt2=5;
switch (input.LA(1)) {
case ' ':
          alt2=1;
        break;
case '\t':
      alt2=2;
    break;
case '\f':
  alt2=3;
break;
case '\n':
case '\r':
alt2=4;
break;
}
switch (alt2) {
case 1:
{
match(' ');
}
break;
case 2:
{
match('\t');
}
break;
case 3:
{
match('\f');
}
break;
case 4:
{
int alt1=3;
int LA1_0=input.LA(1);
if ((LA1_0 == '\r')) {
int LA1_1=input.LA(2);
if ((LA1_1 == '\n')) {
alt1=1;
}
 else {
alt1=2;
}
}
 else if ((LA1_0 == '\n')) {
alt1=3;
}
 else {
NoViableAltException nvae=new NoViableAltException("1057:5: ( '\\r\\n' | '\\r' | '\\n' )",1,0,input);
throw nvae;
}
switch (alt1) {
case 1:
{
match("\r\n");
}
break;
case 2:
{
match('\r');
}
break;
case 3:
{
match('\n');
}
break;
}
}
break;
default :
if (cnt2 >= 1) break loop2;
EarlyExitException eee=new EarlyExitException(2,input);
throw eee;
}
cnt2++;
}
 while (true);
_channel=HIDDEN;
}
if (token == null && ruleNestingLevel == 1) {
emit(_type,_line,_charPosition,_channel,_start,getCharIndex() - 1);
}
}
  finally {
ruleNestingLevel--;
}
}
