{
  Map<String,Class<?>> variables=context.getDeclarationResolver().getDeclarationClasses(context.getRule());
  Dialect.AnalysisResult mvelAnalysis=mvel.analyzeBlock(context,context.getRuleDescr(),mvel.getInterceptors(),d.getModifyExpression(),new Map[]{variables,context.getPackageBuilder().getGlobals()},null);
  final ExecutableStatement expr=(ExecutableStatement)mvel.compile(d.getModifyExpression(),mvelAnalysis,mvel.getInterceptors(),null,null,context);
  Class ret=expr.getKnownEgressType();
  if (ret == null) {
    context.getErrors().add(new DescrBuildError(context.getParentDescr(),context.getRuleDescr(),originalCode,"Unable to determine the resulting type of the expression: " + d.getModifyExpression() + "\n"));
    return;
  }
  String retString=ClassUtils.canonicalName(ret);
  consequence.append("{ ");
  consequence.append(retString);
  consequence.append(" __obj__ = (");
  consequence.append(retString);
  consequence.append(") ");
  consequence.append(d.getModifyExpression());
  consequence.append("; ");
  consequence.append("modifyRetract( __obj__ ); ");
  String originalBlock=originalCode.substring(d.getStart() - 1,d.getEnd());
  int end=originalBlock.indexOf("{");
  addLineBreaks(consequence,originalBlock.substring(0,end));
  int start=end + 1;
  for (  String exprStr : d.getExpressions()) {
    end=originalBlock.indexOf(exprStr,start);
    addLineBreaks(consequence,originalBlock.substring(start,end));
    consequence.append("__obj__.");
    consequence.append(exprStr);
    consequence.append("; ");
    start=end + exprStr.length();
  }
  addLineBreaks(consequence,originalBlock.substring(end));
  consequence.append("modifyInsert( __obj__ ); }");
}
