{
  ConditionalBranchEvaluator branchEvaluator=branchNode.getBranchEvaluator();
  LeftTupleList tupleList=executor.getLeftTupleList();
  for (LeftTuple leftTuple=srcLeftTuples.getUpdateFirst(); leftTuple != null; ) {
    LeftTuple next=leftTuple.getStagedNext();
    LeftTuple rtnLeftTuple=(LeftTuple)leftTuple.getObject();
    LeftTuple mainLeftTuple=leftTuple.getFirstChild();
    RuleTerminalNode oldRtn=null;
    if (rtnLeftTuple != null) {
      oldRtn=(RuleTerminalNode)rtnLeftTuple.getSink();
    }
    ConditionalExecution conditionalExecution=branchEvaluator.evaluate(leftTuple,wm,cbm.context);
    RuleTerminalNode newRtn=null;
    boolean breaking=false;
    if (conditionalExecution != null) {
      newRtn=(RuleTerminalNode)conditionalExecution.getSink().getFirstLeftTupleSink();
      breaking=conditionalExecution.isBreaking();
    }
    if (oldRtn != null) {
      if (newRtn == null) {
        if (rtnLeftTuple.getMemory() != null) {
          tupleList.remove(rtnLeftTuple);
        }
        oldRtn.retractLeftTuple(rtnLeftTuple,rtnLeftTuple.getPropagationContext(),wm);
      }
 else       if (newRtn == oldRtn) {
        if (rtnLeftTuple.getMemory() != null) {
          tupleList.remove(rtnLeftTuple);
        }
        tupleList.add(rtnLeftTuple);
      }
 else {
        if (rtnLeftTuple.getMemory() != null) {
          tupleList.remove(rtnLeftTuple);
        }
        oldRtn.retractLeftTuple(rtnLeftTuple,rtnLeftTuple.getPropagationContext(),wm);
        rtnLeftTuple=newRtn.createLeftTuple(leftTuple,newRtn,leftTuple.getPropagationContext(),true);
        leftTuple.setObject(rtnLeftTuple);
        tupleList.add(rtnLeftTuple);
      }
    }
 else     if (newRtn != null) {
      rtnLeftTuple=newRtn.createLeftTuple(leftTuple,newRtn,leftTuple.getPropagationContext(),true);
      leftTuple.setObject(rtnLeftTuple);
      tupleList.add(rtnLeftTuple);
    }
    if (mainLeftTuple != null) {
switch (mainLeftTuple.getStagedType()) {
case LeftTuple.INSERT:
        stagedLeftTuples.removeInsert(mainLeftTuple);
      break;
case LeftTuple.UPDATE:
    stagedLeftTuples.removeUpdate(mainLeftTuple);
  break;
}
if (!breaking) {
trgLeftTuples.addUpdate(mainLeftTuple);
}
 else {
trgLeftTuples.addDelete(mainLeftTuple);
}
}
 else if (!breaking) {
trgLeftTuples.addInsert(sink.createLeftTuple(leftTuple,sink,leftTuple.getPropagationContext(),true));
}
leftTuple.clearStaged();
leftTuple=next;
}
}
