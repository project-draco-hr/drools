{
  if (!stack.isEmpty() && node == stack.getLast()) {
    return;
  }
  if (node.getType() == NodeTypeEnums.EntryPointNode) {
    return;
  }
  if (node.isInUse()) {
    stillInUse.add(node);
  }
  if (NodeTypeEnums.isBetaNode(node)) {
    BaseNode parent=((LeftTupleSink)node).getLeftTupleSource();
    node.remove(context,this,workingMemories);
    if (!((BetaNode)node).isRightInputIsRiaNode()) {
      stack.addFirst(((BetaNode)node).getRightInput());
    }
    if (processRian && ((BetaNode)node).isRightInputIsRiaNode()) {
      stack.addLast(((BetaNode)node).getLeftTupleSource());
      stack.addLast(((BetaNode)node).getRightInput());
    }
 else {
      removeNode(parent,stack,stillInUse,true,workingMemories,context);
    }
  }
 else   if (NodeTypeEnums.isLeftTupleSink(node)) {
    BaseNode parent=((LeftTupleSink)node).getLeftTupleSource();
    node.remove(context,this,workingMemories);
    removeNode(parent,stack,stillInUse,true,workingMemories,context);
  }
 else   if (NodeTypeEnums.LeftInputAdapterNode == node.getType()) {
    BaseNode parent=((LeftInputAdapterNode)node).getParentObjectSource();
    node.remove(context,this,workingMemories);
    removeNode(parent,stack,stillInUse,true,workingMemories,context);
  }
 else   if (NodeTypeEnums.isObjectSource(node)) {
    BaseNode parent=((ObjectSource)node).getParentObjectSource();
    node.remove(context,this,workingMemories);
    removeNode(parent,stack,stillInUse,true,workingMemories,context);
  }
 else {
    throw new IllegalStateException("Defensive exception, should not fall through");
  }
  if (node.getType() != NodeTypeEnums.ObjectTypeNode && !node.isInUse() && ruleBase.getConfiguration().isPhreakEnabled()) {
    for (    InternalWorkingMemory workingMemory : workingMemories) {
      workingMemory.clearNodeMemory((MemoryFactory)node);
    }
  }
}
