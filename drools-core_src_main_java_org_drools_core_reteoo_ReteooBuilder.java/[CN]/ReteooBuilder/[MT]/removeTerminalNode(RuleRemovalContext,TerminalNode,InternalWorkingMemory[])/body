{
  if (this.kBase.getConfiguration().isPhreakEnabled()) {
    AddRemoveRule.removeRule(tn,workingMemories,kBase);
  }
  RuleRemovalContext.CleanupAdapter adapter=null;
  if (!this.kBase.getConfiguration().isPhreakEnabled()) {
    if (tn instanceof RuleTerminalNode) {
      adapter=new RuleTerminalNode.RTNCleanupAdapter((RuleTerminalNode)tn);
    }
    context.setCleanupAdapter(adapter);
  }
  BaseNode node=(BaseNode)tn;
  Set<BaseNode> removedSources=new HashSet<BaseNode>();
  LinkedList<BaseNode> betaStack=new LinkedList<BaseNode>();
  LinkedList<BaseNode> alphaStack=new LinkedList<BaseNode>();
  LinkedList<BaseNode> stillInUse=new LinkedList<BaseNode>();
  boolean processRian=true;
  while (node != null) {
    removeNode(node,removedSources,alphaStack,betaStack,stillInUse,processRian,workingMemories,context);
    if (!betaStack.isEmpty()) {
      processRian=node.getType() == NodeTypeEnums.RightInputAdaterNode;
      node=betaStack.removeLast();
    }
 else     if (!alphaStack.isEmpty()) {
      node=alphaStack.removeLast();
    }
 else {
      node=null;
    }
  }
  resetMasks(stillInUse);
}
