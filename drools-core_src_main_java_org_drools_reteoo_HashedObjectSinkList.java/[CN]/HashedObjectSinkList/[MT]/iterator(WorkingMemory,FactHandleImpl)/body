{
  return new Iterator(){
    private static final int FLAG_ITER_HASH=0;
    private static final int FLAG_ITER_LIST=1;
    private Iterator it=alphaSwitch.values().iterator();
    private ObjectSink current=null;
    private ObjectSink next=null;
    private int flag=FLAG_ITER_HASH;
    public boolean hasNext(){
      boolean hasnext=false;
      if (next == null) {
switch (flag) {
case FLAG_ITER_HASH:
          while (it.hasNext()) {
            AlphaNodeSwitch wrapper=(AlphaNodeSwitch)it.next();
            next=wrapper.getNode(workingMemory,handle);
            if (next != null) {
              hasnext=true;
              break;
            }
          }
        if (hasnext == false) {
          it=otherSinks.iterator();
          hasnext=it.hasNext();
          if (hasnext) {
            next=(ObjectSink)it.next();
          }
          flag=FLAG_ITER_LIST;
        }
      break;
case FLAG_ITER_LIST:
    hasnext=it.hasNext();
  if (hasnext) {
    next=(ObjectSink)it.next();
  }
break;
}
}
 else {
hasnext=true;
}
return hasnext;
}
public Object next(){
if (this.next == null) {
this.hasNext();
}
this.current=this.next;
this.next=null;
if (this.current == null) {
throw new NoSuchElementException("No more elements to return");
}
return this.current;
}
public void remove(){
if (this.current != null) {
HashedObjectSinkList.this.remove(current);
this.current=null;
}
 else {
throw new IllegalStateException("No item to remove. Call next() before calling remove().");
}
}
}
;
}
