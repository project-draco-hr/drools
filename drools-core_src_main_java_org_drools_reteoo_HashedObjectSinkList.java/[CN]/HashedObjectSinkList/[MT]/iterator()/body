{
  return new Iterator(){
    private static final int FLAG_ITER_HASH=0;
    private static final int FLAG_ITER_LIST=1;
    private Iterator it=HashedObjectSinkList.this.hashedSinks.iterator();
    private ObjectSink current=null;
    private ObjectSink next=null;
    private int flag=FLAG_ITER_HASH;
    public boolean hasNext(){
      boolean hasnext=false;
      if (this.next == null) {
switch (this.flag) {
case FLAG_ITER_HASH:
          hasnext=this.it.hasNext();
        if (hasnext) {
          this.next=(ObjectSink)this.it.next();
        }
 else {
          this.it=HashedObjectSinkList.this.otherSinks.iterator();
          hasnext=this.it.hasNext();
          if (hasnext) {
            this.next=(ObjectSink)this.it.next();
          }
          this.flag=FLAG_ITER_LIST;
        }
      break;
case FLAG_ITER_LIST:
    hasnext=this.it.hasNext();
  if (hasnext) {
    this.next=(ObjectSink)this.it.next();
  }
break;
}
}
 else {
hasnext=true;
}
return hasnext;
}
public Object next(){
if (this.next == null) {
this.hasNext();
}
this.current=this.next;
this.next=null;
if (this.current == null) {
throw new NoSuchElementException("No more elements to return");
}
return this.current;
}
public void remove(){
if (this.current != null) {
HashedObjectSinkList.this.remove(this.current);
this.current=null;
}
 else {
throw new IllegalStateException("No item to remove. Call next() before calling remove().");
}
}
}
;
}
