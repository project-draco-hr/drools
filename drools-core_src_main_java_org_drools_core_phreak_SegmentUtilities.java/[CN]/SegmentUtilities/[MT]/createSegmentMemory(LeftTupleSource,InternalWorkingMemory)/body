{
  SegmentMemory smem=wm.getNodeMemory((MemoryFactory)tupleSource).getSegmentMemory();
  if (smem != null) {
    return smem;
  }
  boolean initRtn=false;
  if (tupleSource.getType() == NodeTypeEnums.LeftInputAdapterNode) {
    initRtn=true;
  }
  while (tupleSource.getType() != NodeTypeEnums.LeftInputAdapterNode && SegmentUtilities.parentInSameSegment(tupleSource,null)) {
    tupleSource=tupleSource.getLeftTupleSource();
  }
  LeftTupleSource segmentRoot=tupleSource;
  if (initRtn) {
    initialiseRtnMemory(segmentRoot,wm);
  }
  smem=new SegmentMemory(segmentRoot);
  long nodePosMask=1;
  long allLinkedTestMask=0;
  boolean updateNodeBit=true;
  while (true) {
    if (NodeTypeEnums.isBetaNode(tupleSource)) {
      allLinkedTestMask=processBetaNode(tupleSource,wm,smem,nodePosMask,allLinkedTestMask,updateNodeBit);
    }
 else {
switch (tupleSource.getType()) {
case NodeTypeEnums.LeftInputAdapterNode:
        allLinkedTestMask=processLiaNode((LeftInputAdapterNode)tupleSource,wm,smem,nodePosMask,allLinkedTestMask);
      break;
case NodeTypeEnums.EvalConditionNode:
    processEvalNode((EvalConditionNode)tupleSource,wm,smem);
  break;
case NodeTypeEnums.ConditionalBranchNode:
updateNodeBit=processBranchNode((ConditionalBranchNode)tupleSource,wm,smem);
break;
case NodeTypeEnums.FromNode:
processFromNode((FromNode)tupleSource,wm,smem);
break;
case NodeTypeEnums.TimerConditionNode:
processTimerNode((TimerNode)tupleSource,wm,smem);
break;
case NodeTypeEnums.QueryElementNode:
processQueryNode((QueryElementNode)tupleSource,wm,segmentRoot,smem);
break;
}
}
nodePosMask=nodePosMask << 1;
if (tupleSource.getSinkPropagator().size() == 1) {
LeftTupleSinkNode sink=(LeftTupleSinkNode)tupleSource.getSinkPropagator().getFirstLeftTupleSink();
if (NodeTypeEnums.isLeftTupleSource(sink)) {
tupleSource=(LeftTupleSource)sink;
}
 else {
if (sink.getType() == NodeTypeEnums.RightInputAdaterNode) {
RiaNodeMemory memory=(RiaNodeMemory)wm.getNodeMemory((MemoryFactory)sink);
smem.getNodeMemories().add(memory.getRiaPathMemory());
memory.getRiaPathMemory().setSegmentMemory(smem);
}
 else if (NodeTypeEnums.isTerminalNode(sink)) {
PathMemory pmem=(PathMemory)wm.getNodeMemory((MemoryFactory)sink);
smem.getNodeMemories().add(pmem);
pmem.setSegmentMemory(smem);
}
smem.setTipNode(sink);
break;
}
}
 else {
smem.setTipNode(tupleSource);
break;
}
}
smem.setAllLinkedMaskTest(allLinkedTestMask);
LeftTupleSource pathRoot=segmentRoot;
int ruleSegmentPosMask=1;
int counter=0;
while (pathRoot.getType() != NodeTypeEnums.LeftInputAdapterNode) {
if (!SegmentUtilities.parentInSameSegment(pathRoot,null)) {
ruleSegmentPosMask=ruleSegmentPosMask << 1;
counter++;
}
pathRoot=pathRoot.getLeftTupleSource();
}
smem.setSegmentPosMaskBit(ruleSegmentPosMask);
smem.setPos(counter);
updateRiaAndTerminalMemory(tupleSource,tupleSource,smem,wm);
return smem;
}
