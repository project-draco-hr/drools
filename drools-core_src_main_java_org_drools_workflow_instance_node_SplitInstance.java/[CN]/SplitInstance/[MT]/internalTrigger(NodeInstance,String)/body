{
  if (!org.drools.workflow.core.Node.CONNECTION_DEFAULT_TYPE.equals(type)) {
    throw new IllegalArgumentException("A Split only accepts default incoming connections!");
  }
  final Split split=getSplit();
switch (split.getType()) {
case Split.TYPE_AND:
    triggerCompleted(org.drools.workflow.core.Node.CONNECTION_DEFAULT_TYPE,true);
  break;
case Split.TYPE_XOR:
List<Connection> outgoing=split.getDefaultOutgoingConnections();
int priority=Integer.MAX_VALUE;
Connection selected=null;
for (final Iterator<Connection> iterator=outgoing.iterator(); iterator.hasNext(); ) {
final Connection connection=(Connection)iterator.next();
ConstraintEvaluator constraint=(ConstraintEvaluator)split.getConstraint(connection);
if (constraint != null && constraint.getPriority() < priority && !constraint.isDefault()) {
if (constraint.evaluate(this,connection,constraint)) {
selected=connection;
priority=constraint.getPriority();
}
}
}
((NodeInstanceContainer)getNodeInstanceContainer()).removeNodeInstance(this);
if (selected == null) {
for (final Iterator<Connection> iterator=outgoing.iterator(); iterator.hasNext(); ) {
final Connection connection=(Connection)iterator.next();
ConstraintEvaluator constraint=(ConstraintEvaluator)split.getConstraint(connection);
if (constraint.isDefault()) {
selected=connection;
break;
}
}
}
if (selected == null) {
throw new IllegalArgumentException("XOR split could not find at least one valid outgoing connection for split " + getSplit().getName());
}
triggerConnection(selected);
break;
case Split.TYPE_OR:
((NodeInstanceContainer)getNodeInstanceContainer()).removeNodeInstance(this);
outgoing=split.getDefaultOutgoingConnections();
boolean found=false;
List<Connection> outgoingCopy=new ArrayList<Connection>(outgoing);
while (!outgoingCopy.isEmpty()) {
priority=Integer.MAX_VALUE;
Connection selectedConnection=null;
ConstraintEvaluator selectedConstraint=null;
for (final Iterator<Connection> iterator=outgoingCopy.iterator(); iterator.hasNext(); ) {
final Connection connection=(Connection)iterator.next();
ConstraintEvaluator constraint=(ConstraintEvaluator)split.getConstraint(connection);
if (constraint != null && constraint.getPriority() < priority && !constraint.isDefault()) {
priority=constraint.getPriority();
selectedConnection=connection;
selectedConstraint=constraint;
}
}
if (selectedConstraint == null) {
break;
}
if (selectedConstraint.evaluate(this,selectedConnection,selectedConstraint)) {
triggerConnection(selectedConnection);
found=true;
}
outgoingCopy.remove(selectedConnection);
}
if (!found) {
for (final Iterator<Connection> iterator=outgoing.iterator(); iterator.hasNext(); ) {
final Connection connection=(Connection)iterator.next();
ConstraintEvaluator constraint=(ConstraintEvaluator)split.getConstraint(connection);
if (constraint.isDefault()) {
triggerConnection(connection);
found=true;
break;
}
}
}
if (!found) {
throw new IllegalArgumentException("OR split could not find at least one valid outgoing connection for split " + getSplit().getName());
}
break;
case Split.TYPE_XAND:
((org.drools.workflow.instance.NodeInstanceContainer)getNodeInstanceContainer()).removeNodeInstance(this);
Node node=getNode();
List<Connection> connections=null;
if (node != null) {
connections=node.getOutgoingConnections(type);
}
if (connections == null || connections.isEmpty()) {
((org.drools.workflow.instance.NodeInstanceContainer)getNodeInstanceContainer()).nodeInstanceCompleted(this,type);
}
 else {
ExclusiveGroupInstance groupInstance=new ExclusiveGroupInstance();
org.drools.runtime.process.NodeInstanceContainer parent=getNodeInstanceContainer();
if (parent instanceof ContextInstanceContainer) {
((ContextInstanceContainer)parent).addContextInstance(ExclusiveGroup.EXCLUSIVE_GROUP,groupInstance);
}
 else {
throw new IllegalArgumentException("An Exclusive AND is only possible if the parent is a context instance container");
}
Map<NodeInstance,String> nodeInstances=new HashMap<NodeInstance,String>();
for (Connection connection : connections) {
nodeInstances.put(((org.drools.workflow.instance.NodeInstanceContainer)getNodeInstanceContainer()).getNodeInstance(connection.getTo()),connection.getToType());
}
for (NodeInstance nodeInstance : nodeInstances.keySet()) {
groupInstance.addNodeInstance(nodeInstance);
}
for (Map.Entry<NodeInstance,String> entry : nodeInstances.entrySet()) {
if (getProcessInstance().getState() != ProcessInstance.STATE_ACTIVE) {
return;
}
boolean hidden=false;
if (getNode().getMetaData("hidden") != null) {
hidden=true;
}
WorkingMemory workingMemory=((ProcessInstance)getProcessInstance()).getWorkingMemory();
if (!hidden) {
((EventSupport)workingMemory).getRuleFlowEventSupport().fireBeforeRuleFlowNodeLeft(this,(InternalWorkingMemory)workingMemory);
}
((org.drools.workflow.instance.NodeInstance)entry.getKey()).trigger(this,entry.getValue());
if (!hidden) {
((EventSupport)workingMemory).getRuleFlowEventSupport().fireAfterRuleFlowNodeLeft(this,(InternalWorkingMemory)workingMemory);
}
}
}
break;
default :
throw new IllegalArgumentException("Illegal split type " + split.getType());
}
}
