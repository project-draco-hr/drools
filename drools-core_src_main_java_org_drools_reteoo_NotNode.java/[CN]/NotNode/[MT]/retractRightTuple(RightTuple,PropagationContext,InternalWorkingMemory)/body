{
  final BetaMemory memory=(BetaMemory)workingMemory.getNodeMemory(this);
  if (isUnlinkingEnabled()) {
    RightTupleSets stagedRightTuples=memory.getStagedRightTuples();
switch (rightTuple.getStagedType()) {
case LeftTuple.INSERT:
      stagedRightTuples.removeInsert(rightTuple);
    break;
case LeftTuple.UPDATE:
  stagedRightTuples.removeUpdate(rightTuple);
break;
}
if (memory.getAndDecCounter() == 1 && isEmptyBetaConstraints()) {
memory.linkNode(workingMemory);
}
 else if (stagedRightTuples.deleteSize() == 0) {
memory.getSegmentMemory().notifyRuleLinkSegment(workingMemory);
}
stagedRightTuples.addDelete(rightTuple);
return;
}
RightTupleMemory rightTupleMemory=memory.getRightTupleMemory();
boolean useComparisonIndex=rightTupleMemory.getIndexType().isComparison();
FastIterator rightIt=rightTupleMemory.fastIterator();
RightTuple rootBlocker=useComparisonIndex ? null : (RightTuple)rightIt.next(rightTuple);
rightTupleMemory.remove(rightTuple);
if (rightTuple.getBlocked() == null) {
return;
}
for (LeftTuple leftTuple=(LeftTuple)rightTuple.getBlocked(); leftTuple != null; ) {
LeftTuple temp=leftTuple.getBlockedNext();
leftTuple.clearBlocker();
this.constraints.updateFromTuple(memory.getContext(),workingMemory,leftTuple);
if (useComparisonIndex) {
rootBlocker=getFirstRightTuple(leftTuple,memory.getRightTupleMemory(),context,rightIt);
}
for (RightTuple newBlocker=rootBlocker; newBlocker != null; newBlocker=(RightTuple)rightIt.next(newBlocker)) {
if (this.constraints.isAllowedCachedLeft(memory.getContext(),newBlocker.getFactHandle())) {
leftTuple.setBlocker(newBlocker);
newBlocker.addBlocked(leftTuple);
break;
}
}
if (leftTuple.getBlocker() == null) {
memory.getLeftTupleMemory().add(leftTuple);
propagateAssertLeftTuple(context,workingMemory,leftTuple);
}
leftTuple=temp;
}
rightTuple.nullBlocked();
this.constraints.resetTuple(memory.getContext());
}
