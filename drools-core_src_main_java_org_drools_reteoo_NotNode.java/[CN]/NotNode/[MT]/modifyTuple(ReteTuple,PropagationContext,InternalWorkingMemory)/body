{
  final BetaMemory memory=(BetaMemory)workingMemory.getNodeMemory(this);
  ReteTuple tuple=(ReteTuple)memory.getTupleMemory().remove(leftTuple);
  if (tuple == null) {
    assertTuple(leftTuple,context,workingMemory);
  }
  Iterator iterator;
  if (leftTuple.isFieldIndexed()) {
    iterator=memory.getObjectMemory().iterator(leftTuple.getFieldIndexHashCode());
  }
 else {
    iterator=memory.getObjectMemory().iterator();
  }
  int matches=tuple.getMatches();
  for (FactEntry entry=(FactEntry)iterator.next(); entry != null; entry=(FactEntry)entry.getNext()) {
    InternalFactHandle handle=entry.getFactHandle();
    if (!this.constraints.isAllowed(handle,leftTuple,workingMemory)) {
      matches--;
    }
  }
  if (tuple.getMatches() != 0 && matches == 0) {
    this.sink.propagateAssertTuple(leftTuple,context,workingMemory);
  }
 else   if (tuple.getMatches() == 0 && matches != 0) {
    this.sink.propagateRetractTuple(leftTuple,context,workingMemory);
  }
}
