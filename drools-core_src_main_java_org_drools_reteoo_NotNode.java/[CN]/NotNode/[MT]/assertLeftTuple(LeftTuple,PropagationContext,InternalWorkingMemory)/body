{
  final BetaMemory memory=(BetaMemory)workingMemory.getNodeMemory(this);
  if (this.tupleMemoryEnabled) {
    memory.getLeftTupleMemory().add(leftTuple);
  }
  this.constraints.updateFromTuple(memory.getContext(),workingMemory,leftTuple);
  for (RightTuple rightTuple=memory.getRightTupleMemory().getLast(leftTuple); rightTuple != null; rightTuple=(RightTuple)rightTuple.getPrevious()) {
    if (this.constraints.isAllowedCachedLeft(memory.getContext(),rightTuple.getFactHandle())) {
      leftTuple.setBlocker(rightTuple);
      LeftTuple blockedPrevious=rightTuple.getBlocked();
      if (blockedPrevious != null) {
        leftTuple.setBlockedNext(blockedPrevious);
        blockedPrevious.setBlockedPrevious(leftTuple);
      }
      rightTuple.setBlocked(leftTuple);
      break;
    }
  }
  this.constraints.resetTuple(memory.getContext());
  if (leftTuple.getBlocker() == null) {
    if (this.tupleMemoryEnabled) {
      memory.getLeftTupleMemory().add(leftTuple);
    }
    this.sink.propagateAssertLeftTuple(leftTuple,context,workingMemory);
  }
}
