{
  if (builder.getRuleClass() == null) {
    return;
  }
  addClassCompileTask(this.pkg.getName() + "." + ruleDescr.getClassName(),ruleDescr,builder.getRuleClass(),this.src,new RuleErrorHandler(ruleDescr,rule,"Rule Compilation error"));
  for (final Iterator it=builder.getInvokers().keySet().iterator(); it.hasNext(); ) {
    final String className=(String)it.next();
    final Object invoker=builder.getInvokerLookups().get(className);
    if (invoker != null) {
      this.pkg.getPackageCompilationData().putInvoker(className,invoker);
    }
    final String text=(String)builder.getInvokers().get(className);
    final BaseDescr descr=(BaseDescr)builder.getDescrLookups().get(className);
    addClassCompileTask(className,descr,text,this.src,new RuleInvokerErrorHandler(descr,rule,"Unable to generate rule invoker."));
  }
  String name=pkg.getName() + "." + ucFirst(ruleDescr.getClassName());
  LineMappings mapping=new LineMappings(name);
  mapping.setStartLine(ruleDescr.getConsequenceLine());
  mapping.setOffset(ruleDescr.getConsequenceOffset());
  this.lineMappings.put(name,mapping);
}
