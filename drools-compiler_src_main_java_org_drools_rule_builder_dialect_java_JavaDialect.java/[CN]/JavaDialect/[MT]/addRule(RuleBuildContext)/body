{
  RuleClassBuilder classBuilder=context.getDialect().getRuleClassBuilder();
  String ruleClass=classBuilder.buildRule(context);
  if (ruleClass == null) {
    return;
  }
  final Rule rule=context.getRule();
  final RuleDescr ruleDescr=context.getRuleDescr();
  addClassCompileTask(this.pkg.getName() + "." + ruleDescr.getClassName(),ruleDescr,ruleClass,this.src,new RuleErrorHandler(ruleDescr,rule,"Rule Compilation error"));
  JavaDialectData data=(JavaDialectData)this.pkg.getDialectDatas().getDialectData(this.ID);
  for (final Iterator it=context.getInvokers().keySet().iterator(); it.hasNext(); ) {
    final String className=(String)it.next();
    final Object invoker=context.getInvokerLookups().get(className);
    if (invoker != null) {
      data.putInvoker(className,invoker);
    }
    final String text=(String)context.getInvokers().get(className);
    final BaseDescr descr=(BaseDescr)context.getDescrLookups().get(className);
    addClassCompileTask(className,descr,text,this.src,new RuleInvokerErrorHandler(descr,rule,"Unable to generate rule invoker."));
  }
  final String name=this.pkg.getName() + "." + StringUtils.ucFirst(ruleDescr.getClassName());
  final LineMappings mapping=new LineMappings(name);
  mapping.setStartLine(ruleDescr.getConsequenceLine());
  mapping.setOffset(ruleDescr.getConsequenceOffset());
  this.pkg.getDialectDatas().getLineMappings().put(name,mapping);
}
