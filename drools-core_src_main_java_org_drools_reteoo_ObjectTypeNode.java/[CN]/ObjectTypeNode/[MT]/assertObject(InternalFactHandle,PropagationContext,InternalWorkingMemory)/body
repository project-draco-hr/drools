{
  if (dirty) {
    otnIdCounter=0;
    updateTupleSinkId(this,this);
    dirty=false;
  }
  if (objectMemoryEnabled && !(queryNode && !((DroolsQuery)factHandle.getObject()).isOpen())) {
    final ObjectTypeNodeMemory memory=(ObjectTypeNodeMemory)workingMemory.getNodeMemory(this);
    memory.memory.add(factHandle,false);
  }
  if (compiledNetwork != null) {
    compiledNetwork.assertObject(factHandle,context,workingMemory);
  }
 else {
    context.setCurrentPropagatingOTN(this);
    this.sink.propagateAssertObject(factHandle,context,workingMemory);
  }
  if (context.getReaderContext() == null && this.objectType.isEvent() && this.expirationOffset >= 0 && this.expirationOffset != Long.MAX_VALUE) {
    WorkingMemoryReteExpireAction expire=new WorkingMemoryReteExpireAction(factHandle,this);
    TimerService clock=workingMemory.getTimerService();
    long nextTimestamp=Math.max(clock.getCurrentTime() + this.expirationOffset,((EventFactHandle)factHandle).getStartTimestamp() + this.expirationOffset);
    JobContext jobctx=new ExpireJobContext(expire,workingMemory);
    JobHandle handle=clock.scheduleJob(job,jobctx,new PointInTimeTrigger(nextTimestamp,null,null));
    jobctx.setJobHandle(handle);
  }
}
