{
  returnAST=null;
  ASTPair currentAST=new ASTPair();
  AST statement_AST=null;
  AST m_AST=null;
  Token c=null;
  AST c_AST=null;
  Token s=null;
  AST s_AST=null;
switch (LA(1)) {
case LCURLY:
{
      compoundStatement();
      astFactory.addASTChild(currentAST,returnAST);
      statement_AST=(AST)currentAST.root;
      break;
    }
case LITERAL_if:
{
    AST tmp91_AST=null;
    tmp91_AST=astFactory.create(LT(1));
    astFactory.makeASTRoot(currentAST,tmp91_AST);
    match(LITERAL_if);
    match(LPAREN);
    expression();
    astFactory.addASTChild(currentAST,returnAST);
    match(RPAREN);
    statement();
    astFactory.addASTChild(currentAST,returnAST);
{
      if ((LA(1) == LITERAL_else) && (_tokenSet_6.member(LA(2)))) {
        match(LITERAL_else);
        statement();
        astFactory.addASTChild(currentAST,returnAST);
      }
 else       if ((_tokenSet_17.member(LA(1))) && (_tokenSet_18.member(LA(2)))) {
      }
 else {
        throw new NoViableAltException(LT(1),getFilename());
      }
    }
    statement_AST=(AST)currentAST.root;
    break;
  }
case LITERAL_for:
{
  AST tmp95_AST=null;
  tmp95_AST=astFactory.create(LT(1));
  astFactory.makeASTRoot(currentAST,tmp95_AST);
  match(LITERAL_for);
  match(LPAREN);
  forInit();
  astFactory.addASTChild(currentAST,returnAST);
  match(SEMI);
  forCond();
  astFactory.addASTChild(currentAST,returnAST);
  match(SEMI);
  forIter();
  astFactory.addASTChild(currentAST,returnAST);
  match(RPAREN);
  statement();
  astFactory.addASTChild(currentAST,returnAST);
  statement_AST=(AST)currentAST.root;
  break;
}
case LITERAL_while:
{
AST tmp100_AST=null;
tmp100_AST=astFactory.create(LT(1));
astFactory.makeASTRoot(currentAST,tmp100_AST);
match(LITERAL_while);
match(LPAREN);
expression();
astFactory.addASTChild(currentAST,returnAST);
match(RPAREN);
statement();
astFactory.addASTChild(currentAST,returnAST);
statement_AST=(AST)currentAST.root;
break;
}
case LITERAL_do:
{
AST tmp103_AST=null;
tmp103_AST=astFactory.create(LT(1));
astFactory.makeASTRoot(currentAST,tmp103_AST);
match(LITERAL_do);
statement();
astFactory.addASTChild(currentAST,returnAST);
match(LITERAL_while);
match(LPAREN);
expression();
astFactory.addASTChild(currentAST,returnAST);
match(RPAREN);
match(SEMI);
statement_AST=(AST)currentAST.root;
break;
}
case LITERAL_break:
{
AST tmp108_AST=null;
tmp108_AST=astFactory.create(LT(1));
astFactory.makeASTRoot(currentAST,tmp108_AST);
match(LITERAL_break);
{
switch (LA(1)) {
case IDENT:
{
  AST tmp109_AST=null;
  tmp109_AST=astFactory.create(LT(1));
  astFactory.addASTChild(currentAST,tmp109_AST);
  match(IDENT);
  break;
}
case SEMI:
{
break;
}
default :
{
throw new NoViableAltException(LT(1),getFilename());
}
}
}
match(SEMI);
statement_AST=(AST)currentAST.root;
break;
}
case LITERAL_continue:
{
AST tmp111_AST=null;
tmp111_AST=astFactory.create(LT(1));
astFactory.makeASTRoot(currentAST,tmp111_AST);
match(LITERAL_continue);
{
switch (LA(1)) {
case IDENT:
{
AST tmp112_AST=null;
tmp112_AST=astFactory.create(LT(1));
astFactory.addASTChild(currentAST,tmp112_AST);
match(IDENT);
break;
}
case SEMI:
{
break;
}
default :
{
throw new NoViableAltException(LT(1),getFilename());
}
}
}
match(SEMI);
statement_AST=(AST)currentAST.root;
break;
}
case LITERAL_return:
{
AST tmp114_AST=null;
tmp114_AST=astFactory.create(LT(1));
astFactory.makeASTRoot(currentAST,tmp114_AST);
match(LITERAL_return);
{
switch (LA(1)) {
case IDENT:
case LPAREN:
case LITERAL_void:
case LITERAL_boolean:
case LITERAL_byte:
case LITERAL_char:
case LITERAL_short:
case LITERAL_int:
case LITERAL_float:
case LITERAL_long:
case LITERAL_double:
case LITERAL_this:
case LITERAL_super:
case PLUS:
case MINUS:
case INC:
case DEC:
case BNOT:
case LNOT:
case LITERAL_true:
case LITERAL_false:
case LITERAL_null:
case LITERAL_new:
case NUM_INT:
case CHAR_LITERAL:
case STRING_LITERAL:
case NUM_FLOAT:
case NUM_LONG:
case NUM_DOUBLE:
{
expression();
astFactory.addASTChild(currentAST,returnAST);
break;
}
case SEMI:
{
break;
}
default :
{
throw new NoViableAltException(LT(1),getFilename());
}
}
}
match(SEMI);
statement_AST=(AST)currentAST.root;
break;
}
case LITERAL_switch:
{
AST tmp116_AST=null;
tmp116_AST=astFactory.create(LT(1));
astFactory.makeASTRoot(currentAST,tmp116_AST);
match(LITERAL_switch);
match(LPAREN);
expression();
astFactory.addASTChild(currentAST,returnAST);
match(RPAREN);
match(LCURLY);
{
_loop115: do {
if ((LA(1) == LITERAL_case || LA(1) == LITERAL_default)) {
casesGroup();
astFactory.addASTChild(currentAST,returnAST);
}
 else {
break _loop115;
}
}
 while (true);
}
match(RCURLY);
statement_AST=(AST)currentAST.root;
break;
}
case LITERAL_try:
{
tryBlock();
astFactory.addASTChild(currentAST,returnAST);
statement_AST=(AST)currentAST.root;
break;
}
case LITERAL_throw:
{
AST tmp121_AST=null;
tmp121_AST=astFactory.create(LT(1));
astFactory.makeASTRoot(currentAST,tmp121_AST);
match(LITERAL_throw);
expression();
astFactory.addASTChild(currentAST,returnAST);
match(SEMI);
statement_AST=(AST)currentAST.root;
break;
}
case SEMI:
{
s=LT(1);
s_AST=astFactory.create(s);
astFactory.addASTChild(currentAST,s_AST);
match(SEMI);
if (inputState.guessing == 0) {
s_AST.setType(EMPTY_STAT);
}
statement_AST=(AST)currentAST.root;
break;
}
default :
boolean synPredMatched109=false;
if (((_tokenSet_19.member(LA(1))) && (_tokenSet_20.member(LA(2))))) {
int _m109=mark();
synPredMatched109=true;
inputState.guessing++;
try {
{
declaration();
}
}
 catch (RecognitionException pe) {
synPredMatched109=false;
}
rewind(_m109);
inputState.guessing--;
}
if (synPredMatched109) {
declaration();
astFactory.addASTChild(currentAST,returnAST);
match(SEMI);
statement_AST=(AST)currentAST.root;
}
 else if ((_tokenSet_4.member(LA(1))) && (_tokenSet_21.member(LA(2)))) {
expression();
astFactory.addASTChild(currentAST,returnAST);
match(SEMI);
statement_AST=(AST)currentAST.root;
}
 else if ((_tokenSet_22.member(LA(1))) && (_tokenSet_23.member(LA(2)))) {
modifiers();
m_AST=(AST)returnAST;
classDefinition(m_AST);
astFactory.addASTChild(currentAST,returnAST);
statement_AST=(AST)currentAST.root;
}
 else if ((LA(1) == IDENT) && (LA(2) == COLON)) {
AST tmp125_AST=null;
tmp125_AST=astFactory.create(LT(1));
astFactory.addASTChild(currentAST,tmp125_AST);
match(IDENT);
c=LT(1);
c_AST=astFactory.create(c);
astFactory.makeASTRoot(currentAST,c_AST);
match(COLON);
if (inputState.guessing == 0) {
c_AST.setType(LABELED_STAT);
}
statement();
astFactory.addASTChild(currentAST,returnAST);
statement_AST=(AST)currentAST.root;
}
 else if ((LA(1) == LITERAL_synchronized) && (LA(2) == LPAREN)) {
AST tmp126_AST=null;
tmp126_AST=astFactory.create(LT(1));
astFactory.makeASTRoot(currentAST,tmp126_AST);
match(LITERAL_synchronized);
match(LPAREN);
expression();
astFactory.addASTChild(currentAST,returnAST);
match(RPAREN);
compoundStatement();
astFactory.addASTChild(currentAST,returnAST);
statement_AST=(AST)currentAST.root;
}
 else {
throw new NoViableAltException(LT(1),getFilename());
}
}
returnAST=statement_AST;
}
