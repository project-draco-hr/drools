{
  final List<TerminalNode> nodes=new ArrayList<TerminalNode>();
  final GroupElement[] subrules=rule.getTransformedLhs();
  for (int i=0; i < subrules.length; i++) {
    final BuildContext context=new BuildContext(rulebase,idGenerator);
    context.setRule(rule);
    if (EventProcessingOption.STREAM.equals(rulebase.getConfiguration().getEventProcessingMode())) {
      TemporalDependencyMatrix temporal=this.utils.calculateTemporalDistance(subrules[i]);
      context.setTemporalDistance(temporal);
    }
    if (rulebase.getConfiguration().isSequential()) {
      context.setTupleMemoryEnabled(false);
      context.setObjectTypeNodeMemoryEnabled(false);
      context.setTerminalNodeMemoryEnabled(false);
      context.setAlphaNodeMemoryAllowed(false);
    }
 else {
      context.setTupleMemoryEnabled(true);
      context.setObjectTypeNodeMemoryEnabled(true);
      context.setTerminalNodeMemoryEnabled(true);
      context.setAlphaNodeMemoryAllowed(true);
    }
    final TerminalNode node=this.addSubRule(context,subrules[i],rule);
    nodes.add(node);
  }
  return nodes;
}
