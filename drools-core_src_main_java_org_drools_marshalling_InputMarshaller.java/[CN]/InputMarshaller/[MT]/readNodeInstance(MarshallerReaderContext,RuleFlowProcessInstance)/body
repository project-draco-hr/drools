{
  ObjectInputStream stream=context.stream;
  NodeInstanceImpl nodeInstance=null;
  long id=stream.readLong();
  long nodeId=stream.readLong();
  int nodeType=stream.readShort();
switch (nodeType) {
case PersisterEnums.RULE_SET_NODE_INSTANCE:
    nodeInstance=new RuleSetNodeInstance();
  break;
case PersisterEnums.WORK_ITEM_NODE_INSTANCE:
nodeInstance=new WorkItemNodeInstance();
((WorkItemNodeInstance)nodeInstance).internalSetWorkItemId(stream.readLong());
break;
case PersisterEnums.SUB_PROCESS_NODE_INSTANCE:
nodeInstance=new SubProcessNodeInstance();
((SubProcessNodeInstance)nodeInstance).internalSetProcessInstanceId(stream.readLong());
break;
case PersisterEnums.MILESTONE_NODE_INSTANCE:
nodeInstance=new MilestoneNodeInstance();
break;
case PersisterEnums.TIMER_NODE_INSTANCE:
nodeInstance=new TimerNodeInstance();
((TimerNodeInstance)nodeInstance).internalSetTimerId(stream.readLong());
break;
case PersisterEnums.JOIN_NODE_INSTANCE:
nodeInstance=new JoinInstance();
int number=stream.readInt();
if (number > 0) {
Map<Long,Integer> triggers=new HashMap<Long,Integer>();
for (int i=0; i < number; i++) {
long l=stream.readLong();
int count=stream.readInt();
triggers.put(l,count);
}
((JoinInstance)nodeInstance).internalSetTriggers(triggers);
}
break;
default :
throw new IllegalArgumentException("Unknown node type: " + nodeType);
}
nodeInstance.setNodeId(nodeId);
nodeInstance.setNodeInstanceContainer(processInstance);
nodeInstance.setProcessInstance(processInstance);
nodeInstance.setId(id);
if (nodeInstance instanceof EventNodeInstance) {
((EventNodeInstance)nodeInstance).addEventListeners();
}
return nodeInstance;
}
