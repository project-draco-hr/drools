{
  ObjectSink[] sinks=riaNode.getSinkPropagator().getSinks();
  BetaNode betaNode=(BetaNode)sinks[0];
  BetaMemory bm;
  Memory nodeMem=wm.getNodeMemory(betaNode);
  if (NodeTypeEnums.AccumulateNode == betaNode.getType()) {
    bm=((AccumulateMemory)nodeMem).getBetaMemory();
  }
 else {
    bm=(BetaMemory)nodeMem;
  }
  BetaNode[] bns=null;
  BetaMemory[] bms=null;
  int length=sinks.length;
  if (length > 1) {
    bns=new BetaNode[sinks.length - 1];
    bms=new BetaMemory[sinks.length - 1];
    for (int i=1; i < length; i++) {
      bns[i - 1]=(BetaNode)sinks[i];
      Memory nodeMem2=wm.getNodeMemory(bns[i - 1]);
      if (NodeTypeEnums.AccumulateNode == betaNode.getType()) {
        bms[i - 1]=((AccumulateMemory)nodeMem2).getBetaMemory();
      }
 else {
        bms[i - 1]=(BetaMemory)nodeMem2;
      }
    }
  }
  length--;
  for (LeftTuple leftTuple=srcTuples.getInsertFirst(); leftTuple != null; ) {
    LeftTuple next=leftTuple.getStagedNext();
    InternalFactHandle handle=riaNode.createFactHandle(leftTuple,leftTuple.getPropagationContext(),wm);
    RightTuple rightTuple=new RightTuple(handle,betaNode);
    leftTuple.setObject(rightTuple);
    bm.getStagedRightTuples().addInsert(rightTuple);
    if (bns != null) {
      for (int i=0; i < length; i++) {
        rightTuple=new RightTuple(handle,bns[i]);
        bms[i].getStagedRightTuples().addInsert(rightTuple);
      }
    }
    leftTuple.clearStaged();
    leftTuple=next;
  }
  for (LeftTuple leftTuple=srcTuples.getDeleteFirst(); leftTuple != null; ) {
    LeftTuple next=leftTuple.getStagedNext();
    RightTuple rightTuple=(RightTuple)leftTuple.getObject();
    RightTupleSets rightTuples=bm.getStagedRightTuples();
switch (rightTuple.getStagedType()) {
case LeftTuple.INSERT:
{
        rightTuples.removeInsert(rightTuple);
        break;
      }
case LeftTuple.UPDATE:
{
      rightTuples.removeUpdate(rightTuple);
      break;
    }
}
rightTuples.addDelete(rightTuple);
if (bns != null) {
  for (int i=0; i < length; i++) {
    rightTuple=rightTuple.getHandleNext();
    rightTuples=bms[i].getStagedRightTuples();
switch (rightTuple.getStagedType()) {
case LeftTuple.INSERT:
{
        rightTuples.removeInsert(rightTuple);
        break;
      }
case LeftTuple.UPDATE:
{
      rightTuples.removeUpdate(rightTuple);
      break;
    }
}
rightTuples.addDelete(rightTuple);
}
}
leftTuple.clearStaged();
leftTuple=next;
}
for (LeftTuple leftTuple=srcTuples.getUpdateFirst(); leftTuple != null; ) {
LeftTuple next=leftTuple.getStagedNext();
RightTuple rightTuple=(RightTuple)leftTuple.getObject();
RightTupleSets rightTuples=bm.getStagedRightTuples();
switch (rightTuple.getStagedType()) {
case LeftTuple.INSERT:
{
rightTuples.removeInsert(rightTuple);
break;
}
case LeftTuple.UPDATE:
{
rightTuples.removeUpdate(rightTuple);
break;
}
}
rightTuples.addUpdate(rightTuple);
if (bns != null) {
for (int i=0; i < length; i++) {
rightTuple=rightTuple.getHandleNext();
rightTuples=bms[i].getStagedRightTuples();
switch (rightTuple.getStagedType()) {
case LeftTuple.INSERT:
{
rightTuples.removeInsert(rightTuple);
break;
}
case LeftTuple.UPDATE:
{
rightTuples.removeUpdate(rightTuple);
break;
}
}
rightTuples.addUpdate(rightTuple);
}
}
leftTuple.clearStaged();
leftTuple=next;
}
srcTuples.resetAll();
}
