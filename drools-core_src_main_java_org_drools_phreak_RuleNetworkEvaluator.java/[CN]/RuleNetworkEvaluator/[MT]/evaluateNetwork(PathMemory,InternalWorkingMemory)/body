{
  SegmentMemory[] smems=rmem.getSegmentMemories();
  int smemIndex=0;
  SegmentMemory smem=smems[smemIndex];
  LeftInputAdapterNode liaNode=(LeftInputAdapterNode)smem.getRootNode();
  NetworkNode node;
  Memory nodeMem;
  if (liaNode == smem.getTipNode()) {
    smem=smems[++smemIndex];
    node=smem.getRootNode();
    nodeMem=smem.getNodeMemories().getFirst();
  }
 else {
    LeftTupleSinkPropagator sink=liaNode.getSinkPropagator();
    LeftTupleSinkNode firstSink=(LeftTupleSinkNode)sink.getFirstLeftTupleSink();
    LeftTupleSinkNode secondSink=firstSink.getNextLeftTupleSinkNode();
    if (sink.size() == 2) {
      node=secondSink;
    }
 else {
      node=firstSink;
    }
    nodeMem=smem.getNodeMemories().getFirst().getNext();
  }
  LeftTupleSets srcTuples=smem.getStagedLeftTuples();
  if (log.isTraceEnabled()) {
    log.trace("Rule[name={}] segments={} {}",rmem.getRuleTerminalNode().getRule().getName(),smems.length,srcTuples.toStringSizes());
  }
  Set<String> visitedRules;
  if (rmem.getRuleTerminalNode().getType() == NodeTypeEnums.QueryTerminalNode) {
    visitedRules=new HashSet<String>();
  }
 else {
    visitedRules=Collections.<String>emptySet();
  }
  LinkedList<StackEntry> stack=new LinkedList<StackEntry>();
  eval1(liaNode,rmem,(LeftTupleSink)node,nodeMem,smems,smemIndex,srcTuples,wm,stack,visitedRules,true);
  return 0;
}
