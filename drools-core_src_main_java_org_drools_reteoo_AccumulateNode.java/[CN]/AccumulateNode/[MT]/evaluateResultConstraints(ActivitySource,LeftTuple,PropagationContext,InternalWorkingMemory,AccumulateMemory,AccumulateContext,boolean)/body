{
  final Object[] result=this.accumulate.getResult(memory.workingMemoryContext,accctx.context,leftTuple,workingMemory);
  if (result[0] == null) {
    throw new IllegalArgumentException("Accumulate's cannot return null");
  }
  if (accctx.result == null) {
    final InternalFactHandle handle=workingMemory.getFactHandleFactory().newFactHandle(result[0],workingMemory.getObjectTypeConfigurationRegistry().getObjectTypeConf(context.getEntryPoint(),result[0]),workingMemory,null);
    accctx.result=new RightTuple(handle,this);
  }
 else {
    accctx.result.getFactHandle().setObject(result[0]);
  }
  boolean isAllowed=result[0] != null;
  for (int i=0, length=this.resultConstraints.length; isAllowed && i < length; i++) {
    if (!this.resultConstraints[i].isAllowed(accctx.result.getFactHandle(),workingMemory,memory.alphaContexts[i])) {
      isAllowed=false;
    }
  }
  if (isAllowed) {
    this.resultBinder.updateFromTuple(memory.resultsContext,workingMemory,leftTuple);
    if (!this.resultBinder.isAllowedCachedLeft(memory.resultsContext,accctx.result.getFactHandle())) {
      isAllowed=false;
    }
    this.resultBinder.resetTuple(memory.resultsContext);
  }
  if (accctx.propagated == true) {
    LeftTuple[] matchings=splitList(leftTuple,accctx,false);
    if (isAllowed) {
      if (ActivitySource.LEFT.equals(source)) {
        this.sink.propagateModifyChildLeftTuple(leftTuple.firstChild,leftTuple,context,workingMemory,useLeftMemory);
      }
 else {
        this.sink.propagateModifyChildLeftTuple(leftTuple.firstChild,accctx.result,context,workingMemory,useLeftMemory);
      }
    }
 else {
      this.sink.propagateRetractLeftTuple(leftTuple,context,workingMemory);
      accctx.propagated=false;
    }
    restoreList(leftTuple,matchings);
  }
 else   if (isAllowed) {
    LeftTuple[] matchings=splitList(leftTuple,accctx,false);
    this.sink.propagateAssertLeftTuple(leftTuple,accctx.result,null,null,context,workingMemory,useLeftMemory);
    accctx.propagated=true;
    restoreList(leftTuple,matchings);
  }
}
