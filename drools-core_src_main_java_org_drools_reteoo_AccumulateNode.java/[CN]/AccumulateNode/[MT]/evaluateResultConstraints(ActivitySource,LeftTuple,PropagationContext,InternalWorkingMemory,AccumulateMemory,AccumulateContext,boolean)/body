{
  final Object result=this.accumulate.getResult(memory.workingMemoryContext,accctx.context,leftTuple,workingMemory);
  if (result == null) {
    throw new RuntimeDroolsException("Accumulate must not return a null value.");
  }
  if (accctx.result == null) {
    final InternalFactHandle handle=workingMemory.getFactHandleFactory().newFactHandle(result,workingMemory.getObjectTypeConfigurationRegistry().getObjectTypeConf(context.getEntryPoint(),result),workingMemory);
    accctx.result=new RightTuple(handle,this);
  }
 else {
    accctx.result.getFactHandle().setObject(result);
  }
  boolean isAllowed=true;
  for (int i=0, length=this.resultConstraints.length; i < length; i++) {
    if (!this.resultConstraints[i].isAllowed(accctx.result.getFactHandle(),workingMemory,memory.alphaContexts[i])) {
      isAllowed=false;
      break;
    }
  }
  if (isAllowed) {
    this.resultBinder.updateFromTuple(memory.resultsContext,workingMemory,leftTuple);
    if (!this.resultBinder.isAllowedCachedLeft(memory.resultsContext,accctx.result.getFactHandle())) {
      isAllowed=false;
    }
    this.resultBinder.resetTuple(memory.resultsContext);
  }
  if (accctx.propagated == true) {
    LeftTuple[] matchings=splitList(leftTuple,accctx,false);
    if (isAllowed) {
      if (ActivitySource.LEFT.equals(source)) {
        this.sink.propagateModifyChildLeftTuple(leftTuple.firstChild,leftTuple,context,workingMemory,useLeftMemory);
      }
 else {
        this.sink.propagateModifyChildLeftTuple(leftTuple.firstChild,accctx.result,context,workingMemory,useLeftMemory);
      }
    }
 else {
      this.sink.propagateRetractLeftTuple(leftTuple,context,workingMemory);
      accctx.propagated=false;
    }
    restoreList(leftTuple,matchings);
  }
 else   if (isAllowed) {
    LeftTuple[] matchings=splitList(leftTuple,accctx,false);
    this.sink.propagateAssertLeftTuple(leftTuple,accctx.result,null,null,context,workingMemory,useLeftMemory);
    accctx.propagated=true;
    restoreList(leftTuple,matchings);
  }
}
