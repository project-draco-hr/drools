{
  if (splitNode.getType() == Split.TYPE_AND) {
    return;
  }
  Map map=new HashMap(splitNode.getConstraints());
  for (Iterator it=map.entrySet().iterator(); it.hasNext(); ) {
    Entry entry=(Entry)it.next();
    Connection connection=(Connection)entry.getKey();
    ConstraintImpl constraint=(ConstraintImpl)entry.getValue();
    if ("rule".equals(constraint.getType())) {
      RuleFlowConstraintEvaluator ruleConstraint=new RuleFlowConstraintEvaluator();
      ruleConstraint.setDialect(constraint.getDialect());
      ruleConstraint.setName(constraint.getName());
      ruleConstraint.setPriority(constraint.getPriority());
      ruleConstraint.setPriority(constraint.getPriority());
      splitNode.setConstraint(connection,ruleConstraint);
    }
 else     if ("code".equals(constraint.getType())) {
      ReturnValueConstraintEvaluator returnValueConstraint=new ReturnValueConstraintEvaluator();
      returnValueConstraint.setDialect(constraint.getDialect());
      returnValueConstraint.setName(constraint.getName());
      returnValueConstraint.setPriority(constraint.getPriority());
      returnValueConstraint.setPriority(constraint.getPriority());
      splitNode.setConstraint(connection,returnValueConstraint);
      ReturnValueDescr returnValueDescr=new ReturnValueDescr();
      returnValueDescr.setText(constraint.getConstraint());
      Dialect dialect=this.packageBuilder.getDialectRegistry().getDialect(constraint.getDialect());
      dialect.getReturnValueEvaluatorBuilder().build(context,returnValueConstraint,returnValueDescr);
    }
  }
}
