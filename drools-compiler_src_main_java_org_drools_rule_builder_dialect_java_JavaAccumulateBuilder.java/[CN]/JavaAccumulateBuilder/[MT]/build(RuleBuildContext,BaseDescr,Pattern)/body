{
  final AccumulateDescr accumDescr=(AccumulateDescr)descr;
  final PatternBuilder patternBuilder=(PatternBuilder)context.getDialect().getBuilder(PatternDescr.class);
  final Pattern sourcePattern=patternBuilder.build(context,accumDescr.getSourcePattern());
  if (sourcePattern == null) {
    return null;
  }
  final Pattern resultPattern=patternBuilder.build(context,accumDescr.getResultPattern());
  Accumulate accumulate=null;
  if (accumDescr.isExternalFunction()) {
    final JavaAnalysisResult analysis=(JavaAnalysisResult)context.getDialect().analyzeBlock(context,accumDescr,accumDescr.getExpression());
    final List[] usedIdentifiers=analysis.getBoundIdentifiers();
    final List tupleDeclarations=new ArrayList();
    for (int i=0, size=usedIdentifiers[0].size(); i < size; i++) {
      tupleDeclarations.add(context.getDeclarationResolver().getDeclaration((String)usedIdentifiers[0].get(i)));
    }
    final Declaration[] previousDeclarations=(Declaration[])tupleDeclarations.toArray(new Declaration[tupleDeclarations.size()]);
    final String[] requiredGlobals=(String[])usedIdentifiers[1].toArray(new String[usedIdentifiers[1].size()]);
    final Declaration[] sourceDeclArr=(Declaration[])sourcePattern.getOuterDeclarations().values().toArray(new Declaration[0]);
    final String className="accumulateExpression" + context.getNextId();
    final Map map=createVariableContext(className,(String)accumDescr.getExpression(),context,previousDeclarations,sourceDeclArr,requiredGlobals);
    AccumulateFunction function=context.getConfiguration().getAccumulatorFunction(accumDescr.getFunctionIdentifier());
    JavaAccumulatorFunctionExecutor accumulator=new JavaAccumulatorFunctionExecutor(function);
    accumulate=new Accumulate(sourcePattern,resultPattern,previousDeclarations,sourceDeclArr,accumulator);
    generatTemplates("returnValueMethod","returnValueInvoker",context,className,map,accumulator,accumDescr);
  }
 else {
    final String className="Accumulate" + context.getNextId();
    accumDescr.setClassName(className);
    final JavaAnalysisResult analysis1=(JavaAnalysisResult)context.getDialect().analyzeBlock(context,accumDescr,accumDescr.getInitCode());
    final Dialect.AnalysisResult analysis2=context.getDialect().analyzeBlock(context,accumDescr,accumDescr.getActionCode());
    final Dialect.AnalysisResult analysis3=context.getDialect().analyzeExpression(context,accumDescr,accumDescr.getResultCode());
    final List requiredDeclarations=new ArrayList(analysis1.getBoundIdentifiers()[0]);
    requiredDeclarations.addAll(analysis2.getBoundIdentifiers()[0]);
    requiredDeclarations.addAll(analysis3.getBoundIdentifiers()[0]);
    final List requiredGlobals=new ArrayList(analysis1.getBoundIdentifiers()[1]);
    requiredGlobals.addAll(analysis2.getBoundIdentifiers()[1]);
    requiredGlobals.addAll(analysis3.getBoundIdentifiers()[1]);
    final Declaration[] declarations=new Declaration[requiredDeclarations.size()];
    for (int i=0, size=requiredDeclarations.size(); i < size; i++) {
      declarations[i]=context.getDeclarationResolver().getDeclaration((String)requiredDeclarations.get(i));
    }
    final Declaration[] sourceDeclArr=(Declaration[])sourcePattern.getOuterDeclarations().values().toArray(new Declaration[0]);
    final String[] globals=(String[])requiredGlobals.toArray(new String[requiredGlobals.size()]);
    final Map map=createVariableContext(className,null,context,declarations,null,globals);
    map.put("className",accumDescr.getClassName());
    map.put("innerDeclarations",sourceDeclArr);
    final String initCode=this.fixInitCode(analysis1,accumDescr.getInitCode());
    final String actionCode=accumDescr.getActionCode();
    final String resultCode=accumDescr.getResultCode();
    String[] attributesTypes=new String[analysis1.getLocalVariablesMap().size()];
    String[] attributes=new String[analysis1.getLocalVariablesMap().size()];
    int index=0;
    for (Iterator it=analysis1.getLocalVariablesMap().entrySet().iterator(); it.hasNext(); ) {
      Map.Entry entry=(Map.Entry)it.next();
      attributes[index]=(String)entry.getKey();
      attributesTypes[index]=((JavaLocalDeclarationDescr)entry.getValue()).getType();
    }
    map.put("attributes",attributes);
    map.put("attributesTypes",attributesTypes);
    map.put("initCode",initCode);
    map.put("actionCode",actionCode);
    map.put("resultCode",resultCode);
    if (accumDescr.getReverseCode() == null) {
      map.put("reverseCode","");
      map.put("supportsReverse","false");
    }
 else {
      map.put("reverseCode",accumDescr.getReverseCode());
      map.put("supportsReverse","true");
    }
    String resultType=null;
    if (resultPattern.getObjectType() instanceof ClassObjectType) {
      resultType=((ClassObjectType)resultPattern.getObjectType()).getClassType().getName();
    }
 else {
      resultType=resultPattern.getObjectType().getValueType().getClassType().getName();
    }
    map.put("resultType",resultType);
    map.put("hashCode",new Integer(actionCode.hashCode()));
    accumulate=new Accumulate(sourcePattern,resultPattern,declarations,sourceDeclArr);
    generatTemplates("accumulateInnerClass","accumulateInvoker",context,className,map,accumulate,accumDescr);
  }
  return accumulate;
}
