{
  final AccumulateDescr accumDescr=(AccumulateDescr)descr;
  final PatternBuilder patternBuilder=(PatternBuilder)context.getDialect().getBuilder(PatternDescr.class);
  final Pattern sourcePattern=(Pattern)patternBuilder.build(context,accumDescr.getInputPattern());
  if (sourcePattern == null) {
    return null;
  }
  Accumulate accumulate=null;
  if (accumDescr.isExternalFunction()) {
    final JavaAnalysisResult analysis=(JavaAnalysisResult)context.getDialect().analyzeBlock(context,accumDescr,accumDescr.getExpression());
    final List[] usedIdentifiers=analysis.getBoundIdentifiers();
    final List tupleDeclarations=new ArrayList();
    for (int i=0, size=usedIdentifiers[0].size(); i < size; i++) {
      tupleDeclarations.add(context.getDeclarationResolver().getDeclaration((String)usedIdentifiers[0].get(i)));
    }
    final Declaration[] previousDeclarations=(Declaration[])tupleDeclarations.toArray(new Declaration[tupleDeclarations.size()]);
    final String[] requiredGlobals=(String[])usedIdentifiers[1].toArray(new String[usedIdentifiers[1].size()]);
    final Declaration[] sourceDeclArr=(Declaration[])sourcePattern.getOuterDeclarations().values().toArray(new Declaration[0]);
    final String className="accumulateExpression" + context.getNextId();
    final Map map=createVariableContext(className,(String)accumDescr.getExpression(),context,previousDeclarations,sourceDeclArr,requiredGlobals);
    AccumulateFunction function=context.getConfiguration().getAccumulateFunction(accumDescr.getFunctionIdentifier());
    JavaAccumulatorFunctionExecutor accumulator=new JavaAccumulatorFunctionExecutor(function);
    accumulate=new Accumulate(sourcePattern,previousDeclarations,sourceDeclArr,accumulator);
    generatTemplates("returnValueMethod","returnValueInvoker",context,className,map,accumulator,accumDescr);
  }
 else {
    final String className="Accumulate" + context.getNextId();
    accumDescr.setClassName(className);
    final JavaAnalysisResult initCodeAnalysis=(JavaAnalysisResult)context.getDialect().analyzeBlock(context,accumDescr,accumDescr.getInitCode());
    final Dialect.AnalysisResult actionCodeAnalysis=context.getDialect().analyzeBlock(context,accumDescr,accumDescr.getActionCode());
    final Dialect.AnalysisResult resultCodeAnalysis=context.getDialect().analyzeExpression(context,accumDescr,accumDescr.getResultCode());
    final List requiredDeclarations=new ArrayList(initCodeAnalysis.getBoundIdentifiers()[0]);
    requiredDeclarations.addAll(actionCodeAnalysis.getBoundIdentifiers()[0]);
    requiredDeclarations.addAll(resultCodeAnalysis.getBoundIdentifiers()[0]);
    final List requiredGlobals=new ArrayList(initCodeAnalysis.getBoundIdentifiers()[1]);
    requiredGlobals.addAll(actionCodeAnalysis.getBoundIdentifiers()[1]);
    requiredGlobals.addAll(resultCodeAnalysis.getBoundIdentifiers()[1]);
    if (accumDescr.getReverseCode() != null) {
      final Dialect.AnalysisResult reverseCodeAnalysis=context.getDialect().analyzeBlock(context,accumDescr,accumDescr.getActionCode());
      requiredDeclarations.addAll(reverseCodeAnalysis.getBoundIdentifiers()[0]);
      requiredGlobals.addAll(reverseCodeAnalysis.getBoundIdentifiers()[1]);
    }
    final Declaration[] declarations=new Declaration[requiredDeclarations.size()];
    for (int i=0, size=requiredDeclarations.size(); i < size; i++) {
      declarations[i]=context.getDeclarationResolver().getDeclaration((String)requiredDeclarations.get(i));
    }
    final Declaration[] sourceDeclArr=(Declaration[])sourcePattern.getOuterDeclarations().values().toArray(new Declaration[0]);
    final String[] globals=(String[])requiredGlobals.toArray(new String[requiredGlobals.size()]);
    final Map map=createVariableContext(className,null,context,declarations,null,globals);
    map.put("className",accumDescr.getClassName());
    map.put("innerDeclarations",sourceDeclArr);
    final String initCode=this.fixInitCode(initCodeAnalysis,accumDescr.getInitCode());
    final String actionCode=accumDescr.getActionCode();
    final String resultCode=accumDescr.getResultCode();
    String[] attributesTypes=new String[initCodeAnalysis.getLocalVariablesMap().size()];
    String[] attributes=new String[initCodeAnalysis.getLocalVariablesMap().size()];
    int index=0;
    for (Iterator it=initCodeAnalysis.getLocalVariablesMap().entrySet().iterator(); it.hasNext(); ) {
      Map.Entry entry=(Map.Entry)it.next();
      attributes[index]=(String)entry.getKey();
      attributesTypes[index]=((JavaLocalDeclarationDescr)entry.getValue()).getType();
    }
    map.put("attributes",attributes);
    map.put("attributesTypes",attributesTypes);
    map.put("initCode",initCode);
    map.put("actionCode",actionCode);
    map.put("resultCode",resultCode);
    if (accumDescr.getReverseCode() == null) {
      map.put("reverseCode","");
      map.put("supportsReverse","false");
    }
 else {
      map.put("reverseCode",accumDescr.getReverseCode());
      map.put("supportsReverse","true");
    }
    map.put("hashCode",new Integer(actionCode.hashCode()));
    accumulate=new Accumulate(sourcePattern,declarations,sourceDeclArr);
    generatTemplates("accumulateInnerClass","accumulateInvoker",context,className,map,accumulate,accumDescr);
  }
  return accumulate;
}
