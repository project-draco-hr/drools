{
  final AccumulateDescr accumDescr=(AccumulateDescr)descr;
  if (!accumDescr.hasValidInput()) {
    return null;
  }
  final RuleConditionBuilder builder=(RuleConditionBuilder)context.getDialect().getBuilder(accumDescr.getInput().getClass());
  final RuleConditionElement source=builder.build(context,accumDescr.getInput());
  Map<String,Declaration> decls=context.getDeclarationResolver().getDeclarations(context.getRule());
  Map<String,Class<?>> declCls=context.getDeclarationResolver().getDeclarationClasses(decls);
  if (source == null) {
    return null;
  }
  Accumulate accumulate=null;
  if (accumDescr.isExternalFunction()) {
    AccumulateFunctionCallDescr func=accumDescr.getFunctions().get(0);
    AccumulateFunction function=context.getConfiguration().getAccumulateFunction(func.getFunction());
    if (function == null) {
      context.getErrors().add(new DescrBuildError(accumDescr,context.getRuleDescr(),null,"Unknown accumulate function: '" + func.getFunction() + "' on rule '"+ context.getRuleDescr().getName()+ "'. All accumulate functions must be registered before building a resource."));
      return null;
    }
    final JavaAnalysisResult analysis=(JavaAnalysisResult)context.getDialect().analyzeBlock(context,accumDescr,func.getParams()[0],new BoundIdentifiers(declCls,context.getPackageBuilder().getGlobals()));
    final BoundIdentifiers usedIdentifiers=analysis.getBoundIdentifiers();
    final Declaration[] previousDeclarations=usedIdentifiers.getDeclarations().values().toArray(new Declaration[usedIdentifiers.getDeclarations().size()]);
    final Declaration[] sourceDeclArr=(Declaration[])source.getOuterDeclarations().values().toArray(new Declaration[0]);
    final String className="accumulateExpression" + context.getNextId();
    final Map<String,Object> map=createVariableContext(className,func.getParams()[0],context,previousDeclarations,sourceDeclArr,usedIdentifiers.getGlobals(),null);
    map.put("readLocalsFromTuple",accumDescr.isMultiPattern() ? Boolean.TRUE : Boolean.FALSE);
    JavaAccumulatorFunctionExecutor accumulator=new JavaAccumulatorFunctionExecutor(function);
    accumulate=new Accumulate(source,previousDeclarations,sourceDeclArr,new Accumulator[]{accumulator});
    generatTemplates("returnValueMethod","returnValueInvoker",context,className,map,accumulator,accumDescr);
  }
 else {
    final String className="Accumulate" + context.getNextId();
    accumDescr.setClassName(className);
    BoundIdentifiers available=new BoundIdentifiers(declCls,context.getPackageBuilder().getGlobals());
    final JavaAnalysisResult initCodeAnalysis=(JavaAnalysisResult)context.getDialect().analyzeBlock(context,accumDescr,accumDescr.getInitCode(),available);
    final AnalysisResult actionCodeAnalysis=context.getDialect().analyzeBlock(context,accumDescr,accumDescr.getActionCode(),available);
    final AnalysisResult resultCodeAnalysis=context.getDialect().analyzeExpression(context,accumDescr,accumDescr.getResultCode(),available);
    final Set<String> requiredDeclarations=new HashSet<String>(initCodeAnalysis.getBoundIdentifiers().getDeclarations().keySet());
    requiredDeclarations.addAll(actionCodeAnalysis.getBoundIdentifiers().getDeclarations().keySet());
    requiredDeclarations.addAll(resultCodeAnalysis.getBoundIdentifiers().getDeclarations().keySet());
    final Map<String,Class<?>> requiredGlobals=new HashMap<String,Class<?>>(initCodeAnalysis.getBoundIdentifiers().getGlobals());
    requiredGlobals.putAll(actionCodeAnalysis.getBoundIdentifiers().getGlobals());
    requiredGlobals.putAll(resultCodeAnalysis.getBoundIdentifiers().getGlobals());
    if (accumDescr.getReverseCode() != null) {
      final AnalysisResult reverseCodeAnalysis=context.getDialect().analyzeBlock(context,accumDescr,accumDescr.getActionCode(),available);
      requiredDeclarations.addAll(reverseCodeAnalysis.getBoundIdentifiers().getDeclarations().keySet());
      requiredGlobals.putAll(reverseCodeAnalysis.getBoundIdentifiers().getGlobals());
    }
    final Declaration[] declarations=new Declaration[requiredDeclarations.size()];
    int i=0;
    for (Iterator<String> it=requiredDeclarations.iterator(); it.hasNext(); i++) {
      declarations[i]=decls.get(it.next());
    }
    final Declaration[] sourceDeclArr=(Declaration[])source.getOuterDeclarations().values().toArray(new Declaration[0]);
    final Map<String,Object> map=createVariableContext(className,null,context,declarations,null,requiredGlobals,null);
    map.put("className",accumDescr.getClassName());
    map.put("innerDeclarations",sourceDeclArr);
    map.put("isMultiPattern",accumDescr.isMultiPattern() ? Boolean.TRUE : Boolean.FALSE);
    final String initCode=this.fixInitCode(initCodeAnalysis,accumDescr.getInitCode());
    final String actionCode=accumDescr.getActionCode();
    final String resultCode=accumDescr.getResultCode();
    String[] attributesTypes=new String[initCodeAnalysis.getLocalVariablesMap().size()];
    String[] attributes=new String[initCodeAnalysis.getLocalVariablesMap().size()];
    int index=0;
    for (    Map.Entry<String,JavaLocalDeclarationDescr> entry : initCodeAnalysis.getLocalVariablesMap().entrySet()) {
      attributes[index]=entry.getKey();
      attributesTypes[index]=entry.getValue().getType();
      index++;
    }
    map.put("attributes",attributes);
    map.put("attributesTypes",attributesTypes);
    map.put("initCode",initCode);
    map.put("actionCode",actionCode);
    map.put("resultCode",resultCode);
    if (accumDescr.getReverseCode() == null) {
      map.put("reverseCode","");
      map.put("supportsReverse","false");
    }
 else {
      map.put("reverseCode",accumDescr.getReverseCode());
      map.put("supportsReverse","true");
    }
    map.put("hashCode",new Integer(actionCode.hashCode()));
    accumulate=new Accumulate(source,declarations,sourceDeclArr);
    generatTemplates("accumulateInnerClass","accumulateInvoker",context,className,map,accumulate,accumDescr);
  }
  return accumulate;
}
