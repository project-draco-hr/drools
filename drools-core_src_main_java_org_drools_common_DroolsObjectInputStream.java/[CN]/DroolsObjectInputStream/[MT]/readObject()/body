{
  byte type=readRecordType();
switch (type) {
case RT_REFERENCE:
    return objectsByHandle.get(dataInput.readInt());
case RT_NULL:
  return null;
case RT_EXTERNALIZABLE:
{
  int handle=dataInput.readInt();
  Class clazz=(Class)readObject();
  Externalizable externalizable;
  try {
    externalizable=(Externalizable)clazz.newInstance();
  }
 catch (  InstantiationException e) {
    throw newInvalidClassException(clazz,e);
  }
catch (  IllegalAccessException e) {
    throw newInvalidClassException(clazz,e);
  }
  registerObject(handle,externalizable);
  externalizable.readExternal(this);
  return externalizable;
}
case RT_MAP:
{
int handle=dataInput.readInt();
Class clazz=(Class)readObject();
int size=dataInput.readInt();
Map<Object,Object> map=(Map<Object,Object>)newCollection(handle,clazz,size);
while (size-- > 0) {
  Object key=readObject();
  Object value=readObject();
  map.put(key,value);
}
return map;
}
case RT_ARRAY:
{
int handle=dataInput.readInt();
Class clazz=(Class)readObject();
int length=dataInput.readInt();
Class componentType=clazz.getComponentType();
Object array=Array.newInstance(componentType,length);
registerObject(handle,array);
if (componentType.isPrimitive()) {
readPrimitiveArray(array,length,componentType);
}
 else {
Object[] objects=(Object[])array;
for (int i=0; i < length; ++i) {
  objects[i]=readObject();
}
}
return array;
}
case RT_COLLECTION:
{
int handle=dataInput.readInt();
Class clazz=(Class)readObject();
int size=dataInput.readInt();
Collection<Object> collection=(Collection<Object>)newCollection(handle,clazz,size);
while (size-- > 0) {
collection.add(readObject());
}
return collection;
}
case RT_STRING:
return readString(dataInput.readInt());
case RT_CLASS:
return readClass(dataInput.readInt());
case RT_EMPTY_SET:
return readEmptySet();
case RT_EMPTY_LIST:
return readEmptyList();
case RT_EMPTY_MAP:
return readEmptyMap();
default :
int handle=dataInput.readInt();
switch (type) {
case RT_ATOMICREFERENCEARRAY:
{
int length=dataInput.readInt();
AtomicReferenceArray<Object> array=new AtomicReferenceArray<Object>(length);
registerObject(handle,array);
for (int i=0; i < length; ++i) {
array.set(i,readObject());
}
return array;
}
case RT_SERIALIZABLE:
{
Object object=dataInput.readObject();
registerObject(handle,object);
return object;
}
default :
throw new StreamCorruptedException("Unsupported object type: " + type);
}
}
}
