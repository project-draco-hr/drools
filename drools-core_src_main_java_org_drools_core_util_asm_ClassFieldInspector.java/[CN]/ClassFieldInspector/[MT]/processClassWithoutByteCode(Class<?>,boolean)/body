{
  final List<Method> methods=Arrays.asList(clazz.getMethods());
  Collections.sort(methods,new Comparator<Method>(){
    public int compare(    Method m1,    Method m2){
      return m1.getName().compareTo(m2.getName());
    }
  }
);
  for (int i=0; i < methods.size(); i++) {
    final int mask=includeFinalMethods ? Modifier.PUBLIC : Modifier.PUBLIC | Modifier.FINAL;
    Method method=methods.get(i);
    if (((method.getModifiers() & mask) == Opcodes.ACC_PUBLIC) && (method.getParameterTypes().length == 0) && (!method.getName().equals("<init>"))&& (!method.getName().equals("<clinit>"))&& (method.getReturnType() != void.class)) {
      final int fieldIndex=this.fieldNames.size();
      addToMapping(method,fieldIndex);
    }
 else     if (((method.getModifiers() & mask) == Opcodes.ACC_PUBLIC) && (method.getParameterTypes().length == 1) && (method.getName().startsWith("set"))) {
      final int fieldIndex=this.fieldNames.size();
      addToMapping(method,fieldIndex);
    }
  }
  final List<Field> flds=Arrays.asList(clazz.getFields());
  Collections.sort(flds,new Comparator<Field>(){
    public int compare(    Field f1,    Field f2){
      return f1.getName().compareTo(f2.getName());
    }
  }
);
  for (  Field fld : flds) {
    if (!Modifier.isStatic(fld.getModifiers()) && !fieldNames.containsKey(fld.getName())) {
      final int fieldIndex=this.fieldNames.size();
      this.fieldNames.put(fld.getName(),fieldIndex);
      this.fieldTypes.put(fld.getName(),fld.getType());
      this.fieldTypesField.put(fld.getName(),fld);
    }
  }
}
