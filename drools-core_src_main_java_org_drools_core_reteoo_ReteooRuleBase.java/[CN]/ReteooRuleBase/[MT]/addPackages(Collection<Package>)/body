{
  List<Package> clonedPkgs=new ArrayList<Package>();
  for (  Package newPkg : newPkgs) {
    clonedPkgs.add(newPkg.deepCloneIfAlreadyInUse(rootClassLoader));
  }
  lock();
  try {
    for (    Package newPkg : clonedPkgs) {
      newPkg.checkValidity();
      this.additionsSinceLock++;
      this.eventSupport.fireBeforePackageAdded(newPkg);
      if (newPkg.hasTraitRegistry()) {
        getTraitRegistry().merge(newPkg.getTraitRegistry());
      }
      Package pkg=this.pkgs.get(newPkg.getName());
      if (pkg == null) {
        pkg=new Package(newPkg.getName());
        pkg.setClassFieldAccessorCache(this.classFieldAccessorCache);
        pkgs.put(pkg.getName(),pkg);
      }
      pkg.getDialectRuntimeRegistry().merge(newPkg.getDialectRuntimeRegistry(),this.rootClassLoader,true);
    }
    for (    Package newPkg : clonedPkgs) {
      String lastType=null;
      try {
        if (newPkg.getTypeDeclarations() != null) {
          JavaDialectRuntimeData runtime=((JavaDialectRuntimeData)newPkg.getDialectRuntimeRegistry().getDialectData("java"));
          for (          TypeDeclaration newDecl : newPkg.getTypeDeclarations().values()) {
            lastType=newDecl.getTypeClassName();
            TypeDeclaration typeDeclaration=this.classTypeDeclaration.get(newDecl.getTypeClassName());
            if (typeDeclaration == null) {
              String className=newDecl.getTypeClassName();
              byte[] def=runtime.getClassDefinition(JavaDialectRuntimeData.convertClassToResourcePath(className));
              Class<?> definedKlass=registerAndLoadTypeDefinition(className,def);
              if (definedKlass == null && typeDeclaration.isNovel()) {
                throw new RuntimeException("Registering null bytes for class " + className);
              }
              if (newDecl.getTypeClassDef() == null) {
                newDecl.setTypeClassDef(new ClassDefinition());
              }
              newDecl.getTypeClassDef().setDefinedClass(definedKlass);
              newDecl.setTypeClass(definedKlass);
              this.classTypeDeclaration.put(className,newDecl);
              typeDeclaration=newDecl;
            }
 else {
              Class<?> definedKlass=typeDeclaration.getTypeClass();
              newDecl.getTypeClassDef().setDefinedClass(definedKlass);
              newDecl.setTypeClass(definedKlass);
              mergeTypeDeclarations(typeDeclaration,newDecl);
            }
            updateDependentTypes(newPkg,typeDeclaration);
          }
        }
      }
 catch (      ClassNotFoundException e) {
        throw new RuntimeDroolsException("unable to resolve Type Declaration class '" + lastType + "'",e);
      }
    }
    for (    Package newPkg : clonedPkgs) {
      Package pkg=this.pkgs.get(newPkg.getName());
      if (newPkg.getFunctions() != null) {
        for (        Map.Entry<String,Function> entry : newPkg.getFunctions().entrySet()) {
          pkg.addFunction(entry.getValue());
        }
      }
      pkg.getDialectRuntimeRegistry().onBeforeExecute();
      pkg.getClassFieldAccessorStore().merge(newPkg.getClassFieldAccessorStore());
    }
    for (    Package newPkg : clonedPkgs) {
      Package pkg=this.pkgs.get(newPkg.getName());
      mergePackage(pkg,newPkg);
      for (      WindowDeclaration window : newPkg.getWindowDeclarations().values()) {
        addWindowDeclaration(newPkg,window);
      }
      for (      String id : newPkg.getEntryPointIds()) {
        addEntryPoint(id);
      }
      for (      Rule rule : newPkg.getRules()) {
        addRule(newPkg,rule);
      }
      if (newPkg.getRuleFlows() != null) {
        final Map<String,org.kie.api.definition.process.Process> flows=newPkg.getRuleFlows();
        for (        org.kie.api.definition.process.Process process : flows.values()) {
          addProcess(process);
        }
      }
      this.eventSupport.fireAfterPackageAdded(newPkg);
    }
  }
  finally {
    unlock();
  }
}
