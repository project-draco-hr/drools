{
  Map<String,PackageDescr> foreignPackages=null;
  for (  AbstractClassTypeDeclarationDescr typeDescr : packageDescr.getClassAndEnumDeclarationDescrs()) {
    if (kbuilder.filterAccepts(typeDescr.getNamespace(),typeDescr.getTypeName())) {
      String qName=typeDescr.getType().getFullName();
      Class<?> typeClass=getClassForType(qName);
      if (typeClass == null) {
        typeClass=getClassForType(typeDescr.getTypeName());
      }
      if (typeClass == null) {
        for (        ImportDescr id : packageDescr.getImports()) {
          String imp=id.getTarget();
          int separator=imp.lastIndexOf('.');
          String tail=imp.substring(separator + 1);
          if (tail.equals(typeDescr.getTypeName())) {
            typeDescr.setNamespace(imp.substring(0,separator));
            typeClass=getClassForType(typeDescr.getType().getFullName());
            break;
          }
 else           if (tail.equals("*")) {
            typeClass=getClassForType(imp.substring(0,imp.length() - 1) + typeDescr.getType().getName());
            if (typeClass != null) {
              String resolvedNamespace=imp.substring(0,separator);
              if (resolvedNamespace.equals(typeDescr.getNamespace())) {
                break;
              }
 else               if (isCompatible(typeClass,typeDescr)) {
                typeDescr.setNamespace(resolvedNamespace);
              }
 else {
                typeClass=null;
              }
            }
          }
        }
      }
      String className=typeClass != null ? typeClass.getName() : qName;
      int dotPos=className.lastIndexOf('.');
      if (dotPos >= 0) {
        typeDescr.setNamespace(className.substring(0,dotPos));
        typeDescr.setTypeName(className.substring(dotPos + 1));
      }
      if (isEmpty(typeDescr.getNamespace()) && typeDescr.getFields().isEmpty()) {
        PackageRegistry pkgReg=kbuilder.getPackageRegistry(packageDescr.getName());
        if (pkgReg != null) {
          try {
            Class<?> clz=pkgReg.getTypeResolver().resolveType(typeDescr.getTypeName());
            java.lang.Package pkg=clz.getPackage();
            if (pkg != null) {
              typeDescr.setNamespace(pkg.getName());
              int index=typeDescr.getNamespace() != null && !typeDescr.getNamespace().isEmpty() ? typeDescr.getNamespace().length() + 1 : 0;
              typeDescr.setTypeName(clz.getCanonicalName().substring(index));
            }
          }
 catch (          Exception e) {
          }
        }
      }
      if (isEmpty(typeDescr.getNamespace())) {
        typeDescr.setNamespace(packageDescr.getNamespace());
      }
      if (typeDescr instanceof TypeDeclarationDescr) {
        fillSuperType((TypeDeclarationDescr)typeDescr,packageDescr);
      }
      fillFieldTypes(typeDescr,packageDescr);
      if (!typeDescr.getNamespace().equals(packageDescr.getNamespace())) {
        PackageDescr altDescr;
        if (foreignPackages == null) {
          foreignPackages=new HashMap<String,PackageDescr>();
        }
        if (foreignPackages.containsKey(typeDescr.getNamespace())) {
          altDescr=foreignPackages.get(typeDescr.getNamespace());
        }
 else {
          altDescr=new PackageDescr(typeDescr.getNamespace());
          foreignPackages.put(typeDescr.getNamespace(),altDescr);
        }
        if (typeDescr instanceof TypeDeclarationDescr) {
          altDescr.addTypeDeclaration((TypeDeclarationDescr)typeDescr);
        }
 else         if (typeDescr instanceof EnumDeclarationDescr) {
          altDescr.addEnumDeclaration((EnumDeclarationDescr)typeDescr);
        }
        for (        ImportDescr imp : packageDescr.getImports()) {
          altDescr.addImport(imp);
        }
        if (!kbuilder.getPackageRegistry().containsKey(altDescr.getNamespace())) {
          kbuilder.newPackage(altDescr);
        }
      }
    }
  }
  if (foreignPackages != null) {
    for (    String ns : foreignPackages.keySet()) {
      kbuilder.mergePackage(kbuilder.getPackageRegistry(ns),foreignPackages.get(ns));
    }
    foreignPackages.clear();
  }
  Collection<AbstractClassTypeDeclarationDescr> sortedTypeDescriptors=sortByHierarchy(packageDescr.getClassAndEnumDeclarationDescrs());
  for (  AbstractClassTypeDeclarationDescr typeDescr : sortedTypeDescriptors) {
    registerGeneratedType(typeDescr);
  }
  if (kbuilder.hasErrors()) {
    return Collections.emptyList();
  }
  for (  AbstractClassTypeDeclarationDescr typeDescr : sortedTypeDescriptors) {
    if (!typeDescr.getNamespace().equals(packageDescr.getNamespace())) {
      continue;
    }
    if (typeDescr instanceof TypeDeclarationDescr) {
      TypeDeclarationDescr tDescr=(TypeDeclarationDescr)typeDescr;
      for (      QualifiedName qname : tDescr.getSuperTypes()) {
        if (mergeInheritedFields(tDescr)) {
          for (          AbstractClassTypeDeclarationDescr descr : sortedTypeDescriptors) {
            if (qname.equals(descr.getType())) {
              typeDescr.getAnnotations().putAll(descr.getAnnotations());
              break;
            }
 else             if (typeDescr.getType().equals(descr.getType())) {
              break;
            }
          }
        }
      }
    }
    TypeDeclaration type=new TypeDeclaration(typeDescr.getTypeName());
    if (typeDescr.getResource() == null) {
      typeDescr.setResource(kbuilder.getCurrentResource());
    }
    type.setResource(typeDescr.getResource());
    TypeDeclaration parent=null;
    if (!typeDescr.getSuperTypes().isEmpty()) {
      PackageRegistry sup=kbuilder.getPackageRegistry(typeDescr.getSuperTypeNamespace());
      if (sup != null) {
        parent=sup.getPackage().getTypeDeclaration(typeDescr.getSuperTypeName());
        if (parent == null) {
          kbuilder.addBuilderResult(new TypeDeclarationError(typeDescr,"Declared class " + typeDescr.getTypeName() + " can't extend class "+ typeDescr.getSuperTypeName()+ ", it should be declared"));
        }
 else {
          if (parent.getNature() == TypeDeclaration.Nature.DECLARATION && kbuilder.getKnowledgeBase() != null) {
            parent=kbuilder.getKnowledgeBase().getPackagesMap().get(typeDescr.getSuperTypeNamespace()).getTypeDeclaration(typeDescr.getSuperTypeName());
          }
        }
      }
    }
    AnnotationDescr annotationDescr=typeDescr.getAnnotation(TypeDeclaration.Role.ID);
    String role=(annotationDescr != null) ? annotationDescr.getSingleValue() : null;
    if (role != null) {
      type.setRole(TypeDeclaration.Role.parseRole(role));
    }
 else     if (parent != null) {
      type.setRole(parent.getRole());
    }
    annotationDescr=typeDescr.getAnnotation(TypeDeclaration.ATTR_TYPESAFE);
    String typesafe=(annotationDescr != null) ? annotationDescr.getSingleValue() : null;
    if (typesafe != null) {
      type.setTypesafe(Boolean.parseBoolean(typesafe));
    }
 else     if (parent != null) {
      type.setTypesafe(parent.isTypesafe());
    }
    annotationDescr=typeDescr.getAnnotation(TypeDeclaration.Format.ID);
    String format=(annotationDescr != null) ? annotationDescr.getSingleValue() : null;
    if (format != null) {
      type.setFormat(TypeDeclaration.Format.parseFormat(format));
    }
    annotationDescr=typeDescr.getAnnotation(TypeDeclaration.Kind.ID);
    String kind=(annotationDescr != null) ? annotationDescr.getSingleValue() : null;
    if (kind != null) {
      type.setKind(TypeDeclaration.Kind.parseKind(kind));
    }
    if (typeDescr instanceof EnumDeclarationDescr) {
      type.setKind(TypeDeclaration.Kind.ENUM);
    }
    annotationDescr=typeDescr.getAnnotation(TypeDeclaration.ATTR_CLASS);
    String className=(annotationDescr != null) ? annotationDescr.getSingleValue() : null;
    if (isEmpty(className)) {
      className=type.getTypeName();
    }
    try {
      if (!kbuilder.hasErrors()) {
        generateDeclaredBean(typeDescr,type,pkgRegistry,unresolvedTypes);
        Class<?> clazz=pkgRegistry.getTypeResolver().resolveType(typeDescr.getType().getFullName());
        type.setTypeClass(clazz);
      }
    }
 catch (    final ClassNotFoundException e) {
      kbuilder.addBuilderResult(new TypeDeclarationError(typeDescr,"Class '" + className + "' not found for type declaration of '"+ type.getTypeName()+ "'"));
      continue;
    }
    if (!processTypeFields(pkgRegistry,typeDescr,type,true)) {
      unresolvedTypes.add(new TypeDefinition(type,typeDescr));
    }
  }
  return unresolvedTypes;
}
