{
  if (typeDescr instanceof TypeDeclarationDescr) {
    TypeDeclarationDescr tDescr=(TypeDeclarationDescr)typeDescr;
    for (    QualifiedName qname : tDescr.getSuperTypes()) {
      if (mergeInheritedFields(tDescr,unresolvedTypes,unprocessableDescrs)) {
        for (        AbstractClassTypeDeclarationDescr descr : sortedTypeDescriptors) {
          if (qname.equals(descr.getType())) {
            typeDescr.getAnnotations().putAll(descr.getAnnotations());
            break;
          }
 else           if (typeDescr.getType().equals(descr.getType())) {
            break;
          }
        }
      }
    }
  }
  if (unprocessableDescrs.containsKey(typeDescr.getType().getFullName())) {
    return;
  }
  TypeDeclaration type=new TypeDeclaration(typeDescr.getTypeName());
  if (typeDescr.getResource() == null) {
    typeDescr.setResource(kbuilder.getCurrentResource());
  }
  type.setResource(typeDescr.getResource());
  TypeDeclaration parent=null;
  if (!typeDescr.getSuperTypes().isEmpty()) {
    PackageRegistry sup=kbuilder.getPackageRegistry(typeDescr.getSuperTypeNamespace());
    if (sup != null) {
      parent=sup.getPackage().getTypeDeclaration(typeDescr.getSuperTypeName());
      if (parent == null) {
        for (        TypeDefinition tdef : unresolvedTypes) {
          if (tdef.getTypeClassName().equals(typeDescr.getSuperTypes().get(0).getFullName())) {
            parent=tdef.type;
          }
        }
      }
      if (parent == null) {
        kbuilder.addBuilderResult(new TypeDeclarationError(typeDescr,"Declared class " + typeDescr.getTypeName() + " can't extend class "+ typeDescr.getSuperTypeName()+ ", it should be declared"));
      }
 else {
        if (parent.getNature() == TypeDeclaration.Nature.DECLARATION && kbuilder.getKnowledgeBase() != null) {
          parent=kbuilder.getKnowledgeBase().getPackagesMap().get(typeDescr.getSuperTypeNamespace()).getTypeDeclaration(typeDescr.getSuperTypeName());
        }
      }
    }
  }
  AnnotationDescr annotationDescr=getSingleAnnotation(typeDescr,TypeDeclaration.Role.ID);
  String role=(annotationDescr != null) ? annotationDescr.getSingleValue() : null;
  if (role != null) {
    type.setRole(TypeDeclaration.Role.parseRole(role));
  }
 else   if (parent != null) {
    type.setRole(parent.getRole());
  }
  annotationDescr=getSingleAnnotation(typeDescr,TypeDeclaration.ATTR_TYPESAFE);
  String typesafe=(annotationDescr != null) ? annotationDescr.getSingleValue() : null;
  if (typesafe != null) {
    type.setTypesafe(Boolean.parseBoolean(typesafe));
  }
 else   if (parent != null && isSet(parent.getSetMask(),TypeDeclaration.TYPESAFE_BIT)) {
    type.setTypesafe(parent.isTypesafe());
  }
  annotationDescr=getSingleAnnotation(typeDescr,TypeDeclaration.Format.ID);
  String format=(annotationDescr != null) ? annotationDescr.getSingleValue() : null;
  if (format != null) {
    type.setFormat(TypeDeclaration.Format.parseFormat(format));
  }
  annotationDescr=getSingleAnnotation(typeDescr,TypeDeclaration.Kind.ID);
  String kind=(annotationDescr != null) ? annotationDescr.getSingleValue() : null;
  if (kind != null) {
    type.setKind(TypeDeclaration.Kind.parseKind(kind));
  }
  if (typeDescr instanceof EnumDeclarationDescr) {
    type.setKind(TypeDeclaration.Kind.ENUM);
  }
  annotationDescr=getSingleAnnotation(typeDescr,TypeDeclaration.ATTR_CLASS);
  String className=(annotationDescr != null) ? annotationDescr.getSingleValue() : null;
  if (isEmpty(className)) {
    className=type.getTypeName();
  }
  try {
    generateDeclaredBean(typeDescr,type,pkgRegistry,unresolvedTypes);
    Class<?> clazz=pkgRegistry.getTypeResolver().resolveType(typeDescr.getType().getFullName());
    type.setTypeClass(clazz);
  }
 catch (  final ClassNotFoundException e) {
    kbuilder.addBuilderResult(new TypeDeclarationError(typeDescr,"Class '" + className + "' not found for type declaration of '"+ type.getTypeName()+ "'"));
    return;
  }
  if (!processTypeFields(pkgRegistry,typeDescr,type,true)) {
    unresolvedTypes.add(new TypeDefinition(type,typeDescr));
  }
}
