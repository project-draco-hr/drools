{
synchronized (this.pkgs) {
    final Package pkg=(Package)this.pkgs.get(packageName);
    if (pkg == null) {
      throw new IllegalArgumentException("Package name '" + packageName + "' does not exist for this Rule Base.");
    }
    boolean doUnlock=false;
    if (!this.lock.isHeldByCurrentThread() && (this.wms == null || this.wms.length == 0)) {
      lock();
      doUnlock=true;
    }
    try {
      this.removalsSinceLock++;
      this.eventSupport.fireBeforePackageRemoved(pkg);
      final Rule[] rules=pkg.getRules();
      for (int i=0; i < rules.length; ++i) {
        removeRule(pkg,rules[i]);
      }
      final Set referencedGlobals=new HashSet();
      for (final Iterator it=this.pkgs.values().iterator(); it.hasNext(); ) {
        final org.drools.rule.Package pkgref=(org.drools.rule.Package)it.next();
        if (pkgref != pkg) {
          referencedGlobals.addAll(pkgref.getGlobals().keySet());
        }
      }
      for (final Iterator it=pkg.getGlobals().keySet().iterator(); it.hasNext(); ) {
        final String globalName=(String)it.next();
        if (!referencedGlobals.contains(globalName)) {
          this.globals.remove(globalName);
        }
      }
      final Map flows=pkg.getRuleFlows();
      for (final Iterator iter=flows.keySet().iterator(); iter.hasNext(); ) {
        removeProcess((String)iter.next());
      }
      this.pkgs.remove(pkg.getName());
      pkg.getDialectRuntimeRegistry().onRemove();
      pkg.clear();
      this.eventSupport.fireAfterPackageRemoved(pkg);
    }
  finally {
      if (doUnlock) {
        unlock();
      }
    }
  }
}
