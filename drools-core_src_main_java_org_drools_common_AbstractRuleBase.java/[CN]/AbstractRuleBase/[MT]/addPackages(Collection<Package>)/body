{
synchronized (this.pkgs) {
    boolean doUnlock=false;
    if (!this.lock.isHeldByCurrentThread() && (this.wms == null || this.wms.length == 0)) {
      lock();
      doUnlock=true;
    }
    try {
      for (      Package newPkg : newPkgs) {
        newPkg.checkValidity();
        this.additionsSinceLock++;
        this.eventSupport.fireBeforePackageAdded(newPkg);
        Package pkg=this.pkgs.get(newPkg.getName());
        if (pkg == null) {
          pkg=new Package(newPkg.getName());
          pkg.setClassFieldAccessorCache(this.classFieldAccessorCache);
          pkgs.put(pkg.getName(),pkg);
        }
        pkg.getDialectRuntimeRegistry().merge(newPkg.getDialectRuntimeRegistry(),this.rootClassLoader);
      }
      for (      Package newPkg : newPkgs) {
        Package pkg=this.pkgs.get(newPkg.getName());
        if (newPkg.getFunctions() != null) {
          for (          Map.Entry<String,Function> entry : newPkg.getFunctions().entrySet()) {
            pkg.addFunction(entry.getValue());
          }
        }
        pkg.getDialectRuntimeRegistry().onBeforeExecute();
        pkg.getClassFieldAccessorStore().merge(newPkg.getClassFieldAccessorStore());
      }
      for (      Package newPkg : newPkgs) {
        Package pkg=this.pkgs.get(newPkg.getName());
        TypeDeclaration lastType=null;
        try {
          if (newPkg.getTypeDeclarations() != null) {
            for (            TypeDeclaration type : newPkg.getTypeDeclarations().values()) {
              lastType=type;
              type.setTypeClass(this.rootClassLoader.loadClass(type.getTypeClassName()));
              if (!this.classTypeDeclaration.containsKey(type.getTypeClass())) {
                this.classTypeDeclaration.put(type.getTypeClass(),type);
              }
            }
          }
        }
 catch (        ClassNotFoundException e) {
          throw new RuntimeDroolsException("unable to resolve Type Declaration class '" + lastType.getTypeName() + "'");
        }
        mergePackage(pkg,newPkg);
        final Rule[] rules=newPkg.getRules();
        for (int i=0; i < rules.length; ++i) {
          addRule(newPkg,rules[i]);
        }
        if (newPkg.getRuleFlows() != null) {
          final Map flows=newPkg.getRuleFlows();
          for (          final Object object : flows.entrySet()) {
            final Entry flow=(Entry)object;
            this.processes.put(flow.getKey(),flow.getValue());
          }
        }
        this.eventSupport.fireAfterPackageAdded(newPkg);
      }
    }
  finally {
      if (doUnlock) {
        unlock();
      }
    }
  }
}
