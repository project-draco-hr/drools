{
  lock();
  try {
    for (    Package newPkg : newPkgs) {
      newPkg.checkValidity();
      this.additionsSinceLock++;
      this.eventSupport.fireBeforePackageAdded(newPkg);
      Package pkg=this.pkgs.get(newPkg.getName());
      if (pkg == null) {
        pkg=new Package(newPkg.getName());
        pkg.setClassFieldAccessorCache(this.classFieldAccessorCache);
        pkgs.put(pkg.getName(),pkg);
      }
      pkg.getDialectRuntimeRegistry().merge(newPkg.getDialectRuntimeRegistry(),this.rootClassLoader);
    }
    for (    Package newPkg : newPkgs) {
      Package pkg=this.pkgs.get(newPkg.getName());
      if (newPkg.getFunctions() != null) {
        for (        Map.Entry<String,Function> entry : newPkg.getFunctions().entrySet()) {
          pkg.addFunction(entry.getValue());
        }
      }
      pkg.getDialectRuntimeRegistry().onBeforeExecute();
      pkg.getClassFieldAccessorStore().merge(newPkg.getClassFieldAccessorStore());
    }
    for (    Package newPkg : newPkgs) {
      Package pkg=this.pkgs.get(newPkg.getName());
      TypeDeclaration lastType=null;
      try {
        if (newPkg.getTypeDeclarations() != null) {
          for (          TypeDeclaration newDecl : newPkg.getTypeDeclarations().values()) {
            lastType=newDecl;
            newDecl.setTypeClass(this.rootClassLoader.loadClass(newDecl.getTypeClassName()));
            TypeDeclaration typeDeclaration=this.classTypeDeclaration.get(newDecl.getTypeClass());
            if (typeDeclaration == null) {
              this.classTypeDeclaration.put(newDecl.getTypeClass(),newDecl);
              typeDeclaration=newDecl;
            }
 else {
              mergeTypeDeclarations(typeDeclaration,newDecl);
            }
            updateDependentTypes(newPkg,typeDeclaration);
          }
        }
      }
 catch (      ClassNotFoundException e) {
        throw new RuntimeDroolsException("unable to resolve Type Declaration class '" + lastType.getTypeName() + "'");
      }
      mergePackage(pkg,newPkg);
      final Rule[] rules=newPkg.getRules();
      for (int i=0; i < rules.length; ++i) {
        addRule(newPkg,rules[i]);
      }
      if (newPkg.getRuleFlows() != null) {
        final Map<String,org.drools.definition.process.Process> flows=newPkg.getRuleFlows();
        for (        org.drools.definition.process.Process process : flows.values()) {
          addProcess((Process)process);
        }
      }
      this.eventSupport.fireAfterPackageAdded(newPkg);
    }
  }
  finally {
    unlock();
  }
}
