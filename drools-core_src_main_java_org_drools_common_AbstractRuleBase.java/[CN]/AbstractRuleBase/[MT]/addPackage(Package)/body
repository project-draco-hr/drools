{
  newPkg.checkValidity();
synchronized (this.pkgs) {
    final Package pkg=(Package)this.pkgs.get(newPkg.getName());
    boolean doUnlock=false;
    if (!this.lock.isHeldByCurrentThread() && (this.wms == null || this.wms.length == 0)) {
      lock();
      doUnlock=true;
    }
    this.additionsSinceLock++;
    this.eventSupport.fireBeforePackageAdded(newPkg);
    if (pkg != null) {
      mergePackage(pkg,newPkg);
    }
 else {
      this.pkgs.put(newPkg.getName(),newPkg);
    }
    final Map newGlobals=newPkg.getGlobals();
    for (final Iterator it=newGlobals.keySet().iterator(); it.hasNext(); ) {
      final String identifier=(String)it.next();
      final Class type=(Class)newGlobals.get(identifier);
      final boolean f=this.globals.containsKey(identifier);
      if (f) {
        final boolean y=!this.globals.get(identifier).equals(type);
        if (f && y) {
          throw new PackageIntegrationException(pkg);
        }
      }
    }
    this.globals.putAll(newGlobals);
    for (    TypeDeclaration type : newPkg.getTypeDeclarations().values()) {
      if (!this.classTypeDeclaration.containsKey(type.getTypeClass())) {
        this.classTypeDeclaration.put(type.getTypeClass(),type);
      }
    }
    final Rule[] rules=newPkg.getRules();
    for (int i=0; i < rules.length; ++i) {
      addRule(newPkg,rules[i]);
    }
    if (newPkg.getRuleFlows() != Collections.EMPTY_MAP) {
      final Map flows=newPkg.getRuleFlows();
      for (final Iterator iter=flows.entrySet().iterator(); iter.hasNext(); ) {
        final Entry flow=(Entry)iter.next();
        this.processes.put(flow.getKey(),flow.getValue());
      }
    }
    this.packageClassLoader.addClassLoader(newPkg.getDialectDatas().getClassLoader());
    this.eventSupport.fireAfterPackageAdded(newPkg);
    if (doUnlock) {
      unlock();
    }
  }
}
