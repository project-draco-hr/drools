{
  newPkg.checkValidity();
synchronized (this.pkgs) {
    Package pkg=this.pkgs.get(newPkg.getName());
    boolean doUnlock=false;
    if (!this.lock.isHeldByCurrentThread() && (this.wms == null || this.wms.length == 0)) {
      lock();
      doUnlock=true;
    }
    this.additionsSinceLock++;
    this.eventSupport.fireBeforePackageAdded(newPkg);
    if (pkg == null) {
      pkg=new Package(newPkg.getName());
      pkg.setClassFieldAccessorCache(this.classFieldAccessorCache);
      pkgs.put(pkg.getName(),pkg);
    }
    pkg.getDialectRuntimeRegistry().merge(newPkg.getDialectRuntimeRegistry(),this.rootClassLoader);
    if (newPkg.getFunctions() != null) {
      for (      Map.Entry<String,Function> entry : newPkg.getFunctions().entrySet()) {
        pkg.addFunction(entry.getValue());
      }
    }
    pkg.getClassFieldAccessorStore().merge(newPkg.getClassFieldAccessorStore());
    pkg.getDialectRuntimeRegistry().onBeforeExecute();
    TypeDeclaration lastType=null;
    try {
      if (newPkg.getTypeDeclarations() != null) {
        for (        TypeDeclaration type : newPkg.getTypeDeclarations().values()) {
          lastType=type;
          type.setTypeClass(this.rootClassLoader.loadClass(pkg.getName() + "." + type.getTypeName()));
          if (!this.classTypeDeclaration.containsKey(type.getTypeClass())) {
            this.classTypeDeclaration.put(type.getTypeClass(),type);
          }
        }
      }
    }
 catch (    ClassNotFoundException e) {
      throw new RuntimeDroolsException("unable to resolve Type Declaration class '" + lastType.getTypeName() + "'");
    }
    mergePackage(pkg,newPkg);
    final Rule[] rules=newPkg.getRules();
    for (int i=0; i < rules.length; ++i) {
      addRule(newPkg,rules[i]);
    }
    if (newPkg.getRuleFlows() != null) {
      final Map flows=newPkg.getRuleFlows();
      for (      final Object object : newPkg.getRuleFlows().entrySet()) {
        final Entry flow=(Entry)object;
        this.processes.put(flow.getKey(),flow.getValue());
      }
    }
    this.eventSupport.fireAfterPackageAdded(newPkg);
    if (doUnlock) {
      unlock();
    }
  }
}
