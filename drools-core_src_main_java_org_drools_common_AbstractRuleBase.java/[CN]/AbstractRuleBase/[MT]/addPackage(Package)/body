{
  newPkg.checkValidity();
synchronized (this.pkgs) {
    Package pkg=this.pkgs.get(newPkg.getName());
    boolean doUnlock=false;
    if (!this.lock.isHeldByCurrentThread() && (this.wms == null || this.wms.length == 0)) {
      lock();
      doUnlock=true;
    }
    this.additionsSinceLock++;
    this.eventSupport.fireBeforePackageAdded(newPkg);
    if (pkg == null) {
      pkg=new Package(newPkg.getName(),newPkg.getDialectDatas().getParentClassLoader());
      pkgs.put(pkg.getName(),pkg);
      this.packageClassLoader.addClassLoader(pkg.getDialectDatas().getClassLoader());
    }
 else {
      this.packageClassLoader.addClassLoader(newPkg.getDialectDatas().getClassLoader());
    }
    final Map<String,Class> newGlobals=newPkg.getGlobals();
    if (newGlobals != null) {
      for (      final Map.Entry<String,Class> entry : newGlobals.entrySet()) {
        final String identifier=entry.getKey();
        final Class type=entry.getValue();
        if (this.globals.containsKey(identifier) && !this.globals.get(identifier).equals(type)) {
          throw new PackageIntegrationException(pkg);
        }
 else {
          this.globals.put(identifier,type);
        }
      }
    }
    mergePackage(pkg,newPkg);
    if (newPkg.getTypeDeclarations() != null) {
      for (      TypeDeclaration type : newPkg.getTypeDeclarations().values()) {
        if (!this.classTypeDeclaration.containsKey(type.getTypeClass())) {
          this.classTypeDeclaration.put(type.getTypeClass(),type);
        }
      }
    }
    final Rule[] rules=newPkg.getRules();
    for (int i=0; i < rules.length; ++i) {
      addRule(newPkg,rules[i]);
    }
    if (newPkg.getRuleFlows() != null) {
      final Map flows=newPkg.getRuleFlows();
      for (      final Object object : newPkg.getRuleFlows().entrySet()) {
        final Entry flow=(Entry)object;
        this.processes.put(flow.getKey(),flow.getValue());
      }
    }
    this.eventSupport.fireAfterPackageAdded(newPkg);
    if (doUnlock) {
      unlock();
    }
  }
}
