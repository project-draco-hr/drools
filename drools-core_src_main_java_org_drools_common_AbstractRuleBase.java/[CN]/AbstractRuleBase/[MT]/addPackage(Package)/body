{
  newPkg.checkValidity();
synchronized (this.pkgs) {
    Package pkg=this.pkgs.get(newPkg.getName());
    boolean doUnlock=false;
    if (!this.lock.isHeldByCurrentThread() && (this.wms == null || this.wms.length == 0)) {
      lock();
      doUnlock=true;
    }
    this.additionsSinceLock++;
    this.eventSupport.fireBeforePackageAdded(newPkg);
    if (pkg == null) {
      pkg=new Package(newPkg.getName(),newPkg.getPackageScopeClassLoader());
      pkgs.put(pkg.getName(),pkg);
      this.packageClassLoader.addClassLoader(pkg.getDialectRuntimeRegistry().getClassLoader());
    }
 else {
      pkg.getPackageScopeClassLoader().getStore().putAll(newPkg.getPackageScopeClassLoader().getStore());
      this.packageClassLoader.addClassLoader(newPkg.getDialectRuntimeRegistry().getClassLoader());
    }
    mergePackage(pkg,newPkg);
    if (newPkg.getTypeDeclarations() != null) {
      for (      TypeDeclaration type : newPkg.getTypeDeclarations().values()) {
        if (!this.classTypeDeclaration.containsKey(type.getTypeClass())) {
          this.classTypeDeclaration.put(type.getTypeClass(),type);
        }
      }
    }
    final Rule[] rules=newPkg.getRules();
    for (int i=0; i < rules.length; ++i) {
      addRule(newPkg,rules[i]);
    }
    if (newPkg.getRuleFlows() != null) {
      final Map flows=newPkg.getRuleFlows();
      for (      final Object object : newPkg.getRuleFlows().entrySet()) {
        final Entry flow=(Entry)object;
        this.processes.put(flow.getKey(),flow.getValue());
      }
    }
    this.eventSupport.fireAfterPackageAdded(newPkg);
    if (doUnlock) {
      unlock();
    }
  }
}
