{
  final Map globals=pkg.getGlobals();
  final Map<String,ImportDeclaration> imports=pkg.getImports();
  imports.putAll(newPkg.getImports());
  for (final Iterator it=newPkg.getGlobals().keySet().iterator(); it.hasNext(); ) {
    final String identifier=(String)it.next();
    final Class type=(Class)globals.get(identifier);
    if (globals.containsKey(identifier) && !globals.get(identifier).equals(type)) {
      throw new PackageIntegrationException("Unable to merge new Package",newPkg);
    }
  }
  globals.putAll(newPkg.getGlobals());
  for (  TypeDeclaration type : newPkg.getTypeDeclarations().values()) {
    if (!this.classTypeDeclaration.containsKey(type.getTypeClass())) {
      this.classTypeDeclaration.put(type.getTypeClass(),type);
    }
    if (!pkg.getTypeDeclarations().containsKey(type.getTypeName())) {
      pkg.addTypeDeclaration(type);
    }
  }
  final Rule[] newRules=newPkg.getRules();
  for (int i=0; i < newRules.length; i++) {
    final Rule newRule=newRules[i];
    if (pkg.getRule(newRule.getName()) != null) {
      removeRule(pkg,pkg.getRule(newRule.getName()));
    }
    pkg.addRule(newRule);
  }
  if (newPkg.getRuleFlows() != Collections.EMPTY_MAP) {
    final Map flows=newPkg.getRuleFlows();
    for (final Iterator iter=flows.values().iterator(); iter.hasNext(); ) {
      final Process flow=(Process)iter.next();
      pkg.addRuleFlow(flow);
    }
  }
  pkg.getDialectDatas().merge(newPkg.getDialectDatas());
  if (this.reloadPackageCompilationData == null) {
    this.reloadPackageCompilationData=new ReloadPackageCompilationData();
  }
  this.reloadPackageCompilationData.addDialectDatas(pkg.getDialectDatas());
}
