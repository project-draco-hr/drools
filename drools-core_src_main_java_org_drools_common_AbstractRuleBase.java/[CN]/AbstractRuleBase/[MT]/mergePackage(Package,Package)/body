{
  final Map<String,ImportDeclaration> imports=pkg.getImports();
  imports.putAll(newPkg.getImports());
  if (newPkg.getGlobals() != null) {
    final Map globals=pkg.getGlobals();
    if (globals == Collections.EMPTY_MAP) {
      for (      Object object : newPkg.getGlobals().entrySet()) {
        Map.Entry entry=(Map.Entry)object;
        pkg.addGlobal((String)entry.getKey(),(Class)entry.getValue());
      }
    }
 else {
      globals.putAll(newPkg.getGlobals());
    }
  }
  if (newPkg.getTypeDeclarations() != null) {
    for (    TypeDeclaration type : newPkg.getTypeDeclarations().values()) {
      if (!this.classTypeDeclaration.containsKey(type.getTypeClass())) {
        this.classTypeDeclaration.put(type.getTypeClass(),type);
      }
      if (!pkg.getTypeDeclarations().containsKey(type.getTypeName())) {
        pkg.addTypeDeclaration(type);
      }
    }
  }
  final Rule[] newRules=newPkg.getRules();
  for (int i=0; i < newRules.length; i++) {
    final Rule newRule=newRules[i];
    if (pkg.getRule(newRule.getName()) != null) {
      removeRule(pkg,pkg.getRule(newRule.getName()));
    }
    pkg.addRule(newRule);
  }
  if (newPkg.getRuleFlows() != null) {
    final Map flows=newPkg.getRuleFlows();
    for (final Iterator iter=flows.values().iterator(); iter.hasNext(); ) {
      final Process flow=(Process)iter.next();
      pkg.addRuleFlow(flow);
    }
  }
  pkg.getDialectDatas().merge(newPkg.getDialectDatas());
  if (newPkg.getFunctions() != null) {
    for (    Map.Entry<String,Function> entry : newPkg.getFunctions().entrySet()) {
      pkg.addFunction(entry.getValue());
    }
  }
  if (this.reloadPackageCompilationData == null) {
    this.reloadPackageCompilationData=new ReloadPackageCompilationData();
  }
  this.reloadPackageCompilationData.addDialectDatas(pkg.getDialectDatas());
}
