{
  final Map<String,ImportDeclaration> imports=pkg.getImports();
  imports.putAll(newPkg.getImports());
  if (newPkg.getGlobals() != null && newPkg.getGlobals() != Collections.EMPTY_MAP) {
    Map<String,Class> globals=pkg.getGlobals();
    for (    final Map.Entry<String,Class> entry : newPkg.getGlobals().entrySet()) {
      final String identifier=entry.getKey();
      final Class type=entry.getValue();
      if (globals.containsKey(identifier) && !globals.get(identifier).equals(type)) {
        throw new PackageIntegrationException(pkg);
      }
 else {
        pkg.addGlobal(identifier,type);
        this.globals.put(identifier,type);
      }
    }
  }
  if (newPkg.getTypeDeclarations() != null) {
    for (    TypeDeclaration type : newPkg.getTypeDeclarations().values()) {
      if (!pkg.getTypeDeclarations().containsKey(type.getTypeName())) {
        pkg.addTypeDeclaration(type);
      }
    }
  }
  pkg.getPackageScopeClassLoader().getStore().putAll(newPkg.getPackageScopeClassLoader().getStore());
  final Rule[] newRules=newPkg.getRules();
  for (int i=0; i < newRules.length; i++) {
    final Rule newRule=newRules[i];
    if (pkg.getRule(newRule.getName()) != null) {
      removeRule(pkg,pkg.getRule(newRule.getName()));
    }
    pkg.addRule(newRule);
  }
  if (newPkg.getRuleFlows() != null) {
    final Map flows=newPkg.getRuleFlows();
    for (final Iterator iter=flows.values().iterator(); iter.hasNext(); ) {
      final Process flow=(Process)iter.next();
      pkg.addProcess(flow);
    }
  }
  pkg.getDialectRuntimeRegistry().merge(newPkg.getDialectRuntimeRegistry());
  if (newPkg.getFunctions() != null) {
    for (    Map.Entry<String,Function> entry : newPkg.getFunctions().entrySet()) {
      pkg.addFunction(entry.getValue());
    }
  }
  if (this.reloadPackageCompilationData == null) {
    this.reloadPackageCompilationData=new ReloadPackageCompilationData();
  }
  this.reloadPackageCompilationData.addDialectDatas(pkg.getDialectRuntimeRegistry());
}
