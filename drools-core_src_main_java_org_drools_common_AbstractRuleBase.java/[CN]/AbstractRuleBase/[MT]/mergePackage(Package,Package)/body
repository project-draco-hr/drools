{
  final Map globals=pkg.getGlobals();
  final Set imports=pkg.getImports();
  final PackageCompilationData compilationData=pkg.getPackageCompilationData();
  final PackageCompilationData newCompilationData=newPkg.getPackageCompilationData();
  final String[] files=newCompilationData.list();
  for (int i=0, length=files.length; i < length; i++) {
    compilationData.write(files[i],newCompilationData.read(files[i]));
  }
  imports.addAll(newPkg.getImports());
  compilationData.putAllInvokers(newCompilationData.getInvokers());
  if (compilationData.isDirty()) {
    if (this.reloadPackageCompilationData == null) {
      this.reloadPackageCompilationData=new ReloadPackageCompilationData();
    }
    this.reloadPackageCompilationData.addPackageCompilationData(compilationData);
  }
  for (final Iterator it=newPkg.getGlobals().keySet().iterator(); it.hasNext(); ) {
    final String identifier=(String)it.next();
    final Class type=(Class)globals.get(identifier);
    if (globals.containsKey(identifier) && !globals.get(identifier).equals(type)) {
      throw new PackageIntegrationException("Unable to merge new Package",newPkg);
    }
  }
  globals.putAll(newPkg.getGlobals());
  final Rule[] newRules=newPkg.getRules();
  for (int i=0; i < newRules.length; i++) {
    final Rule newRule=newRules[i];
    if (pkg.getRule(newRule.getName()) == null) {
      pkg.addRule(newRule);
    }
  }
  if (newPkg.getRuleFlows() != Collections.EMPTY_MAP) {
    Map flows=newPkg.getRuleFlows();
    for (Iterator iter=flows.values().iterator(); iter.hasNext(); ) {
      Process flow=(Process)iter.next();
      pkg.addRuleFlow(flow);
    }
  }
}
