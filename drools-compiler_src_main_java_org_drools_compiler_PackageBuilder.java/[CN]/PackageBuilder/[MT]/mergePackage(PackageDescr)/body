{
  PackageRegistry pkgRegistry=this.pkgRegistryMap.get(packageDescr.getNamespace());
  for (  final ImportDescr importEntry : packageDescr.getImports()) {
    pkgRegistry.addImport(importEntry.getTarget());
  }
  processEntryPointDeclarations(packageDescr);
  processTypeDeclarations(packageDescr);
  for (  FunctionDescr function : packageDescr.getFunctions()) {
    Function existingFunc=pkgRegistry.getPackage().getFunctions().get(function.getName());
    if (existingFunc != null && function.getNamespace().equals(existingFunc.getNamespace())) {
      this.results.add(new DuplicateFunction(function,this.configuration));
    }
  }
  for (  final FunctionImportDescr functionImport : packageDescr.getFunctionImports()) {
    String importEntry=functionImport.getTarget();
    pkgRegistry.addStaticImport(importEntry);
    pkgRegistry.getPackage().addStaticImport(importEntry);
  }
  for (  final GlobalDescr global : packageDescr.getGlobals()) {
    final String identifier=global.getIdentifier();
    String className=global.getType();
    while (className.indexOf('<') >= 0) {
      className=className.replaceAll("<[^<>]+?>","");
    }
    Class<?> clazz;
    try {
      clazz=pkgRegistry.getTypeResolver().resolveType(className);
      pkgRegistry.getPackage().addGlobal(identifier,clazz);
      this.globals.put(identifier,clazz);
    }
 catch (    final ClassNotFoundException e) {
      this.results.add(new GlobalError(identifier,global.getLine()));
      e.printStackTrace();
    }
  }
  this.pkgRegistryMap.remove(packageDescr.getName());
  this.pkgRegistryMap.put(packageDescr.getName(),pkgRegistry);
}
