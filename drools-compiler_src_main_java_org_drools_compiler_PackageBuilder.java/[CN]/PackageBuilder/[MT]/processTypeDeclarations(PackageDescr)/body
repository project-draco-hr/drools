{
  PackageRegistry defaultRegistry=this.pkgRegistryMap.get(packageDescr.getNamespace());
  PackageRegistry pkgRegistry=null;
  for (  TypeDeclarationDescr typeDescr : packageDescr.getTypeDeclarations()) {
    if (isEmpty(typeDescr.getNamespace())) {
      for (      ImportDescr id : packageDescr.getImports()) {
        String imp=id.getTarget();
        int separator=imp.lastIndexOf('.');
        String tail=imp.substring(separator + 1);
        if (tail.equals(typeDescr.getTypeName())) {
          typeDescr.setNamespace(imp.substring(0,separator));
        }
      }
    }
    String qName=typeDescr.getType().getFullName();
    int dotPos=qName.lastIndexOf('.');
    if (dotPos >= 0) {
      Class cls=null;
      try {
        cls=Class.forName(typeDescr.getTypeName(),true,this.rootClassLoader);
      }
 catch (      ClassNotFoundException e) {
      }
      String qualifiedClass=qName;
      int lastIndex;
      while (cls == null && (lastIndex=qualifiedClass.lastIndexOf('.')) != -1) {
        try {
          qualifiedClass=qualifiedClass.substring(0,lastIndex) + "$" + qualifiedClass.substring(lastIndex + 1);
          cls=Class.forName(qualifiedClass,true,this.rootClassLoader);
        }
 catch (        final ClassNotFoundException e) {
          cls=null;
        }
      }
      if (cls != null) {
        String str=ClassUtils.getPackage(cls);
        typeDescr.setNamespace(str);
        dotPos=cls.getName().lastIndexOf('.');
        typeDescr.setTypeName(cls.getName().substring(dotPos + 1));
      }
 else {
        typeDescr.setNamespace(qName.substring(0,dotPos));
        typeDescr.setTypeName(qName.substring(dotPos + 1));
      }
    }
    if (isEmpty(typeDescr.getNamespace()) && typeDescr.getFields().isEmpty()) {
      PackageRegistry pkgReg=this.pkgRegistryMap.get(packageDescr.getName());
      if (pkgReg != null) {
        try {
          Class<?> clz=pkgReg.getTypeResolver().resolveType(typeDescr.getTypeName());
          java.lang.Package pkg=clz.getPackage();
          if (pkg != null) {
            typeDescr.setNamespace(pkg.getName());
            int index=typeDescr.getNamespace() != null && typeDescr.getNamespace().length() > 0 ? typeDescr.getNamespace().length() + 1 : 0;
            typeDescr.setTypeName(clz.getCanonicalName().substring(index));
          }
        }
 catch (        Exception e) {
        }
      }
    }
    if (isEmpty(typeDescr.getNamespace())) {
      typeDescr.setNamespace(packageDescr.getNamespace());
    }
    fillSuperType(typeDescr,packageDescr);
    fillFieldTypes(typeDescr,packageDescr);
    if (!typeDescr.getNamespace().equals(packageDescr.getNamespace())) {
      PackageDescr altDescr=new PackageDescr(typeDescr.getNamespace());
      altDescr.addTypeDeclaration(typeDescr);
      for (      ImportDescr imp : packageDescr.getImports()) {
        altDescr.addImport(imp);
      }
      if (getPackageRegistry().containsKey(altDescr.getNamespace())) {
        mergePackage(altDescr);
      }
 else {
        newPackage(altDescr);
      }
    }
  }
  Collection<TypeDeclarationDescr> sortedTypeDescriptors=sortByHierarchy(packageDescr.getTypeDeclarations());
  for (  TypeDeclarationDescr typeDescr : sortedTypeDescriptors) {
    if (!typeDescr.getNamespace().equals(packageDescr.getNamespace())) {
      continue;
    }
    pkgRegistry=this.pkgRegistryMap.get(packageDescr.getNamespace());
    for (    TypeDeclarationDescr.QualifiedName qname : typeDescr.getSuperTypes()) {
      if (mergeInheritedFields(typeDescr)) {
        Iterator<TypeDeclarationDescr> iter=sortedTypeDescriptors.iterator();
        while (iter.hasNext()) {
          TypeDeclarationDescr descr=iter.next();
          if (qname.equals(descr.getType())) {
            typeDescr.getAnnotations().putAll(descr.getAnnotations());
            break;
          }
 else           if (typeDescr.getType().equals(descr.getType())) {
            break;
          }
        }
      }
    }
    TypeDeclaration type=new TypeDeclaration(typeDescr.getTypeName());
    if (resource != null) {
      type.setResource(this.resource);
    }
    AnnotationDescr annotationDescr=typeDescr.getAnnotation(TypeDeclaration.Role.ID);
    String role=(annotationDescr != null) ? annotationDescr.getSingleValue() : null;
    if (role != null) {
      type.setRole(TypeDeclaration.Role.parseRole(role));
    }
    annotationDescr=typeDescr.getAnnotation(TypeDeclaration.ATTR_TYPESAFE);
    String typesafe=(annotationDescr != null) ? annotationDescr.getSingleValue() : null;
    if (typesafe != null) {
      type.setTypesafe(Boolean.parseBoolean(typesafe));
    }
    annotationDescr=typeDescr.getAnnotation(TypeDeclaration.Format.ID);
    String format=(annotationDescr != null) ? annotationDescr.getSingleValue() : null;
    if (format != null) {
      type.setFormat(TypeDeclaration.Format.parseFormat(format));
    }
    annotationDescr=typeDescr.getAnnotation(TypeDeclaration.ATTR_CLASS);
    String className=(annotationDescr != null) ? annotationDescr.getSingleValue() : null;
    if (StringUtils.isEmpty(className)) {
      className=type.getTypeName();
    }
    Class clazz;
    try {
      generateDeclaredBean(typeDescr,type,pkgRegistry);
      clazz=pkgRegistry.getTypeResolver().resolveType(typeDescr.getType().getFullName());
      type.setTypeClass(clazz);
      if (type.getTypeClassDef() != null) {
        try {
          buildFieldAccessors(type,pkgRegistry);
        }
 catch (        Exception e) {
          this.results.add(new TypeDeclarationError("Error creating field accessors for TypeDeclaration '" + className + "' for type '"+ type.getTypeName()+ "'",typeDescr.getLine()));
          continue;
        }
      }
    }
 catch (    final ClassNotFoundException e) {
      this.results.add(new TypeDeclarationError("Class '" + className + "' not found for type declaration of '"+ type.getTypeName()+ "'",typeDescr.getLine()));
      continue;
    }
    annotationDescr=typeDescr.getAnnotation(TypeDeclaration.ATTR_TIMESTAMP);
    String timestamp=(annotationDescr != null) ? annotationDescr.getSingleValue() : null;
    if (timestamp != null) {
      type.setTimestampAttribute(timestamp);
      ClassDefinition cd=type.getTypeClassDef();
      Package pkg=pkgRegistry.getPackage();
      InternalReadAccessor reader=pkg.getClassFieldAccessorStore().getMVELReader(ClassUtils.getPackage(type.getTypeClass()),type.getTypeClass().getName(),timestamp,type.isTypesafe());
      MVELDialectRuntimeData data=(MVELDialectRuntimeData)pkg.getDialectRuntimeRegistry().getDialectData("mvel");
      data.addCompileable((MVELCompileable)reader);
      ((MVELCompileable)reader).compile(data);
      type.setTimestampExtractor(reader);
    }
    annotationDescr=typeDescr.getAnnotation(TypeDeclaration.ATTR_DURATION);
    String duration=(annotationDescr != null) ? annotationDescr.getSingleValue() : null;
    if (duration != null) {
      type.setDurationAttribute(duration);
      ClassDefinition cd=type.getTypeClassDef();
      Package pkg=pkgRegistry.getPackage();
      InternalReadAccessor reader=pkg.getClassFieldAccessorStore().getMVELReader(ClassUtils.getPackage(type.getTypeClass()),type.getTypeClass().getName(),duration,type.isTypesafe());
      MVELDialectRuntimeData data=(MVELDialectRuntimeData)pkg.getDialectRuntimeRegistry().getDialectData("mvel");
      data.addCompileable((MVELCompileable)reader);
      ((MVELCompileable)reader).compile(data);
      type.setDurationExtractor(reader);
    }
    annotationDescr=typeDescr.getAnnotation(TypeDeclaration.ATTR_EXPIRE);
    String expiration=(annotationDescr != null) ? annotationDescr.getSingleValue() : null;
    if (expiration != null) {
      if (timeParser == null) {
        timeParser=new TimeIntervalParser();
      }
      type.setExpirationOffset(timeParser.parse(expiration)[0].longValue());
    }
    boolean dynamic=typeDescr.getAnnotationNames().contains(TypeDeclaration.ATTR_PROP_CHANGE_SUPPORT);
    type.setDynamic(dynamic);
    pkgRegistry.getPackage().addTypeDeclaration(type);
  }
}
