{
  ClassBuilder cb=new ClassBuilder();
  String fullName=typeDescr.getNamespace() + "." + typeDescr.getTypeName();
  String superType=typeDescr.getSuperTypeName() == null ? Object.class.getName() : typeDescr.getSuperTypeName();
  String[] interfaces=new String[1 + typeDescr.getInterfaceNames().size()];
  int j=0;
  Iterator<String> intfIter=typeDescr.getInterfaceNames().iterator();
  while (intfIter.hasNext())   interfaces[j++]=intfIter.next();
  interfaces[typeDescr.getInterfaceNames().size()]=Serializable.class.getName();
  ClassDefinition def=new ClassDefinition(fullName,superType,interfaces);
  Map<String,TypeFieldDescr> flds=typeDescr.getFields();
  try {
    PriorityQueue<TypeFieldDescr> queue=new PriorityQueue<TypeFieldDescr>();
    for (    TypeFieldDescr field : flds.values()) {
      String idx=field.getMetaAttribute(TypeDeclaration.ATTR_FIELD_POSITION);
      if (idx != null) {
        field.setIndex(Integer.valueOf(idx));
      }
      queue.add(field);
    }
    TypeFieldDescr field=queue.poll();
    while (field != null) {
      String fullFieldType=pkgRegistry.getTypeResolver().resolveType(field.getPattern().getObjectType()).getName();
      FieldDefinition fieldDef=new FieldDefinition(field.getFieldName(),fullFieldType);
      boolean isKey=field.getMetaAttributes().containsKey("key");
      fieldDef.setKey(isKey);
      def.addField(fieldDef);
      field=queue.poll();
    }
    byte[] d=cb.buildClass(def);
    JavaDialectRuntimeData dialect=(JavaDialectRuntimeData)pkgRegistry.getDialectRuntimeRegistry().getDialectData("java");
    dialect.write(JavaDialectRuntimeData.convertClassToResourcePath(fullName),d);
    type.setTypeClassDef(def);
  }
 catch (  Exception e) {
    e.printStackTrace();
    this.results.add(new TypeDeclarationError("Unable to create a class for declared type " + fullName + ": "+ e.getMessage()+ ";",typeDescr.getLine()));
  }
}
