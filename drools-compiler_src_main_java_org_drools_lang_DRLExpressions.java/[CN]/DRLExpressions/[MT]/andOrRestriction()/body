{
  BaseDescr result=null;
  Token lop=null;
  DRLExpressions.equalityExpression_return left=null;
  DRLExpressions.operator_return op=null;
  DRLExpressions.shiftExpression_return right=null;
  try {
{
      pushFollow(FOLLOW_equalityExpression_in_andOrRestriction815);
      left=equalityExpression();
      state._fsp--;
      if (state.failed)       return result;
      if (state.backtracking == 0) {
        if (buildDescr && state.backtracking == 0) {
          result=(left != null ? left.result : null);
        }
      }
      loop21:       do {
        int alt21=2;
        alt21=dfa21.predict(input);
switch (alt21) {
case 1:
{
            int alt20=2;
            int LA20_0=input.LA(1);
            if ((LA20_0 == DOUBLE_PIPE)) {
              alt20=1;
            }
 else             if ((LA20_0 == DOUBLE_AMPER)) {
              alt20=2;
            }
 else {
              if (state.backtracking > 0) {
                state.failed=true;
                return result;
              }
              NoViableAltException nvae=new NoViableAltException("",20,0,input);
              throw nvae;
            }
switch (alt20) {
case 1:
{
                lop=(Token)match(input,DOUBLE_PIPE,FOLLOW_DOUBLE_PIPE_in_andOrRestriction836);
                if (state.failed)                 return result;
              }
            break;
case 2:
{
            lop=(Token)match(input,DOUBLE_AMPER,FOLLOW_DOUBLE_AMPER_in_andOrRestriction840);
            if (state.failed)             return result;
          }
        break;
    }
    pushFollow(FOLLOW_operator_in_andOrRestriction845);
    op=operator();
    state._fsp--;
    if (state.failed)     return result;
    pushFollow(FOLLOW_shiftExpression_in_andOrRestriction849);
    right=shiftExpression();
    state._fsp--;
    if (state.failed)     return result;
    if (state.backtracking == 0) {
      if (buildDescr && state.backtracking == 0) {
        ConstraintConnectiveDescr descr=(lop != null ? lop.getText() : null).equals("||") ? ConstraintConnectiveDescr.newOr() : ConstraintConnectiveDescr.newAnd();
        descr.addOrMerge(result);
        RelationalExprDescr re=new RelationalExprDescr((op != null ? input.toString(op.start,op.stop) : null),new AtomicExprDescr((left != null ? input.toString(left.start,left.stop) : null)),new AtomicExprDescr((right != null ? input.toString(right.start,right.stop) : null)));
        descr.addOrMerge(re);
        result=descr;
      }
    }
  }
break;
default :
break loop21;
}
}
 while (true);
int alt22=2;
int LA22_0=input.LA(1);
if ((LA22_0 == EOF)) {
int LA22_1=input.LA(2);
if (((LA22_1 >= AT && LA22_1 <= MOD_ASSIGN) || (LA22_1 >= SEMICOLON && LA22_1 <= COLON) || (LA22_1 >= GREATER && LA22_1 <= EQUALS_ASSIGN)|| LA22_1 == RIGHT_PAREN || LA22_1 == RIGHT_SQUARE || (LA22_1 >= RIGHT_CURLY && LA22_1 <= COMMA) || (LA22_1 >= DOUBLE_AMPER && LA22_1 <= QUESTION) || (LA22_1 >= PIPE && LA22_1 <= XOR) || LA22_1 == ID)) {
alt22=1;
}
 else if ((LA22_1 == EOF)) {
int LA22_4=input.LA(3);
if ((LA22_4 == EOF)) {
alt22=1;
}
}
}
switch (alt22) {
case 1:
{
match(input,EOF,FOLLOW_EOF_in_andOrRestriction868);
if (state.failed) return result;
}
break;
}
}
}
 catch (RecognitionException re) {
throw re;
}
 finally {
}
return result;
}
