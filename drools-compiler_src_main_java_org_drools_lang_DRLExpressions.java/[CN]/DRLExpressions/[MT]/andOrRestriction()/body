{
  BaseDescr result=null;
  Token lop=null;
  DRLExpressions.equalityExpression_return left=null;
  DRLExpressions.operator_return op=null;
  DRLExpressions.shiftExpression_return right=null;
  try {
{
      pushFollow(FOLLOW_equalityExpression_in_andOrRestriction794);
      left=equalityExpression();
      state._fsp--;
      if (state.failed)       return result;
      if (state.backtracking == 0) {
        if (buildDescr && state.backtracking == 0) {
          result=(left != null ? left.result : null);
        }
      }
      loop21:       do {
        int alt21=2;
        alt21=dfa21.predict(input);
switch (alt21) {
case 1:
{
            int alt20=2;
            int LA20_0=input.LA(1);
            if ((LA20_0 == DOUBLE_PIPE)) {
              alt20=1;
            }
 else             if ((LA20_0 == DOUBLE_AMPER)) {
              alt20=2;
            }
 else {
              if (state.backtracking > 0) {
                state.failed=true;
                return result;
              }
              NoViableAltException nvae=new NoViableAltException("",20,0,input);
              throw nvae;
            }
switch (alt20) {
case 1:
{
                lop=(Token)match(input,DOUBLE_PIPE,FOLLOW_DOUBLE_PIPE_in_andOrRestriction815);
                if (state.failed)                 return result;
              }
            break;
case 2:
{
            lop=(Token)match(input,DOUBLE_AMPER,FOLLOW_DOUBLE_AMPER_in_andOrRestriction819);
            if (state.failed)             return result;
          }
        break;
    }
    pushFollow(FOLLOW_operator_in_andOrRestriction824);
    op=operator();
    state._fsp--;
    if (state.failed)     return result;
    pushFollow(FOLLOW_shiftExpression_in_andOrRestriction828);
    right=shiftExpression();
    state._fsp--;
    if (state.failed)     return result;
    if (state.backtracking == 0) {
      if (buildDescr && state.backtracking == 0) {
        ConstraintConnectiveDescr descr=(lop != null ? lop.getText() : null).equals("||") ? ConstraintConnectiveDescr.newOr() : ConstraintConnectiveDescr.newAnd();
        descr.addOrMerge(result);
        RelationalExprDescr re=new RelationalExprDescr((op != null ? input.toString(op.start,op.stop) : null),new AtomicExprDescr((left != null ? input.toString(left.start,left.stop) : null)),new AtomicExprDescr((right != null ? input.toString(right.start,right.stop) : null)));
        descr.addOrMerge(re);
        result=descr;
      }
    }
  }
break;
default :
break loop21;
}
}
 while (true);
}
}
 catch (RecognitionException re) {
throw re;
}
 finally {
}
return result;
}
