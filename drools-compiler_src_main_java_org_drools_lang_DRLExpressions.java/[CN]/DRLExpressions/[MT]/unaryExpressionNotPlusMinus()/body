{
  DRLExpressions.unaryExpressionNotPlusMinus_return retval=new DRLExpressions.unaryExpressionNotPlusMinus_return();
  retval.start=input.LT(1);
  Token var=null;
  BaseDescr left=null;
  boolean isLeft=false;
  BindingDescr bind=null;
  try {
    int alt43=4;
    alt43=dfa43.predict(input);
switch (alt43) {
case 1:
{
        match(input,TILDE,FOLLOW_TILDE_in_unaryExpressionNotPlusMinus2012);
        if (state.failed)         return retval;
        pushFollow(FOLLOW_unaryExpression_in_unaryExpressionNotPlusMinus2014);
        unaryExpression();
        state._fsp--;
        if (state.failed)         return retval;
      }
    break;
case 2:
{
    match(input,NEGATION,FOLLOW_NEGATION_in_unaryExpressionNotPlusMinus2023);
    if (state.failed)     return retval;
    pushFollow(FOLLOW_unaryExpression_in_unaryExpressionNotPlusMinus2025);
    unaryExpression();
    state._fsp--;
    if (state.failed)     return retval;
  }
break;
case 3:
{
pushFollow(FOLLOW_castExpression_in_unaryExpressionNotPlusMinus2039);
castExpression();
state._fsp--;
if (state.failed) return retval;
}
break;
case 4:
{
if (state.backtracking == 0) {
isLeft=helper.getLeftMostExpr() == null;
}
int alt40=3;
int LA40_0=input.LA(1);
if ((LA40_0 == ID)) {
int LA40_1=input.LA(2);
if ((LA40_1 == COLON)) {
int LA40_3=input.LA(3);
if (((inMap == 0 && ternOp == 0 && input.LA(2) == DRLLexer.COLON))) {
  alt40=1;
}
}
 else if ((LA40_1 == UNIFY)) {
alt40=2;
}
}
switch (alt40) {
case 1:
{
{
  if (!((inMap == 0 && ternOp == 0 && input.LA(2) == DRLLexer.COLON))) {
    if (state.backtracking > 0) {
      state.failed=true;
      return retval;
    }
    throw new FailedPredicateException(input,"unaryExpressionNotPlusMinus","inMap == 0 && ternOp == 0 && input.LA(2) == DRLLexer.COLON");
  }
{
    var=(Token)match(input,ID,FOLLOW_ID_in_unaryExpressionNotPlusMinus2067);
    if (state.failed)     return retval;
    match(input,COLON,FOLLOW_COLON_in_unaryExpressionNotPlusMinus2069);
    if (state.failed)     return retval;
    if (state.backtracking == 0) {
      hasBindings=true;
      if (buildDescr) {
        bind=new BindingDescr((var != null ? var.getText() : null),null,false);
        helper.setStart(bind,var);
      }
    }
  }
}
}
break;
case 2:
{
{
if (!((inMap == 0 && ternOp == 0 && input.LA(2) == DRLLexer.UNIFY))) {
if (state.backtracking > 0) {
  state.failed=true;
  return retval;
}
throw new FailedPredicateException(input,"unaryExpressionNotPlusMinus","inMap == 0 && ternOp == 0 && input.LA(2) == DRLLexer.UNIFY");
}
{
var=(Token)match(input,ID,FOLLOW_ID_in_unaryExpressionNotPlusMinus2109);
if (state.failed) return retval;
match(input,UNIFY,FOLLOW_UNIFY_in_unaryExpressionNotPlusMinus2111);
if (state.failed) return retval;
if (state.backtracking == 0) {
  hasBindings=true;
  if (buildDescr) {
    bind=new BindingDescr((var != null ? var.getText() : null),null,true);
    helper.setStart(bind,var);
  }
}
}
}
}
break;
}
pushFollow(FOLLOW_primary_in_unaryExpressionNotPlusMinus2156);
left=primary();
state._fsp--;
if (state.failed) return retval;
if (state.backtracking == 0) {
if (buildDescr) {
retval.result=left;
}
}
loop41: do {
int alt41=2;
int LA41_0=input.LA(1);
if ((LA41_0 == DOT) && (synpred16_DRLExpressions())) {
alt41=1;
}
 else if ((LA41_0 == LEFT_SQUARE) && (synpred16_DRLExpressions())) {
alt41=1;
}
switch (alt41) {
case 1:
{
pushFollow(FOLLOW_selector_in_unaryExpressionNotPlusMinus2173);
selector();
state._fsp--;
if (state.failed) return retval;
}
break;
default :
break loop41;
}
}
 while (true);
if (state.backtracking == 0) {
if (buildDescr) {
String expr=input.toString(retval.start,input.LT(-1));
if (isLeft) {
helper.setLeftMostExpr(expr);
}
if (bind != null) {
if (bind.isUnification()) {
expr=expr.substring(expr.indexOf(":=") + 2).trim();
}
 else {
expr=expr.substring(expr.indexOf(":") + 1).trim();
}
bind.setExpression(expr);
helper.setEnd(bind);
retval.result=bind;
}
}
}
int alt42=2;
int LA42_0=input.LA(1);
if (((LA42_0 >= DECR && LA42_0 <= INCR)) && (synpred17_DRLExpressions())) {
alt42=1;
}
switch (alt42) {
case 1:
{
if ((input.LA(1) >= DECR && input.LA(1) <= INCR)) {
input.consume();
state.errorRecovery=false;
state.failed=false;
}
 else {
if (state.backtracking > 0) {
state.failed=true;
return retval;
}
MismatchedSetException mse=new MismatchedSetException(null,input);
throw mse;
}
}
break;
}
}
break;
}
retval.stop=input.LT(-1);
}
 catch (RecognitionException re) {
throw re;
}
 finally {
}
return retval;
}
