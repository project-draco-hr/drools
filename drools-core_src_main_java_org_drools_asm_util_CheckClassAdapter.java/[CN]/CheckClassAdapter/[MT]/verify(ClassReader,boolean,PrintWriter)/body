{
  ClassNode cn=new ClassNode();
  cr.accept(new CheckClassAdapter(cn),true);
  List methods=cn.methods;
  for (int i=0; i < methods.size(); ++i) {
    MethodNode method=(MethodNode)methods.get(i);
    if (method.instructions.size() > 0) {
      Analyzer a=new Analyzer(new SimpleVerifier(Type.getType("L" + cn.name + ";"),Type.getType("L" + cn.superName + ";"),(cn.access & Opcodes.ACC_INTERFACE) != 0));
      try {
        a.analyze(cn.name,method);
        if (!dump) {
          continue;
        }
      }
 catch (      Exception e) {
        e.printStackTrace();
      }
      Frame[] frames=a.getFrames();
      TraceMethodVisitor mv=new TraceMethodVisitor();
      pw.println(method.name + method.desc);
      for (int j=0; j < method.instructions.size(); ++j) {
        ((AbstractInsnNode)method.instructions.get(j)).accept(mv);
        StringBuffer s=new StringBuffer();
        Frame f=frames[j];
        if (f == null) {
          s.append('?');
        }
 else {
          for (int k=0; k < f.getLocals(); ++k) {
            s.append(getShortName(f.getLocal(k).toString())).append(' ');
          }
          s.append(" : ");
          for (int k=0; k < f.getStackSize(); ++k) {
            s.append(getShortName(f.getStack(k).toString())).append(' ');
          }
        }
        while (s.length() < method.maxStack + method.maxLocals + 1) {
          s.append(' ');
        }
        pw.print(Integer.toString(j + 100000).substring(1));
        pw.print(" " + s + " : "+ mv.buf);
      }
      for (int j=0; j < method.tryCatchBlocks.size(); ++j) {
        ((TryCatchBlockNode)method.tryCatchBlocks.get(j)).accept(mv);
        pw.print(" " + mv.buf);
      }
      pw.println();
    }
  }
}
