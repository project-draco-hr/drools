{
  DefeasibleLogicalDependency newDep=(DefeasibleLogicalDependency)((LinkedListEntry)node).getObject();
  newDep.setStatus(resolveStatus(newDep));
  RuleImpl rule=newDep.getJustifier().getRule();
  boolean wasDefeated=false;
  for (LinkedListEntry<DefeasibleLogicalDependency> existingNode=rootUndefeated; existingNode != null; existingNode=existingNode.getNext()) {
    DefeasibleLogicalDependency existingDep=existingNode.getObject();
    wasDefeated=checkIsDefeated(newDep,rule,existingDep);
    if (wasDefeated) {
      existingDep.addDefeated(newDep);
      break;
    }
  }
  if (!wasDefeated) {
    LinkedListEntry<DefeasibleLogicalDependency> stagedDeps=null;
    for (LinkedListEntry<DefeasibleLogicalDependency> existingNode=rootUndefeated; existingNode != null; ) {
      LinkedListEntry<DefeasibleLogicalDependency> next=existingNode.getNext();
      DefeasibleLogicalDependency existingDep=existingNode.getObject();
      if (checkIsDefeated(existingDep,existingDep.getJustifier().getRule(),newDep)) {
        removeUndefeated(existingDep,existingNode);
        newDep.addDefeated(existingDep);
        if (existingDep.getRootDefeated() != null) {
          if (stagedDeps == null) {
            stagedDeps=existingDep.getRootDefeated();
          }
 else {
            stagedDeps.setPrevious(existingDep.getTailDefeated());
            stagedDeps=existingDep.getRootDefeated();
          }
        }
        existingDep.clearDefeated();
      }
      existingNode=next;
    }
    addUndefeated(newDep,(LinkedListEntry<DefeasibleLogicalDependency>)node);
    reprocessDefeated(stagedDeps);
  }
  updateStatus();
}
