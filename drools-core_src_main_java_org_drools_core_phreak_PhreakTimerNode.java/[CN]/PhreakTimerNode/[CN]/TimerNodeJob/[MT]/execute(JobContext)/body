{
  final TimerNodeJobContext timerJobCtx=(TimerNodeJobContext)ctx;
  Trigger trigger=timerJobCtx.getTrigger();
  final PathMemory pmem=timerJobCtx.getPathMemory();
  pmem.doLinkRule(timerJobCtx.getWorkingMemory());
  LeftTupleList leftTuples=timerJobCtx.getTimerNodeMemory().getInsertOrUpdateLeftTuples();
  LeftTuple lt=timerJobCtx.getLeftTuple();
  if (log.isTraceEnabled()) {
    log.trace("Timer Executor {} {}",timerJobCtx.getTrigger(),lt);
  }
synchronized (leftTuples) {
    if (timerJobCtx.getJobHandle().isCancel()) {
      return;
    }
    if (lt.getMemory() == null) {
      leftTuples.add(lt);
    }
  }
  timerJobCtx.getTimerNodeMemory().setNodeDirtyWithoutNotify();
  pmem.queueRuleAgendaItem(timerJobCtx.getWorkingMemory());
  final TimedRuleExecutionFilter filter=timerJobCtx.getWorkingMemory().getSessionConfiguration().getTimedRuleExecutionFilter();
  if (filter != null) {
    ExecutorHolder.executor.execute(new Runnable(){
      @Override public void run(){
        if (filter.accept(new Rule[]{pmem.getRule()})) {
          new Executor(pmem,timerJobCtx.getWorkingMemory(),timerJobCtx.getSink(),timerJobCtx.getTimerNodeMemory()).evauateAndFireRule();
        }
      }
    }
);
  }
}
