{
  final TimerNodeJobContext timerJobCtx=(TimerNodeJobContext)ctx;
  Trigger trigger=timerJobCtx.getTrigger();
  LeftTupleList leftTuples=timerJobCtx.getTimerNodeMemory().getInsertOrUpdateLeftTuples();
  LeftTuple lt=timerJobCtx.getLeftTuple();
  if (log.isTraceEnabled()) {
    log.trace("Timer Executor {} {}",timerJobCtx.getTrigger(),lt);
  }
synchronized (leftTuples) {
    if (timerJobCtx.getJobHandle().isCancel()) {
      return;
    }
    if (lt.getMemory() == null) {
      leftTuples.add(lt);
    }
  }
  timerJobCtx.getTimerNodeMemory().setNodeDirtyWithoutNotify();
  for (  final PathMemory pmem : timerJobCtx.getPathMemories()) {
    pmem.doLinkRule(timerJobCtx.getWorkingMemory());
    pmem.queueRuleAgendaItem(timerJobCtx.getWorkingMemory());
    final TimedRuleExecutionFilter filter=timerJobCtx.getWorkingMemory().getSessionConfiguration().getTimedRuleExecutionFilter();
    if (filter != null) {
      ExecutorHolder.executor.execute(new Runnable(){
        @Override public void run(){
          if (filter.accept(new Rule[]{pmem.getRule()})) {
            new Executor(pmem,timerJobCtx.getWorkingMemory(),timerJobCtx.getSink(),timerJobCtx.getTimerNodeMemory()).evauateAndFireRule();
          }
        }
      }
);
    }
  }
}
