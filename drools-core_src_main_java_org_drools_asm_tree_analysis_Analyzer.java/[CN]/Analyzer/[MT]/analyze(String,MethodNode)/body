{
  this.n=m.instructions.size();
  this.indexes=new IntMap(2 * this.n);
  this.handlers=new List[this.n];
  this.frames=new Frame[this.n];
  this.subroutines=new Subroutine[this.n];
  this.queued=new boolean[this.n];
  this.queue=new int[this.n];
  this.top=0;
  for (int i=0; i < this.n; ++i) {
    Object insn=m.instructions.get(i);
    if (insn instanceof LabelNode) {
      insn=((LabelNode)insn).label;
    }
    this.indexes.put(insn,i);
  }
  for (int i=0; i < m.tryCatchBlocks.size(); ++i) {
    final TryCatchBlockNode tcb=(TryCatchBlockNode)m.tryCatchBlocks.get(i);
    final int begin=this.indexes.get(tcb.start);
    final int end=this.indexes.get(tcb.end);
    for (int j=begin; j < end; ++j) {
      List insnHandlers=this.handlers[j];
      if (insnHandlers == null) {
        insnHandlers=new ArrayList();
        this.handlers[j]=insnHandlers;
      }
      insnHandlers.add(tcb);
    }
  }
  final Frame current=newFrame(m.maxLocals,m.maxStack);
  final Frame handler=newFrame(m.maxLocals,m.maxStack);
  final Type[] args=Type.getArgumentTypes(m.desc);
  int local=0;
  if ((m.access & Opcodes.ACC_STATIC) == 0) {
    final Type ctype=Type.getType("L" + owner + ";");
    current.setLocal(local++,this.interpreter.newValue(ctype));
  }
  for (int i=0; i < args.length; ++i) {
    current.setLocal(local++,this.interpreter.newValue(args[i]));
    if (args[i].getSize() == 2) {
      current.setLocal(local++,this.interpreter.newValue(null));
    }
  }
  while (local < m.maxLocals) {
    current.setLocal(local++,this.interpreter.newValue(null));
  }
  merge(0,current,null);
  while (this.top > 0) {
    final int insn=this.queue[--this.top];
    final Frame f=this.frames[insn];
    Subroutine subroutine=this.subroutines[insn];
    this.queued[insn]=false;
    try {
      final Object o=m.instructions.get(insn);
      this.jsr=false;
      if (o instanceof LabelNode) {
        merge(insn + 1,f,subroutine);
      }
 else {
        final AbstractInsnNode insnNode=(AbstractInsnNode)o;
        final int insnOpcode=insnNode.getOpcode();
        current.init(f).execute(insnNode,this.interpreter);
        subroutine=subroutine == null ? null : subroutine.copy();
        if (insnNode instanceof JumpInsnNode) {
          final JumpInsnNode j=(JumpInsnNode)insnNode;
          if (insnOpcode != Opcodes.GOTO && insnOpcode != Opcodes.JSR) {
            merge(insn + 1,current,subroutine);
          }
          if (insnOpcode == Opcodes.JSR) {
            this.jsr=true;
            merge(this.indexes.get(j.label),current,new Subroutine(j.label,m.maxLocals,j));
          }
 else {
            merge(this.indexes.get(j.label),current,subroutine);
          }
        }
 else         if (insnNode instanceof LookupSwitchInsnNode) {
          final LookupSwitchInsnNode lsi=(LookupSwitchInsnNode)insnNode;
          merge(this.indexes.get(lsi.dflt),current,subroutine);
          for (int j=0; j < lsi.labels.size(); ++j) {
            final Label label=(Label)lsi.labels.get(j);
            merge(this.indexes.get(label),current,subroutine);
          }
        }
 else         if (insnNode instanceof TableSwitchInsnNode) {
          final TableSwitchInsnNode tsi=(TableSwitchInsnNode)insnNode;
          merge(this.indexes.get(tsi.dflt),current,subroutine);
          for (int j=0; j < tsi.labels.size(); ++j) {
            final Label label=(Label)tsi.labels.get(j);
            merge(this.indexes.get(label),current,subroutine);
          }
        }
 else         if (insnOpcode == Opcodes.RET) {
          if (subroutine == null) {
            throw new AnalyzerException("RET instruction outside of a sub routine");
          }
          for (int i=0; i < subroutine.callers.size(); ++i) {
            final int caller=this.indexes.get(subroutine.callers.get(i));
            merge(caller + 1,this.frames[caller],current,this.subroutines[caller],subroutine.access);
          }
        }
 else         if (insnOpcode != Opcodes.ATHROW && (insnOpcode < Opcodes.IRETURN || insnOpcode > Opcodes.RETURN)) {
          if (subroutine != null) {
            if (insnNode instanceof VarInsnNode) {
              final int var=((VarInsnNode)insnNode).var;
              subroutine.access[var]=true;
              if (insnOpcode == Opcodes.LLOAD || insnOpcode == Opcodes.DLOAD || insnOpcode == Opcodes.LSTORE || insnOpcode == Opcodes.DSTORE) {
                subroutine.access[var + 1]=true;
              }
            }
 else             if (insnNode instanceof IincInsnNode) {
              final int var=((IincInsnNode)insnNode).var;
              subroutine.access[var]=true;
            }
          }
          merge(insn + 1,current,subroutine);
        }
      }
      final List insnHandlers=this.handlers[insn];
      if (insnHandlers != null) {
        for (int i=0; i < insnHandlers.size(); ++i) {
          final TryCatchBlockNode tcb=(TryCatchBlockNode)insnHandlers.get(i);
          Type type;
          if (tcb.type == null) {
            type=Type.getType("Ljava/lang/Throwable;");
          }
 else {
            type=Type.getType("L" + tcb.type + ";");
          }
          handler.init(f);
          handler.clearStack();
          handler.push(this.interpreter.newValue(type));
          merge(this.indexes.get(tcb.handler),handler,subroutine);
        }
      }
    }
 catch (    final AnalyzerException e) {
      throw new AnalyzerException("Error at instruction " + insn + ": "+ e.getMessage(),e);
    }
catch (    final Exception e) {
      throw new AnalyzerException("Error at instruction " + insn + ": "+ e.getMessage(),e);
    }
  }
  return this.frames;
}
