{
  n=m.instructions.size();
  indexes=new IntMap(2 * n);
  handlers=new List[n];
  frames=new Frame[n];
  subroutines=new Subroutine[n];
  queued=new boolean[n];
  queue=new int[n];
  top=0;
  for (int i=0; i < n; ++i) {
    Object insn=m.instructions.get(i);
    if (insn instanceof LabelNode) {
      insn=((LabelNode)insn).label;
    }
    indexes.put(insn,i);
  }
  for (int i=0; i < m.tryCatchBlocks.size(); ++i) {
    TryCatchBlockNode tcb=(TryCatchBlockNode)m.tryCatchBlocks.get(i);
    int begin=indexes.get(tcb.start);
    int end=indexes.get(tcb.end);
    for (int j=begin; j < end; ++j) {
      List insnHandlers=handlers[j];
      if (insnHandlers == null) {
        insnHandlers=new ArrayList();
        handlers[j]=insnHandlers;
      }
      insnHandlers.add(tcb);
    }
  }
  Frame current=newFrame(m.maxLocals,m.maxStack);
  Frame handler=newFrame(m.maxLocals,m.maxStack);
  Type[] args=Type.getArgumentTypes(m.desc);
  int local=0;
  if ((m.access & ACC_STATIC) == 0) {
    Type ctype=Type.getType("L" + owner + ";");
    current.setLocal(local++,interpreter.newValue(ctype));
  }
  for (int i=0; i < args.length; ++i) {
    current.setLocal(local++,interpreter.newValue(args[i]));
    if (args[i].getSize() == 2) {
      current.setLocal(local++,interpreter.newValue(null));
    }
  }
  while (local < m.maxLocals) {
    current.setLocal(local++,interpreter.newValue(null));
  }
  merge(0,current,null);
  while (top > 0) {
    int insn=queue[--top];
    Frame f=frames[insn];
    Subroutine subroutine=subroutines[insn];
    queued[insn]=false;
    try {
      Object o=m.instructions.get(insn);
      jsr=false;
      if (o instanceof LabelNode) {
        merge(insn + 1,f,subroutine);
      }
 else {
        AbstractInsnNode insnNode=(AbstractInsnNode)o;
        int insnOpcode=insnNode.getOpcode();
        current.init(f).execute(insnNode,interpreter);
        subroutine=subroutine == null ? null : subroutine.copy();
        if (insnNode instanceof JumpInsnNode) {
          JumpInsnNode j=(JumpInsnNode)insnNode;
          if (insnOpcode != GOTO && insnOpcode != JSR) {
            merge(insn + 1,current,subroutine);
          }
          if (insnOpcode == JSR) {
            jsr=true;
            merge(indexes.get(j.label),current,new Subroutine(j.label,m.maxLocals,j));
          }
 else {
            merge(indexes.get(j.label),current,subroutine);
          }
        }
 else         if (insnNode instanceof LookupSwitchInsnNode) {
          LookupSwitchInsnNode lsi=(LookupSwitchInsnNode)insnNode;
          merge(indexes.get(lsi.dflt),current,subroutine);
          for (int j=0; j < lsi.labels.size(); ++j) {
            Label label=(Label)lsi.labels.get(j);
            merge(indexes.get(label),current,subroutine);
          }
        }
 else         if (insnNode instanceof TableSwitchInsnNode) {
          TableSwitchInsnNode tsi=(TableSwitchInsnNode)insnNode;
          merge(indexes.get(tsi.dflt),current,subroutine);
          for (int j=0; j < tsi.labels.size(); ++j) {
            Label label=(Label)tsi.labels.get(j);
            merge(indexes.get(label),current,subroutine);
          }
        }
 else         if (insnOpcode == RET) {
          if (subroutine == null) {
            throw new AnalyzerException("RET instruction outside of a sub routine");
          }
          for (int i=0; i < subroutine.callers.size(); ++i) {
            int caller=indexes.get(subroutine.callers.get(i));
            merge(caller + 1,frames[caller],current,subroutines[caller],subroutine.access);
          }
        }
 else         if (insnOpcode != ATHROW && (insnOpcode < IRETURN || insnOpcode > RETURN)) {
          if (subroutine != null) {
            if (insnNode instanceof VarInsnNode) {
              int var=((VarInsnNode)insnNode).var;
              subroutine.access[var]=true;
              if (insnOpcode == LLOAD || insnOpcode == DLOAD || insnOpcode == LSTORE || insnOpcode == DSTORE) {
                subroutine.access[var + 1]=true;
              }
            }
 else             if (insnNode instanceof IincInsnNode) {
              int var=((IincInsnNode)insnNode).var;
              subroutine.access[var]=true;
            }
          }
          merge(insn + 1,current,subroutine);
        }
      }
      List insnHandlers=handlers[insn];
      if (insnHandlers != null) {
        for (int i=0; i < insnHandlers.size(); ++i) {
          TryCatchBlockNode tcb=(TryCatchBlockNode)insnHandlers.get(i);
          Type type;
          if (tcb.type == null) {
            type=Type.getType("Ljava/lang/Throwable;");
          }
 else {
            type=Type.getType("L" + tcb.type + ";");
          }
          handler.init(f);
          handler.clearStack();
          handler.push(interpreter.newValue(type));
          merge(indexes.get(tcb.handler),handler,subroutine);
        }
      }
    }
 catch (    AnalyzerException e) {
      throw new AnalyzerException("Error at instruction " + insn + ": "+ e.getMessage(),e);
    }
catch (    Exception e) {
      throw new AnalyzerException("Error at instruction " + insn + ": "+ e.getMessage(),e);
    }
  }
  return frames;
}
