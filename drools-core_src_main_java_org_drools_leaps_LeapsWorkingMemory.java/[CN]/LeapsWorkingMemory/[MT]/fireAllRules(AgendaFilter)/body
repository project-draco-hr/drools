{
  if (!this.firing) {
    try {
      this.firing=true;
      boolean nothingToProcess=false;
      while (!nothingToProcess) {
        for (Iterator rulesIt=this.noPositiveColumnsRules.iterator(); rulesIt.hasNext(); ) {
          LeapsRule rule=((LeapsRuleHandle)rulesIt.next()).getLeapsRule();
          final PropagationContextImpl context=new PropagationContextImpl(nextPropagationIdCounter(),PropagationContext.ASSERTION,null,null);
          final LeapsTuple tuple=new LeapsTuple(new LeapsFactHandle[0],rule,context);
          if (TokenEvaluator.processAfterAllPositiveConstraintOk(tuple,rule,this)) {
            this.assertTuple(tuple);
          }
        }
        this.noPositiveColumnsRules.clear();
        while (!this.mainStack.empty()) {
          final Token token=this.peekTokenOnTop();
          boolean done=false;
          while (!done) {
            if (!token.isResume()) {
              if (token.hasNextRuleHandle()) {
                token.nextRuleHandle();
              }
 else {
                this.removeTokenFromStack((LeapsFactHandle)token.getDominantFactHandle());
                done=true;
              }
            }
            if (!done) {
              try {
                TokenEvaluator.evaluate(token);
                if (token.getDominantFactHandle() != null) {
                  if (token.getDominantFactHandle().getObject().getClass() != FromConstraintFactDriver.class) {
                    token.setResume(true);
                  }
                  done=true;
                }
              }
 catch (              final NoMatchesFoundException ex) {
                token.setResume(false);
              }
            }
            while (this.agenda.fireNextItem(agendaFilter)) {
              ;
            }
          }
        }
        while (this.agenda.fireNextItem(agendaFilter)) {
          ;
        }
        if (this.mainStack.empty()) {
          nothingToProcess=true;
        }
      }
      this.rulesAddedSinceLastFireAll=false;
      this.idLastFireAllAt=((LeapsFactHandleFactory)this.handleFactory).getNextId();
      for (final Iterator it=this.factTables.values().iterator(); it.hasNext(); ) {
        ((FactTable)it.next()).setReseededStack(true);
      }
      this.getFactTable(FromConstraintFactDriver.class).clear();
    }
  finally {
      this.firing=false;
    }
  }
}
