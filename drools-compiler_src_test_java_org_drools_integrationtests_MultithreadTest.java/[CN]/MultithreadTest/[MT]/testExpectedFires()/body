{
  try {
    final PackageBuilder packageBuilder=new PackageBuilder();
    packageBuilder.addPackageFromDrl(new InputStreamReader(getClass().getResourceAsStream("test_MultithreadFiringCheck.drl")));
    final RuleBase ruleBase=RuleBaseFactory.newRuleBase();
    ruleBase.addPackage(packageBuilder.getPackage());
    final Queue errorList=new ConcurrentLinkedQueue();
    final Thread t[]=new Thread[50];
    for (int i=0; i < t.length; i++) {
      final int count=i;
      t[i]=new Thread(new Runnable(){
        public void run(){
          try {
            final int iterations=count * 15 + 3000;
            final List results=new ArrayList();
            final StatefulSession session2=ruleBase.newStatefulSession();
            session2.setGlobal("results",results);
            session2.insert(new Integer(-1));
            for (int k=0; k < iterations; k++) {
              session2.insert(new Integer(k));
              if (k + 1 != session2.getAgenda().agendaSize()) {
                errorList.add("THREAD-" + count + " ERROR: expected agenda size="+ (k + 1)+ " but was "+ session2.getAgenda().agendaSize());
              }
            }
            session2.fireAllRules();
            session2.dispose();
            if (results.size() != iterations) {
              errorList.add("THREAD-" + count + " ERROR: expected fire count="+ iterations+ " but was "+ results.size());
            }
          }
 catch (          Exception e) {
            errorList.add("THREAD-" + count + " EXCEPTION: "+ e.getMessage());
            e.printStackTrace();
          }
        }
      }
);
      t[i].start();
    }
    for (int i=0; i < t.length; i++) {
      t[i].join();
    }
    assertTrue("Errors during execution: " + errorList.toString(),errorList.isEmpty());
  }
 catch (  Exception e) {
    e.printStackTrace();
    fail("No exception should have been raised: " + e.getMessage());
  }
}
