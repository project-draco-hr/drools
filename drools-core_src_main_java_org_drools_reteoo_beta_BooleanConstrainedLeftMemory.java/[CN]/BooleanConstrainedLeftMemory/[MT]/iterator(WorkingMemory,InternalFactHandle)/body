{
  this.selectPossibleMatches(workingMemory,handle);
  final Iterator iterator=new Iterator(){
    MultiLinkedListNode current=null;
    MultiLinkedListNode next=null;
    MultiLinkedListNode candidate=(MultiLinkedListNode)BooleanConstrainedLeftMemory.this.selectedList.getFirst();
    public final boolean hasNext(){
      boolean hasnext=false;
      if (this.next == null) {
        while (this.candidate != null) {
          if ((BooleanConstrainedLeftMemory.this.innerMemory == null) || (BooleanConstrainedLeftMemory.this.innerMemory.isPossibleMatch((MultiLinkedListNodeWrapper)this.candidate.getChild()))) {
            hasnext=true;
            this.next=this.candidate;
            this.candidate=(MultiLinkedListNode)this.candidate.getNext();
            break;
          }
          this.candidate=(MultiLinkedListNode)this.candidate.getNext();
        }
      }
 else {
        hasnext=true;
      }
      return hasnext;
    }
    public final Object next(){
      if (this.next == null) {
        this.hasNext();
      }
      this.current=this.next;
      this.next=null;
      if (this.current == null) {
        throw new NoSuchElementException("No more elements to return");
      }
      return this.current;
    }
    public final void remove(){
      if (this.current != null) {
        BooleanConstrainedLeftMemory.this.remove(workingMemory,(ReteTuple)this.current);
      }
 else {
        throw new IllegalStateException("No item to remove. Call next() before calling remove().");
      }
    }
  }
;
  return iterator;
}
