{
  return new Iterator(){
    Iterator trueIt=BooleanConstrainedLeftMemory.this.trueList.iterator();
    Iterator falseIt=BooleanConstrainedLeftMemory.this.falseList.iterator();
    ReteTuple currentTrue=null;
    ReteTuple currentFalse=null;
    ReteTuple current=null;
    ReteTuple next=null;
    public final boolean hasNext(){
      boolean hasnext=false;
      if (this.next == null) {
        if ((this.currentTrue == null) && (this.trueIt.hasNext())) {
          this.currentTrue=(ReteTuple)this.trueIt.next();
        }
        if ((this.currentFalse == null) && (this.falseIt.hasNext())) {
          this.currentFalse=(ReteTuple)this.falseIt.next();
        }
        if ((this.currentTrue != null) && (this.currentFalse != null)) {
          if (this.currentTrue.getRecency() <= this.currentFalse.getRecency()) {
            this.next=this.currentTrue;
            this.currentTrue=null;
          }
 else {
            this.next=this.currentFalse;
            this.currentFalse=null;
          }
          hasnext=true;
        }
 else         if (this.currentTrue != null) {
          this.next=this.currentTrue;
          this.currentTrue=null;
          hasnext=true;
        }
 else         if (this.currentFalse != null) {
          this.next=this.currentFalse;
          this.currentFalse=null;
          hasnext=true;
        }
      }
 else {
        hasnext=true;
      }
      return hasnext;
    }
    public final Object next(){
      if (this.next == null) {
        this.hasNext();
      }
      this.current=this.next;
      this.next=null;
      if (this.current == null) {
        throw new NoSuchElementException("No more elements to return");
      }
      return this.current;
    }
    public final void remove(){
      throw new UnsupportedOperationException("Not possible to call remove when iterating over all elements");
    }
  }
;
}
