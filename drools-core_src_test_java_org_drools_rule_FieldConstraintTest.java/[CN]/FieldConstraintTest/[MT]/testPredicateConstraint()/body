{
  final ReteooRuleBase ruleBase=(ReteooRuleBase)RuleBaseFactory.newRuleBase();
  final InternalWorkingMemory workingMemory=(InternalWorkingMemory)ruleBase.newStatefulSession();
  final InternalReadAccessor priceExtractor=cache.getReader(Cheese.class,"price",getClass().getClassLoader());
  Pattern pattern=new Pattern(0,new ClassObjectType(Cheese.class));
  final Declaration price1Declaration=new Declaration("price1",priceExtractor,pattern);
  pattern=new Pattern(1,new ClassObjectType(Cheese.class));
  final Declaration price2Declaration=new Declaration("price2",priceExtractor,pattern);
  final PredicateExpression evaluator=new PredicateExpression(){
    /** 
 */
    private static final long serialVersionUID=400L;
    public boolean evaluate(    Object object,    Tuple tuple,    Declaration[] previousDeclarations,    Declaration[] localDeclarations,    WorkingMemory workingMemory,    Object context){
      int price1=previousDeclarations[0].getIntValue((InternalWorkingMemory)workingMemory,workingMemory.getObject(tuple.get(previousDeclarations[0])));
      int price2=localDeclarations[0].getIntValue((InternalWorkingMemory)workingMemory,object);
      return (price2 == (price1 * 2));
    }
    public Object createContext(){
      return null;
    }
    public void readExternal(    ObjectInput in) throws IOException, ClassNotFoundException {
    }
    public void writeExternal(    ObjectOutput out) throws IOException {
    }
  }
;
  final PredicateConstraint constraint1=new PredicateConstraint(evaluator,new Declaration[]{price1Declaration},new Declaration[]{price2Declaration},new String[]{});
  final Cheese cheddar0=new Cheese("cheddar",5);
  final InternalFactHandle f0=(InternalFactHandle)workingMemory.insert(cheddar0);
  LeftTuple tuple=new LeftTuple(f0,null,true);
  final Cheese cheddar1=new Cheese("cheddar",10);
  final InternalFactHandle f1=(InternalFactHandle)workingMemory.insert(cheddar1);
  tuple=new LeftTuple(tuple,new RightTuple(f1,null),null,true);
  final PredicateContextEntry context=(PredicateContextEntry)constraint1.createContextEntry();
  context.updateFromTuple(workingMemory,tuple);
  assertTrue(constraint1.isAllowedCachedLeft(context,f1));
}
