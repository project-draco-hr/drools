{
  final ReteooRuleBase ruleBase=(ReteooRuleBase)RuleBaseFactory.newRuleBase();
  final InternalWorkingMemory workingMemory=(InternalWorkingMemory)ruleBase.newWorkingMemory();
  final FieldExtractor priceExtractor=new ClassFieldExtractor(Cheese.class,"price");
  Column column=new Column(0,new ClassObjectType(Cheese.class));
  final Declaration price1Declaration=new Declaration("price1",priceExtractor,column);
  column=new Column(1,new ClassObjectType(Cheese.class));
  final Declaration price2Declaration=new Declaration("price2",priceExtractor,column);
  final PredicateExpression evaluator=new PredicateExpression(){
    /** 
 */
    private static final long serialVersionUID=-7805842671538257493L;
    public boolean evaluate(    Object object,    Tuple tuple,    Declaration declaration,    Declaration[] previousDeclarations,    Declaration[] localDeclarations,    WorkingMemory workingMemory){
      int price1=previousDeclarations[0].getIntValue(workingMemory.getObject(tuple.get(previousDeclarations[0])));
      int price2=declaration.getIntValue(object);
      return (price2 == (price1 * 2));
    }
  }
;
  final PredicateConstraint constraint1=new PredicateConstraint(evaluator,price2Declaration,new Declaration[]{price1Declaration},new Declaration[0]);
  final Cheese cheddar0=new Cheese("cheddar",5);
  final FactHandle f0=workingMemory.assertObject(cheddar0);
  InstrumentedReteTuple tuple=new InstrumentedReteTuple(f0);
  final Cheese cheddar1=new Cheese("cheddar",10);
  final InternalFactHandle f1=(InternalFactHandle)workingMemory.assertObject(cheddar1);
  tuple=new InstrumentedReteTuple(tuple,f1);
  PredicateContextEntry context=(PredicateContextEntry)constraint1.getContextEntry();
  context.updateFromTuple(workingMemory,tuple);
  assertTrue(constraint1.isAllowedCachedLeft(context,f1.getObject()));
}
