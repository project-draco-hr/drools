{
  boolean multithread=context.readBoolean();
  long time=context.readLong();
  int handleId=context.readInt();
  long handleCounter=context.readLong();
  long propagationCounter=context.readLong();
  context.readInt();
  context.readLong();
  session.reset(handleId,handleCounter,propagationCounter);
  DefaultAgenda agenda=(DefaultAgenda)session.getAgenda();
  if (session.getTimerService() instanceof PseudoClockScheduler) {
    PseudoClockScheduler clock=(PseudoClockScheduler)session.getTimerService();
    clock.advanceTime(time,TimeUnit.MILLISECONDS);
  }
  readAgenda(context,agenda);
  for (  RuleFlowGroup group : agenda.getRuleFlowGroupsMap().values()) {
    ((RuleFlowGroupImpl)group).setWorkingMemory(session);
  }
  context.wm=session;
  context.handles.put(context.wm.getInitialFactHandle().getId(),context.wm.getInitialFactHandle());
  readFactHandles(context);
  readActionQueue(context);
  readTruthMaintenanceSystem(context);
  if (context.marshalProcessInstances && processMarshaller != null) {
    processMarshaller.readProcessInstances(context);
  }
  if (context.marshalWorkItems && processMarshaller != null) {
    processMarshaller.readWorkItems(context);
  }
  if (processMarshaller != null) {
    processMarshaller.readProcessTimers(context);
  }
 else {
    int token;
    while ((token=context.readShort()) == PersisterEnums.DEFAULT_TIMER) {
      InputMarshaller.readTimer(context);
    }
  }
  if (multithread) {
    session.startPartitionManagers();
  }
  return session;
}
