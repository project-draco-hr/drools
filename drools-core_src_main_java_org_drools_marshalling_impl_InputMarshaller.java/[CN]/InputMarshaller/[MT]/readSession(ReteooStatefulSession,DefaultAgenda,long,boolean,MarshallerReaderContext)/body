{
  if (session.getTimerService() instanceof PseudoClockScheduler) {
    PseudoClockScheduler clock=(PseudoClockScheduler)session.getTimerService();
    clock.advanceTime(time,TimeUnit.MILLISECONDS);
  }
  for (  RuleFlowGroup group : agenda.getRuleFlowGroupsMap().values()) {
    ((RuleFlowGroupImpl)group).setWorkingMemory(session);
  }
  context.wm=session;
  context.handles.put(context.wm.getInitialFactHandle().getId(),context.wm.getInitialFactHandle());
  if (context.stream.readBoolean()) {
    InternalFactHandle initialFactHandle=context.wm.getInitialFactHandle();
    int sinkId=context.stream.readInt();
    ObjectTypeNode initialFactNode=(ObjectTypeNode)context.sinks.get(sinkId);
    if (initialFactNode == null) {
      EntryPointNode defaultEPNode=context.ruleBase.getRete().getEntryPointNode(EntryPoint.DEFAULT);
      BuildContext buildContext=new BuildContext(context.ruleBase,context.ruleBase.getReteooBuilder().getIdGenerator());
      buildContext.setPartitionId(RuleBasePartitionId.MAIN_PARTITION);
      buildContext.setObjectTypeNodeMemoryEnabled(true);
      initialFactNode=new ObjectTypeNode(sinkId,defaultEPNode,ClassObjectType.InitialFact_ObjectType,buildContext);
      context.ruleBase.lock();
      try {
        InternalWorkingMemory[] wms=buildContext.getWorkingMemories();
        if (wms.length > 0) {
          initialFactNode.attach(wms);
        }
 else {
          initialFactNode.attach();
        }
      }
  finally {
        context.ruleBase.unlock();
      }
    }
    ObjectHashSet initialFactMemory=(ObjectHashSet)context.wm.getNodeMemory(initialFactNode);
    initialFactMemory.add(initialFactHandle);
    readRightTuples(initialFactHandle,context);
  }
  while (context.readShort() == PersisterEnums.ENTRY_POINT) {
    String entryPointId=context.stream.readUTF();
    WorkingMemoryEntryPoint wmep=context.wm.getEntryPoints().get(entryPointId);
    readFactHandles(context,((NamedEntryPoint)wmep).getObjectStore());
  }
  InternalFactHandle handle=context.wm.getInitialFactHandle();
  while (context.stream.readShort() == PersisterEnums.LEFT_TUPLE) {
    LeftTupleSink sink=(LeftTupleSink)context.sinks.get(context.stream.readInt());
    LeftTuple leftTuple=sink.createLeftTuple(handle,sink,true);
    readLeftTuple(leftTuple,context);
  }
  readPropagationContexts(context);
  readActivations(context);
  readActionQueue(context);
  readTruthMaintenanceSystem(context);
  if (processMarshaller != null) {
    processMarshaller.readProcessInstances(context);
  }
 else {
    short type=context.stream.readShort();
    if (PersisterEnums.END != type) {
      throw new IllegalStateException("No process marshaller, unable to unmarshall type: " + type);
    }
  }
  if (processMarshaller != null) {
    processMarshaller.readWorkItems(context);
  }
 else {
    short type=context.stream.readShort();
    if (PersisterEnums.END != type) {
      throw new IllegalStateException("No process marshaller, unable to unmarshall type: " + type);
    }
  }
  if (processMarshaller != null) {
    processMarshaller.readProcessTimers(context);
  }
 else {
    short type=context.stream.readShort();
    if (PersisterEnums.END != type) {
      throw new IllegalStateException("No process marshaller, unable to unmarshall type: " + type);
    }
  }
  while (context.readShort() == PersisterEnums.DEFAULT_TIMER) {
    InputMarshaller.readTimer(context);
  }
  if (multithread) {
    session.startPartitionManagers();
  }
  return session;
}
