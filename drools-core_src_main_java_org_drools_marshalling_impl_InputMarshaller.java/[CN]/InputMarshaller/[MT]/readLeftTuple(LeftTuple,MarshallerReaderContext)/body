{
  ObjectInputStream stream=context.stream;
  Map<Integer,BaseNode> sinks=context.sinks;
  LeftTupleSink sink=parentLeftTuple.getLeftTupleSink();
switch (sink.getType()) {
case NodeTypeEnums.JoinNode:
{
      BetaMemory memory=(BetaMemory)context.wm.getNodeMemory((BetaNode)sink);
      readBehaviors((BetaNode)sink,memory,context);
      addToLeftMemory(parentLeftTuple,memory);
      while (stream.readShort() == PersisterEnums.RIGHT_TUPLE) {
        int childSinkId=stream.readInt();
        LeftTupleSink childSink=(LeftTupleSink)sinks.get(childSinkId);
        int factHandleId=stream.readInt();
        RightTupleKey key=new RightTupleKey(factHandleId,sink);
        RightTuple rightTuple=context.rightTuples.get(key);
        LeftTuple childLeftTuple=childSink.createLeftTuple(parentLeftTuple,rightTuple,null,null,childSink,true);
        readLeftTuple(childLeftTuple,context);
      }
      break;
    }
case NodeTypeEnums.EvalConditionNode:
{
    while (stream.readShort() == PersisterEnums.LEFT_TUPLE) {
      LeftTupleSink childSink=(LeftTupleSink)sinks.get(stream.readInt());
      LeftTuple childLeftTuple=childSink.createLeftTuple(parentLeftTuple,childSink,true);
      readLeftTuple(childLeftTuple,context);
    }
    break;
  }
case NodeTypeEnums.NotNode:
case NodeTypeEnums.ForallNotNode:
{
  BetaMemory memory=(BetaMemory)context.wm.getNodeMemory((BetaNode)sink);
  readBehaviors((BetaNode)sink,memory,context);
  int type=stream.readShort();
  if (type == PersisterEnums.LEFT_TUPLE_NOT_BLOCKED) {
    addToLeftMemory(parentLeftTuple,memory);
    while (stream.readShort() == PersisterEnums.LEFT_TUPLE) {
      LeftTupleSink childSink=(LeftTupleSink)sinks.get(stream.readInt());
      LeftTuple childLeftTuple=childSink.createLeftTuple(parentLeftTuple,childSink,true);
      readLeftTuple(childLeftTuple,context);
    }
  }
 else {
    int factHandleId=stream.readInt();
    RightTupleKey key=new RightTupleKey(factHandleId,sink);
    RightTuple rightTuple=context.rightTuples.get(key);
    parentLeftTuple.setBlocker(rightTuple);
    rightTuple.addBlocked(parentLeftTuple);
  }
  break;
}
case NodeTypeEnums.ExistsNode:
{
BetaMemory memory=(BetaMemory)context.wm.getNodeMemory((BetaNode)sink);
readBehaviors((BetaNode)sink,memory,context);
int type=stream.readShort();
if (type == PersisterEnums.LEFT_TUPLE_NOT_BLOCKED) {
  addToLeftMemory(parentLeftTuple,memory);
}
 else {
  int factHandleId=stream.readInt();
  RightTupleKey key=new RightTupleKey(factHandleId,sink);
  RightTuple rightTuple=context.rightTuples.get(key);
  parentLeftTuple.setBlocker(rightTuple);
  rightTuple.addBlocked(parentLeftTuple);
  while (stream.readShort() == PersisterEnums.LEFT_TUPLE) {
    LeftTupleSink childSink=(LeftTupleSink)sinks.get(stream.readInt());
    LeftTuple childLeftTuple=childSink.createLeftTuple(parentLeftTuple,childSink,true);
    readLeftTuple(childLeftTuple,context);
  }
}
break;
}
case NodeTypeEnums.AccumulateNode:
{
AccumulateMemory memory=(AccumulateMemory)context.wm.getNodeMemory((BetaNode)sink);
memory.betaMemory.getLeftTupleMemory().add(parentLeftTuple);
readBehaviors((BetaNode)sink,memory.betaMemory,context);
AccumulateContext accctx=new AccumulateContext();
parentLeftTuple.setObject(accctx);
InternalFactHandle handle=readFactHandle(context);
accctx.result=new RightTuple(handle,(RightTupleSink)sink);
accctx.context=(Serializable[])stream.readObject();
accctx.propagated=stream.readBoolean();
short head=-1;
while ((head=stream.readShort()) != PersisterEnums.END) {
switch (head) {
case PersisterEnums.RIGHT_TUPLE:
{
    int factHandleId=stream.readInt();
    RightTupleKey key=new RightTupleKey(factHandleId,sink);
    RightTuple rightTuple=context.rightTuples.get(key);
    sink.createLeftTuple(parentLeftTuple,rightTuple,null,null,sink,true);
    break;
  }
case PersisterEnums.LEFT_TUPLE:
{
  int sinkId=stream.readInt();
  LeftTupleSink childSink=(LeftTupleSink)sinks.get(sinkId);
  LeftTuple childLeftTuple=new LeftTupleImpl(parentLeftTuple,accctx.result,childSink,true);
  readLeftTuple(childLeftTuple,context);
  break;
}
default :
{
throw new RuntimeDroolsException("Marshalling error. This is a bug. Please contact the development team.");
}
}
}
break;
}
case NodeTypeEnums.RightInputAdaterNode:
{
ObjectHashMap memory=(ObjectHashMap)context.wm.getNodeMemory((NodeMemory)sink);
int id=stream.readInt();
long recency=stream.readLong();
InternalFactHandle handle=new DefaultFactHandle(id,parentLeftTuple,recency,context.wm.getEntryPoints().get(EntryPoint.DEFAULT.getEntryPointId()));
memory.put(parentLeftTuple,handle);
readRightTuples(handle,context);
stream.readShort();
break;
}
case NodeTypeEnums.FromNode:
{
FromMemory memory=(FromMemory)context.wm.getNodeMemory((NodeMemory)sink);
memory.betaMemory.getLeftTupleMemory().add(parentLeftTuple);
Map<Object,RightTuple> matches=new LinkedHashMap<Object,RightTuple>();
parentLeftTuple.setObject(matches);
while (stream.readShort() == PersisterEnums.FACT_HANDLE) {
InternalFactHandle handle=readFactHandle(context);
context.handles.put(handle.getId(),handle);
readRightTuples(handle,context);
matches.put(handle.getObject(),handle.getFirstRightTuple());
}
while (stream.readShort() == PersisterEnums.RIGHT_TUPLE) {
LeftTupleSink childSink=(LeftTupleSink)sinks.get(stream.readInt());
int factHandleId=stream.readInt();
RightTupleKey key=new RightTupleKey(factHandleId,null);
RightTuple rightTuple=context.rightTuples.get(key);
LeftTuple childLeftTuple=new LeftTupleImpl(parentLeftTuple,rightTuple,childSink,true);
readLeftTuple(childLeftTuple,context);
}
break;
}
case NodeTypeEnums.UnificationNode:
{
boolean isOpen=context.readBoolean();
if (isOpen) {
QueryElementNode node=(QueryElementNode)sink;
InternalFactHandle handle=readFactHandle(context);
context.handles.put(handle.getId(),handle);
node.createDroolsQuery(parentLeftTuple,handle,context.wm);
readLeftTuples(context);
}
 else {
while (stream.readShort() == PersisterEnums.LEFT_TUPLE) {
LeftTupleSink childSink=(LeftTupleSink)sinks.get(stream.readInt());
InternalFactHandle handle=readFactHandle(context);
context.handles.put(handle.getId(),handle);
RightTuple rightTuple=new RightTuple(handle);
LeftTuple childLeftTuple=new LeftTupleImpl(parentLeftTuple,rightTuple,childSink,true);
readLeftTuple(childLeftTuple,context);
}
}
break;
}
case NodeTypeEnums.RuleTerminalNode:
{
int pos=context.terminalTupleMap.size();
context.terminalTupleMap.put(pos,parentLeftTuple);
break;
}
case NodeTypeEnums.QueryTerminalNode:
{
boolean unificationNode=context.readBoolean();
if (unificationNode) {
InternalFactHandle handle=readFactHandle(context);
context.handles.put(handle.getId(),handle);
RightTuple rightTuple=new RightTuple(handle);
parentLeftTuple.setObject(rightTuple);
LeftTuple entry=parentLeftTuple;
while (entry.getParent() != null) {
entry=entry.getParent();
}
DroolsQuery query=(DroolsQuery)entry.getLastHandle().getObject();
LeftTuple leftTuple=((UnificationNodeViewChangedEventListener)query.getQueryResultCollector()).getLeftTuple();
while (stream.readShort() == PersisterEnums.LEFT_TUPLE) {
LeftTupleSink childSink=(LeftTupleSink)sinks.get(stream.readInt());
LeftTuple childLeftTuple=childSink.createLeftTuple(leftTuple,rightTuple,childSink);
readLeftTuple(childLeftTuple,context);
}
}
break;
}
}
}
