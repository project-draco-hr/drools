{
  ObjectInputStream stream=context.stream;
  InternalWorkingMemory wm=context.wm;
  Map<Integer,BaseNode> sinks=context.sinks;
  LeftTupleSink sink=parentLeftTuple.getLeftTupleSink();
switch (sink.getType()) {
case NodeTypeEnums.JoinNode:
{
      BetaMemory memory=(BetaMemory)context.wm.getNodeMemory((BetaNode)sink);
      memory.getLeftTupleMemory().add(parentLeftTuple);
      while (stream.readShort() == PersisterEnums.RIGHT_TUPLE) {
        LeftTupleSink childSink=(LeftTupleSink)sinks.get(stream.readInt());
        int factHandleId=stream.readInt();
        RightTupleKey key=new RightTupleKey(factHandleId,sink);
        RightTuple rightTuple=context.rightTuples.get(key);
        LeftTuple childLeftTuple=new LeftTuple(parentLeftTuple,rightTuple,childSink,true);
        readLeftTuple(childLeftTuple,context);
      }
      break;
    }
case NodeTypeEnums.EvalConditionNode:
{
    final EvalMemory memory=(EvalMemory)context.wm.getNodeMemory((EvalConditionNode)sink);
    memory.tupleMemory.add(parentLeftTuple);
    while (stream.readShort() == PersisterEnums.LEFT_TUPLE) {
      LeftTupleSink childSink=(LeftTupleSink)sinks.get(stream.readInt());
      LeftTuple childLeftTuple=new LeftTuple(parentLeftTuple,childSink,true);
      readLeftTuple(childLeftTuple,context);
    }
    break;
  }
case NodeTypeEnums.NotNode:
case NodeTypeEnums.ForallNotNode:
{
  BetaMemory memory=(BetaMemory)context.wm.getNodeMemory((BetaNode)sink);
  int type=stream.readShort();
  if (type == PersisterEnums.LEFT_TUPLE_NOT_BLOCKED) {
    memory.getLeftTupleMemory().add(parentLeftTuple);
    while (stream.readShort() == PersisterEnums.LEFT_TUPLE) {
      LeftTupleSink childSink=(LeftTupleSink)sinks.get(stream.readInt());
      LeftTuple childLeftTuple=new LeftTuple(parentLeftTuple,childSink,true);
      readLeftTuple(childLeftTuple,context);
    }
  }
 else {
    int factHandleId=stream.readInt();
    RightTupleKey key=new RightTupleKey(factHandleId,sink);
    RightTuple rightTuple=context.rightTuples.get(key);
    parentLeftTuple.setBlocker(rightTuple);
    rightTuple.addBlocked(parentLeftTuple);
  }
  break;
}
case NodeTypeEnums.ExistsNode:
{
BetaMemory memory=(BetaMemory)context.wm.getNodeMemory((BetaNode)sink);
int type=stream.readShort();
if (type == PersisterEnums.LEFT_TUPLE_NOT_BLOCKED) {
  memory.getLeftTupleMemory().add(parentLeftTuple);
}
 else {
  int factHandleId=stream.readInt();
  RightTupleKey key=new RightTupleKey(factHandleId,sink);
  RightTuple rightTuple=context.rightTuples.get(key);
  parentLeftTuple.setBlocker(rightTuple);
  rightTuple.addBlocked(parentLeftTuple);
  while (stream.readShort() == PersisterEnums.LEFT_TUPLE) {
    LeftTupleSink childSink=(LeftTupleSink)sinks.get(stream.readInt());
    LeftTuple childLeftTuple=new LeftTuple(parentLeftTuple,childSink,true);
    readLeftTuple(childLeftTuple,context);
  }
}
break;
}
case NodeTypeEnums.AccumulateNode:
{
AccumulateMemory memory=(AccumulateMemory)context.wm.getNodeMemory((BetaNode)sink);
memory.betaMemory.getLeftTupleMemory().add(parentLeftTuple);
AccumulateContext accctx=new AccumulateContext();
memory.betaMemory.getCreatedHandles().put(parentLeftTuple,accctx,false);
InternalFactHandle handle=readFactHandle(context);
accctx.result=new RightTuple(handle,(RightTupleSink)sink);
accctx.context=(Serializable)stream.readObject();
accctx.propagated=stream.readBoolean();
short head=-1;
while ((head=stream.readShort()) != PersisterEnums.END) {
switch (head) {
case PersisterEnums.RIGHT_TUPLE:
{
    int factHandleId=stream.readInt();
    RightTupleKey key=new RightTupleKey(factHandleId,sink);
    RightTuple rightTuple=context.rightTuples.get(key);
    new LeftTuple(parentLeftTuple,rightTuple,sink,true);
    break;
  }
case PersisterEnums.LEFT_TUPLE:
{
  LeftTupleSink childSink=(LeftTupleSink)sinks.get(stream.readInt());
  LeftTuple childLeftTuple=new LeftTuple(parentLeftTuple,accctx.result,childSink,true);
  readLeftTuple(childLeftTuple,context);
  break;
}
default :
{
throw new RuntimeDroolsException("Marshalling error. This is a bug. Please contact the development team.");
}
}
}
break;
}
case NodeTypeEnums.CollectNode:
{
CollectMemory memory=(CollectMemory)context.wm.getNodeMemory((BetaNode)sink);
memory.betaMemory.getLeftTupleMemory().add(parentLeftTuple);
CollectContext colctx=new CollectContext();
memory.betaMemory.getCreatedHandles().put(parentLeftTuple,colctx,false);
InternalFactHandle handle=readFactHandle(context);
colctx.resultTuple=new RightTuple(handle,(RightTupleSink)sink);
colctx.propagated=stream.readBoolean();
short head=-1;
while ((head=stream.readShort()) != PersisterEnums.END) {
switch (head) {
case PersisterEnums.RIGHT_TUPLE:
{
int factHandleId=stream.readInt();
RightTupleKey key=new RightTupleKey(factHandleId,sink);
RightTuple rightTuple=context.rightTuples.get(key);
new LeftTuple(parentLeftTuple,rightTuple,sink,true);
break;
}
case PersisterEnums.LEFT_TUPLE:
{
LeftTupleSink childSink=(LeftTupleSink)sinks.get(stream.readInt());
LeftTuple childLeftTuple=new LeftTuple(parentLeftTuple,colctx.resultTuple,childSink,true);
readLeftTuple(childLeftTuple,context);
break;
}
default :
{
throw new RuntimeDroolsException("Marshalling error. This is a bug. Please contact the development team.");
}
}
}
break;
}
case NodeTypeEnums.RightInputAdaterNode:
{
ObjectHashMap memory=(ObjectHashMap)context.wm.getNodeMemory((NodeMemory)sink);
int id=stream.readInt();
long recency=stream.readLong();
InternalFactHandle handle=new DefaultFactHandle(id,parentLeftTuple,recency);
memory.put(parentLeftTuple,handle);
readRightTuples(handle,context);
stream.readShort();
break;
}
case NodeTypeEnums.RuleTerminalNode:
{
int pos=context.terminalTupleMap.size();
context.terminalTupleMap.put(pos,parentLeftTuple);
break;
}
}
}
