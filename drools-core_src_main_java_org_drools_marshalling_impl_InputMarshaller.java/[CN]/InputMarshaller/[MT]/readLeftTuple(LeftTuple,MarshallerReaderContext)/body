{
  ObjectInputStream stream=context.stream;
  Map<Integer,BaseNode> sinks=context.sinks;
  LeftTupleSink sink=parentLeftTuple.getLeftTupleSink();
switch (sink.getType()) {
case NodeTypeEnums.JoinNode:
{
      BetaMemory memory=(BetaMemory)context.wm.getNodeMemory((BetaNode)sink);
      addToLeftMemory(parentLeftTuple,memory);
      while (stream.readShort() == PersisterEnums.RIGHT_TUPLE) {
        LeftTupleSink childSink=(LeftTupleSink)sinks.get(stream.readInt());
        int factHandleId=stream.readInt();
        RightTupleKey key=new RightTupleKey(factHandleId,sink);
        RightTuple rightTuple=context.rightTuples.get(key);
        LeftTuple childLeftTuple=new LeftTuple(parentLeftTuple,rightTuple,childSink,true);
        readLeftTuple(childLeftTuple,context);
      }
      break;
    }
case NodeTypeEnums.EvalConditionNode:
{
    while (stream.readShort() == PersisterEnums.LEFT_TUPLE) {
      LeftTupleSink childSink=(LeftTupleSink)sinks.get(stream.readInt());
      LeftTuple childLeftTuple=new LeftTuple(parentLeftTuple,childSink,true);
      readLeftTuple(childLeftTuple,context);
    }
    break;
  }
case NodeTypeEnums.NotNode:
case NodeTypeEnums.ForallNotNode:
{
  BetaMemory memory=(BetaMemory)context.wm.getNodeMemory((BetaNode)sink);
  int type=stream.readShort();
  if (type == PersisterEnums.LEFT_TUPLE_NOT_BLOCKED) {
    addToLeftMemory(parentLeftTuple,memory);
    while (stream.readShort() == PersisterEnums.LEFT_TUPLE) {
      LeftTupleSink childSink=(LeftTupleSink)sinks.get(stream.readInt());
      LeftTuple childLeftTuple=new LeftTuple(parentLeftTuple,childSink,true);
      readLeftTuple(childLeftTuple,context);
    }
  }
 else {
    int factHandleId=stream.readInt();
    RightTupleKey key=new RightTupleKey(factHandleId,sink);
    RightTuple rightTuple=context.rightTuples.get(key);
    parentLeftTuple.setBlocker(rightTuple);
    rightTuple.addBlocked(parentLeftTuple);
  }
  break;
}
case NodeTypeEnums.ExistsNode:
{
BetaMemory memory=(BetaMemory)context.wm.getNodeMemory((BetaNode)sink);
int type=stream.readShort();
if (type == PersisterEnums.LEFT_TUPLE_NOT_BLOCKED) {
  addToLeftMemory(parentLeftTuple,memory);
}
 else {
  int factHandleId=stream.readInt();
  RightTupleKey key=new RightTupleKey(factHandleId,sink);
  RightTuple rightTuple=context.rightTuples.get(key);
  parentLeftTuple.setBlocker(rightTuple);
  rightTuple.addBlocked(parentLeftTuple);
  while (stream.readShort() == PersisterEnums.LEFT_TUPLE) {
    LeftTupleSink childSink=(LeftTupleSink)sinks.get(stream.readInt());
    LeftTuple childLeftTuple=new LeftTuple(parentLeftTuple,childSink,true);
    readLeftTuple(childLeftTuple,context);
  }
}
break;
}
case NodeTypeEnums.AccumulateNode:
{
AccumulateMemory memory=(AccumulateMemory)context.wm.getNodeMemory((BetaNode)sink);
memory.betaMemory.getLeftTupleMemory().add(parentLeftTuple);
AccumulateContext accctx=new AccumulateContext();
memory.betaMemory.getCreatedHandles().put(parentLeftTuple,accctx,false);
InternalFactHandle handle=readFactHandle(context);
accctx.result=new RightTuple(handle,(RightTupleSink)sink);
accctx.context=(Serializable[])stream.readObject();
accctx.propagated=stream.readBoolean();
short head=-1;
while ((head=stream.readShort()) != PersisterEnums.END) {
switch (head) {
case PersisterEnums.RIGHT_TUPLE:
{
    int factHandleId=stream.readInt();
    RightTupleKey key=new RightTupleKey(factHandleId,sink);
    RightTuple rightTuple=context.rightTuples.get(key);
    new LeftTuple(parentLeftTuple,rightTuple,sink,true);
    break;
  }
case PersisterEnums.LEFT_TUPLE:
{
  LeftTupleSink childSink=(LeftTupleSink)sinks.get(stream.readInt());
  LeftTuple childLeftTuple=new LeftTuple(parentLeftTuple,accctx.result,childSink,true);
  readLeftTuple(childLeftTuple,context);
  break;
}
default :
{
throw new RuntimeDroolsException("Marshalling error. This is a bug. Please contact the development team.");
}
}
}
break;
}
case NodeTypeEnums.RightInputAdaterNode:
{
ObjectHashMap memory=(ObjectHashMap)context.wm.getNodeMemory((NodeMemory)sink);
int id=stream.readInt();
long recency=stream.readLong();
InternalFactHandle handle=new DefaultFactHandle(id,parentLeftTuple,recency,context.wm.getEntryPoints().get(EntryPoint.DEFAULT.getEntryPointId()));
memory.put(parentLeftTuple,handle);
readRightTuples(handle,context);
stream.readShort();
break;
}
case NodeTypeEnums.FromNode:
{
FromMemory memory=(FromMemory)context.wm.getNodeMemory((NodeMemory)sink);
memory.betaMemory.getLeftTupleMemory().add(parentLeftTuple);
Map<Object,RightTuple> matches=new LinkedHashMap<Object,RightTuple>();
memory.betaMemory.getCreatedHandles().put(parentLeftTuple,matches);
while (stream.readShort() == PersisterEnums.FACT_HANDLE) {
InternalFactHandle handle=readFactHandle(context);
context.handles.put(handle.getId(),handle);
readRightTuples(handle,context);
matches.put(handle.getObject(),handle.getFirstRightTuple());
}
while (stream.readShort() == PersisterEnums.RIGHT_TUPLE) {
LeftTupleSink childSink=(LeftTupleSink)sinks.get(stream.readInt());
int factHandleId=stream.readInt();
RightTupleKey key=new RightTupleKey(factHandleId,null);
RightTuple rightTuple=context.rightTuples.get(key);
LeftTuple childLeftTuple=new LeftTuple(parentLeftTuple,rightTuple,childSink,true);
readLeftTuple(childLeftTuple,context);
}
break;
}
case NodeTypeEnums.UnificationNode:
{
while (stream.readShort() == PersisterEnums.LEFT_TUPLE) {
LeftTupleSink childSink=(LeftTupleSink)sinks.get(stream.readInt());
InternalFactHandle handle=readFactHandle(context);
context.handles.put(handle.getId(),handle);
LeftTuple childLeftTuple=new LeftTuple(parentLeftTuple,handle,childSink,true);
readLeftTuple(childLeftTuple,context);
}
break;
}
case NodeTypeEnums.RuleTerminalNode:
{
int pos=context.terminalTupleMap.size();
context.terminalTupleMap.put(pos,parentLeftTuple);
break;
}
}
}
