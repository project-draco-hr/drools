{
  final EvalDescr evalDescr=(EvalDescr)descr;
  final String className="eval" + context.getNextId();
  evalDescr.setClassMethodName(className);
  Map<String,Declaration> decls=context.getDeclarationResolver().getDeclarations(context.getRule());
  AnalysisResult analysis=context.getDialect().analyzeExpression(context,evalDescr,evalDescr.getContent(),new BoundIdentifiers(context.getDeclarationResolver().getDeclarationClasses(decls),context.getPackageBuilder().getGlobals()));
  final BoundIdentifiers usedIdentifiers=analysis.getBoundIdentifiers();
  final Declaration[] declarations=decls.values().toArray(new Declaration[decls.size()]);
  Arrays.sort(declarations,RuleTerminalNode.SortDeclarations.instance);
  final EvalCondition eval=new EvalCondition(declarations);
  final Map vars=createVariableContext(className,(String)evalDescr.getContent(),context,declarations,null,usedIdentifiers.getGlobals());
  generateMethodTemplate("evalMethod",context,vars);
  byte[] bytecode=createEvalBytecode(context,vars);
  registerInvokerBytecode(context,vars,bytecode,eval);
  return eval;
}
