{
  this.selectPossibleMatches(workingMemory,tuple);
  Iterator iterator=null;
  if (this.selectedList != null) {
    iterator=new Iterator(){
      ObjectMatches current=null;
      ObjectMatches next=null;
      ObjectMatches candidate=(ObjectMatches)selectedList.getFirst();
      public final boolean hasNext(){
        boolean hasnext=false;
        if (next == null) {
          while (candidate != null) {
            if ((innerMemory == null) || (innerMemory.isPossibleMatch((MultiLinkedListNodeWrapper)candidate.getChild()))) {
              hasnext=true;
              next=candidate;
              candidate=(ObjectMatches)candidate.getNext();
              break;
            }
            candidate=(ObjectMatches)candidate.getNext();
          }
        }
 else {
          hasnext=true;
        }
        return hasnext;
      }
      public final Object next(){
        if (this.next == null) {
          this.hasNext();
        }
        this.current=this.next;
        this.next=null;
        if (this.current == null) {
          throw new NoSuchElementException("No more elements to return");
        }
        return this.current;
      }
      public final void remove(){
        throw new UnsupportedOperationException("Iterator.remove() should not be used to remove right side objects from right memory.");
      }
    }
;
  }
 else {
    iterator=Collections.EMPTY_LIST.iterator();
  }
  return iterator;
}
