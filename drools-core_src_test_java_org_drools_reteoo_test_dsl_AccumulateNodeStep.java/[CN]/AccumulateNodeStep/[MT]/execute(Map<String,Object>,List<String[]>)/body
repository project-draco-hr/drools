{
  BuildContext buildContext=(BuildContext)context.get("BuildContext");
  if (args.size() >= 1) {
    String[] a=args.get(0);
    String name=a[0];
    String leftInput=a[1];
    String rightInput=a[2];
    String sourceType=a[3];
    String expr=a[4];
    LeftTupleSource leftTupleSource;
    if ("mock".equals(leftInput)) {
      leftTupleSource=Mockito.mock(LeftTupleSource.class);
    }
 else {
      leftTupleSource=(LeftTupleSource)context.get(leftInput);
    }
    ObjectSource rightObjectSource;
    if ("mock".equals(rightInput)) {
      rightObjectSource=Mockito.mock(ObjectSource.class);
    }
 else {
      rightObjectSource=(ObjectSource)context.get(rightInput);
    }
    Pattern sourcePattern;
    Pattern resultPattern;
    try {
      sourcePattern=reteTesterHelper.getPattern(0,sourceType);
      resultPattern=reteTesterHelper.getPattern(buildContext.getNextId(),Number.class.getName());
    }
 catch (    Exception e) {
      throw new IllegalArgumentException("Not possible to process arguments: " + Arrays.toString(a));
    }
    BetaConstraints betaSourceConstraints=new EmptyBetaConstraints();
    AlphaNodeFieldConstraint[] alphaResultConstraint=new AlphaNodeFieldConstraint[0];
    for (int i=1; i < args.size(); i++) {
      a=args.get(i);
      String type=a[0];
      String fieldName=a[1];
      String operator=a[2];
      String val=a[3];
      if ("source".equals(type)) {
        Declaration declr=(Declaration)context.get(val);
        try {
          BetaNodeFieldConstraint sourceBetaConstraint=this.reteTesterHelper.getBoundVariableConstraint(sourcePattern,fieldName,declr,operator);
          betaSourceConstraints=new SingleBetaConstraints(sourceBetaConstraint,buildContext.getRuleBase().getConfiguration());
        }
 catch (        IntrospectionException e) {
          throw new IllegalArgumentException();
        }
      }
 else       if ("result".equals(type)) {
        alphaResultConstraint=new AlphaNodeFieldConstraint[1];
        try {
          alphaResultConstraint[0]=this.reteTesterHelper.getLiteralConstraint(resultPattern,fieldName,operator,val);
        }
 catch (        IntrospectionException e) {
          throw new IllegalArgumentException("Unable to configure alpha constraint: " + Arrays.toString(a),e);
        }
      }
    }
    MVELDialectRuntimeData data=(MVELDialectRuntimeData)buildContext.getRuleBase().getPackage(buildContext.getRule().getPackageName()).getDialectRuntimeRegistry().getDialectData("mvel");
    data.onAdd(null,((InternalRuleBase)buildContext.getRuleBase()).getRootClassLoader());
    NodeTestCase testCase=(NodeTestCase)context.get("TestCase");
    try {
      for (      String imp : testCase.getImports()) {
        if (imp.endsWith(".*")) {
          data.getPackageImports().add(imp.substring(0,imp.lastIndexOf('.')));
        }
 else {
          Class cls=data.getRootClassLoader().loadClass(imp);
          data.getImports().put(cls.getSimpleName(),cls);
        }
      }
    }
 catch (    Exception e) {
      throw new RuntimeException("Unable to load class",e);
    }
    Declaration decl=(Declaration)context.get(expr);
    MVELCompilationUnit compilationUnit=new MVELCompilationUnit(name,expr,new String[]{},new EvaluatorWrapper[]{},new Declaration[]{},new Declaration[]{decl},new String[]{},new String[]{"this","drools","kcontext","rule",decl.getIdentifier()},new String[]{Object.class.getName(),KnowledgeHelper.class.getName(),KnowledgeHelper.class.getName(),Rule.class.getName(),decl.getValueType().getClassType().getName()},4,false);
    AccumulateFunction accFunction=new SumAccumulateFunction();
    Accumulator accumulator=new MVELAccumulatorFunctionExecutor(compilationUnit,accFunction);
    ((MVELCompileable)accumulator).compile(data);
    Accumulate accumulate=new Accumulate(sourcePattern,new Declaration[]{},new Declaration[]{},new Accumulator[]{accumulator},false);
    AccumulateNode accNode=new AccumulateNode(buildContext.getNextId(),leftTupleSource,rightObjectSource,alphaResultConstraint,betaSourceConstraints,new EmptyBetaConstraints(),new Behavior[]{},accumulate,false,buildContext);
    accNode.attach();
    context.put(name,accNode);
  }
 else {
    StringBuilder msgBuilder=new StringBuilder();
    msgBuilder.append("Can not parse AccumulateNode step arguments: \n");
    for (    String[] arg : args) {
      msgBuilder.append("    ");
      msgBuilder.append(Arrays.toString(arg));
      msgBuilder.append("\n");
    }
    throw new IllegalArgumentException(msgBuilder.toString());
  }
}
