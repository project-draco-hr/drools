{
  Accumulate accumulate=accNode.getAccumulate();
  BetaMemory bm=am.getBetaMemory();
  LeftTupleMemory ltm=bm.getLeftTupleMemory();
  RightTupleMemory rtm=bm.getRightTupleMemory();
  ContextEntry[] contextEntry=bm.getContext();
  BetaConstraints constraints=accNode.getRawConstraints();
  if (srcRightTuples.insertSize() > 32 && rtm instanceof AbstractHashTable) {
    ((AbstractHashTable)rtm).ensureCapacity(srcRightTuples.insertSize());
  }
  for (RightTuple rightTuple=srcRightTuples.getInsertFirst(); rightTuple != null; ) {
    RightTuple next=rightTuple.getStagedNext();
    rtm.add(rightTuple);
    if (ltm == null || ltm.size() == 0) {
      rightTuple.clearStaged();
      rightTuple=next;
      continue;
    }
    PropagationContext context=rightTuple.getPropagationContext();
    constraints.updateFromFactHandle(contextEntry,wm,rightTuple.getFactHandle());
    FastIterator leftIt=accNode.getLeftIterator(ltm);
    for (LeftTuple leftTuple=accNode.getFirstLeftTuple(rightTuple,ltm,context,leftIt); leftTuple != null; leftTuple=(LeftTuple)leftIt.next(leftTuple)) {
      if (constraints.isAllowedCachedRight(contextEntry,leftTuple)) {
        final AccumulateContext accctx=(AccumulateContext)leftTuple.getObject();
        addMatch(accNode,accumulate,leftTuple,rightTuple,null,null,wm,am,accctx,true);
        if (leftTuple.getStagedType() == LeftTuple.NONE) {
          trgLeftTuples.addUpdate(leftTuple);
        }
      }
    }
    rightTuple.clearStaged();
    rightTuple=next;
  }
  constraints.resetFactHandle(contextEntry);
}
