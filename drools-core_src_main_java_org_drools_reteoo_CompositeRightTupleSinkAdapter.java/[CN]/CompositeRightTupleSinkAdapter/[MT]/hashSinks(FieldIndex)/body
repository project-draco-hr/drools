{
  final int index=fieldIndex.getIndex();
  final List list=new ArrayList();
  if (this.hashedSinkMap == null) {
    this.hashedSinkMap=new ObjectHashMap();
  }
  for (RightTupleSinkNode sink=this.hashableSinks.getFirst(); sink != null; sink=sink.getNextRightTupleSinkNode()) {
    final AlphaNode alphaNode=(AlphaNode)sink;
    final AlphaNodeFieldConstraint fieldConstraint=alphaNode.getConstraint();
    final LiteralConstraint literalConstraint=(LiteralConstraint)fieldConstraint;
    final Evaluator evaluator=literalConstraint.getEvaluator();
    if (evaluator.getOperator() == Operator.EQUAL && index == literalConstraint.getFieldExtractor().getIndex()) {
      final FieldValue value=literalConstraint.getField();
      list.add(sink);
      this.hashedSinkMap.put(new HashKey(index,value,fieldIndex.getFieldExtractor()),sink);
    }
  }
  for (final java.util.Iterator it=list.iterator(); it.hasNext(); ) {
    final RightTupleSinkNode sink=(RightTupleSinkNode)it.next();
    this.hashableSinks.remove(sink);
  }
  if (this.hashableSinks.isEmpty()) {
    this.hashableSinks=null;
  }
  fieldIndex.setHashed(true);
}
