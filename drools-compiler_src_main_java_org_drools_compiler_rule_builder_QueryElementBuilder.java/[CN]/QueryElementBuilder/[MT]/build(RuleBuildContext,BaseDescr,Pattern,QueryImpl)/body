{
  PatternDescr patternDescr=(PatternDescr)descr;
  Declaration[] params=query.getParameters();
  List<BaseDescr> args=(List<BaseDescr>)patternDescr.getDescrs();
  List<Integer> declrIndexes=new ArrayList<Integer>();
  List<Integer> varIndexes=new ArrayList<Integer>();
  List<Object> arguments=new ArrayList<Object>(params.length);
  for (int i=0; i < params.length; i++) {
    arguments.add(null);
  }
  List<Declaration> requiredDeclarations=new ArrayList<Declaration>();
  ObjectType argsObjectType=ClassObjectType.ObjectArray_ObjectType;
  InternalReadAccessor arrayReader=new SelfReferenceClassFieldReader(Object[].class,"this");
  Pattern pattern=new Pattern(context.getNextPatternId(),0,argsObjectType,null);
  if (!StringUtils.isEmpty(patternDescr.getIdentifier())) {
    if (query.isAbductive()) {
      Declaration declr=context.getDeclarationResolver().getDeclaration(query,patternDescr.getIdentifier());
      if (declr != null && !patternDescr.isUnification()) {
        context.addError(new DescrBuildError(context.getParentDescr(),descr,null,"Duplicate declaration " + patternDescr.getIdentifier() + ", unable to bind abducted value"));
      }
    }
 else {
      context.addError(new DescrBuildError(context.getParentDescr(),descr,null,"Query binding is not supported by non-abductive queries : " + patternDescr.getIdentifier()));
    }
  }
  boolean addAbductiveReturnArgument=query.isAbductive() && !StringUtils.isEmpty(patternDescr.getIdentifier()) && args.size() < params.length;
  if (addAbductiveReturnArgument) {
    ExprConstraintDescr extraDescr=new ExprConstraintDescr(patternDescr.getIdentifier());
    extraDescr.setPosition(patternDescr.getConstraint().getDescrs().size());
    extraDescr.setType(ExprConstraintDescr.Type.POSITIONAL);
    args.add(extraDescr);
  }
  for (int i=0, length=args.size(); i < length; i++) {
    BaseDescr base=args.get(i);
    String expression=null;
    boolean isPositional=false;
    boolean isBinding=false;
    BindingDescr bind=null;
    ConstraintConnectiveDescr result=null;
    if (base instanceof BindingDescr) {
      bind=(BindingDescr)base;
      expression=bind.getVariable() + (bind.isUnification() ? " := " : " : ") + bind.getExpression();
      isBinding=true;
    }
 else {
      if (base instanceof ExprConstraintDescr) {
        ExprConstraintDescr ecd=(ExprConstraintDescr)base;
        expression=ecd.getExpression();
        isPositional=ecd.getType() == ExprConstraintDescr.Type.POSITIONAL;
      }
 else {
        expression=base.getText();
      }
      result=parseExpression(context,patternDescr,expression);
      if (result == null) {
        context.addError(new DescrBuildError(context.getParentDescr(),descr,null,"Unable to parse constraint: \n" + expression));
        continue;
      }
      isBinding=result.getDescrs().size() == 1 && result.getDescrs().get(0) instanceof BindingDescr;
      if (isBinding) {
        bind=(BindingDescr)result.getDescrs().get(0);
      }
    }
    if ((!isPositional) && (!isBinding)) {
      context.addError(new DescrBuildError(context.getParentDescr(),descr,null,"Query's must use positional or bindings, not field constraints:\n" + expression));
      continue;
    }
 else     if (isPositional && isBinding) {
      context.addError(new DescrBuildError(context.getParentDescr(),descr,null,"Query's can't use positional bindings:\n" + expression));
      continue;
    }
 else     if (isPositional) {
      processPositional(context,query,params,declrIndexes,varIndexes,arguments,requiredDeclarations,arrayReader,pattern,base,expression,result);
    }
 else {
      processBinding(context,descr,params,declrIndexes,varIndexes,arguments,requiredDeclarations,arrayReader,pattern,bind,result);
    }
  }
  Declaration[] declrsArray=requiredDeclarations.toArray(new Declaration[requiredDeclarations.size()]);
  int[] declrIndexArray=new int[declrIndexes.size()];
  for (int i=0; i < declrsArray.length; i++) {
    declrIndexArray[i]=declrIndexes.get(i);
  }
  int[] varIndexesArray=new int[varIndexes.size()];
  for (int i=0; i < varIndexesArray.length; i++) {
    varIndexesArray[i]=varIndexes.get(i);
  }
  for (  Integer declIndex : declrIndexes) {
    Declaration knownInputArg=(Declaration)arguments.get(declIndex);
    Declaration formalArgument=query.getParameters()[declIndex];
    Class actual=knownInputArg.getExtractor().getExtractToClass();
    Class formal=formalArgument.getExtractor().getExtractToClass();
    if (!isCompatible(actual,formal) && !isCompatible(formal,actual)) {
      context.addError(new DescrBuildError(context.getParentDescr(),descr,null,"Query is being invoked with known argument of type " + actual + " at position "+ declIndex+ ", but the expected query argument is of type "+ formal));
    }
  }
  return new QueryElement(pattern,query.getName(),arguments.toArray(new Object[arguments.size()]),declrsArray,declrIndexArray,varIndexesArray,!patternDescr.isQuery(),query.isAbductive());
}
