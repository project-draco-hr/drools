{
  ColumnDescr column=new ColumnDescr(pattern.factType);
  column.setIdentifier(pattern.boundName);
  ce.addDescr(column);
  for (int i=0; i < pattern.constraints.length; i++) {
    Constraint constr=pattern.constraints[i];
    if (constr.fieldBinding != null) {
      FieldBindingDescr fieldDescr=new FieldBindingDescr(constr.fieldName,constr.fieldBinding);
      column.addDescr(fieldDescr);
    }
    if (constr.constraintValueType == Constraint.TYPE_PREDICATE) {
      PredicateDescr predicateDescr=new PredicateDescr(constr.value);
      column.addDescr(predicateDescr);
    }
 else {
      FieldConstraintDescr constrDescr=new FieldConstraintDescr(constr.fieldName);
      constrDescr.addRestriction(this.getFieldRestriction(constr.constraintValueType,constr.operator,constr.value));
      if (constr.connectives != null) {
        for (int j=0; j < constr.connectives.length; j++) {
          ConnectiveConstraint conn=constr.connectives[j];
          if (conn.isANDConnective()) {
            RestrictionConnectiveDescr andDescr=new RestrictionConnectiveDescr(RestrictionConnectiveDescr.AND);
            constrDescr.addRestriction(andDescr);
          }
 else           if (conn.isORConnective()) {
            RestrictionConnectiveDescr orDescr=new RestrictionConnectiveDescr(RestrictionConnectiveDescr.OR);
            constrDescr.addRestriction(orDescr);
          }
 else {
            throw new IllegalStateException("Unknown connective type/operator: [" + conn.operator + "]");
          }
          constrDescr.addRestriction(this.getFieldRestriction(conn.constraintValueType,conn.operator,conn.value));
        }
      }
      column.addDescr(constrDescr);
    }
  }
}
