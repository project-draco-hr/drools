{
  final PatternDescr pattern=new PatternDescr(factPattern.factType);
  pattern.setIdentifier(factPattern.boundName);
  ce.addDescr(pattern);
  for (int i=0; i < factPattern.constraints.length; i++) {
    final Constraint constr=factPattern.constraints[i];
    if (constr.fieldBinding != null) {
      final FieldBindingDescr fieldDescr=new FieldBindingDescr(constr.fieldName,constr.fieldBinding);
      pattern.addConstraint(fieldDescr);
    }
    if (constr.constraintValueType == IConstraint.TYPE_PREDICATE) {
      final PredicateDescr predicateDescr=new PredicateDescr(constr.value);
      pattern.addConstraint(predicateDescr);
    }
 else {
      final FieldConstraintDescr constrDescr=new FieldConstraintDescr(constr.fieldName);
      constrDescr.addRestriction(this.getFieldRestriction(constr.constraintValueType,constr.operator,constr.value));
      if (constr.connectives != null) {
        for (int j=0; j < constr.connectives.length; j++) {
          final ConnectiveConstraint conn=constr.connectives[j];
          if (conn.isANDConnective()) {
            final RestrictionConnectiveDescr andDescr=new RestrictionConnectiveDescr(RestrictionConnectiveDescr.AND);
            constrDescr.addRestriction(andDescr);
          }
 else           if (conn.isORConnective()) {
            final RestrictionConnectiveDescr orDescr=new RestrictionConnectiveDescr(RestrictionConnectiveDescr.OR);
            constrDescr.addRestriction(orDescr);
          }
 else {
            throw new IllegalStateException("Unknown connective type/operator: [" + conn.operator + "]");
          }
          constrDescr.addRestriction(this.getFieldRestriction(conn.constraintValueType,conn.operator,conn.value));
        }
      }
      pattern.addConstraint(constrDescr);
    }
  }
}
