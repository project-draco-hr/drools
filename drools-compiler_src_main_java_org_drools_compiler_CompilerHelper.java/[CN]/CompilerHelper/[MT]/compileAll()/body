{
  if (this.generatedClassList.isEmpty()) {
    return;
  }
  final String[] classes=new String[this.generatedClassList.size()];
  this.generatedClassList.toArray(classes);
  final CompilationResult result=this.compiler.compile(classes,this.src,this.packageStoreWrapper,this.pkg.getPackageCompilationData().getClassLoader());
  if (result.getErrors().length > 0) {
    for (int i=0; i < result.getErrors().length; i++) {
      final CompilationProblem err=result.getErrors()[i];
      final ErrorHandler handler=(ErrorHandler)this.errorHandlers.get(err.getFileName());
      if (handler instanceof RuleErrorHandler) {
        final RuleErrorHandler rh=(RuleErrorHandler)handler;
      }
      handler.addError(err);
    }
    final Collection errors=this.errorHandlers.values();
    for (final Iterator iter=errors.iterator(); iter.hasNext(); ) {
      final ErrorHandler handler=(ErrorHandler)iter.next();
      if (handler.isInError()) {
        if (!(handler instanceof RuleInvokerErrorHandler)) {
          this.results.add(handler.getError());
        }
 else {
          System.err.println("Warning: An error occurred compiling a semantic invoker. Errors should have been reported elsewhere.");
        }
      }
    }
  }
}
