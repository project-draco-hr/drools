{
  InternalKnowledgePackage pkg=new KnowledgePackageImpl("pkg1");
  final RuleDescr ruleDescr=new RuleDescr("rule 1");
  KnowledgeBuilderImpl pkgBuilder=new KnowledgeBuilderImpl(pkg);
  final KnowledgeBuilderConfigurationImpl conf=pkgBuilder.getBuilderConfiguration();
  PackageRegistry pkgRegistry=pkgBuilder.getPackageRegistry(pkg.getName());
  MVELDialect mvelDialect=(MVELDialect)pkgRegistry.getDialectCompiletimeRegistry().getDialect("mvel");
  final InstrumentedBuildContent context=new InstrumentedBuildContent(pkgBuilder,ruleDescr,pkgRegistry.getDialectCompiletimeRegistry(),pkg,mvelDialect);
  final InstrumentedDeclarationScopeResolver declarationResolver=new InstrumentedDeclarationScopeResolver();
  final InternalReadAccessor extractor=store.getReader(Cheese.class,"price",getClass().getClassLoader());
  final Pattern patternA=new Pattern(0,new ClassObjectType(Cheese.class));
  final Pattern patternB=new Pattern(1,new ClassObjectType(Cheese.class));
  final Declaration a=new Declaration("a",extractor,patternA);
  final Declaration b=new Declaration("b",extractor,patternB);
  context.getBuildStack().add(patternA);
  context.getBuildStack().add(patternB);
  final Map map=new HashMap();
  map.put("a",a);
  map.put("b",b);
  declarationResolver.setDeclarations(map);
  context.setDeclarationResolver(declarationResolver);
  final PredicateDescr predicateDescr=new PredicateDescr();
  predicateDescr.setContent("a == b");
  final MVELPredicateBuilder builder=new MVELPredicateBuilder();
  final Declaration[] previousDeclarations=new Declaration[]{a};
  final Declaration[] localDeclarations=new Declaration[]{b};
  final PredicateConstraint predicate=new PredicateConstraint(null,localDeclarations);
  AnalysisResult analysis=context.getDialect().analyzeExpression(context,predicateDescr,predicateDescr.getContent(),new BoundIdentifiers(declarationResolver.getDeclarationClasses((RuleImpl)null),new HashMap(),null,Cheese.class));
  builder.build(context,new BoundIdentifiers(declarationResolver.getDeclarationClasses((RuleImpl)null),new HashMap()),previousDeclarations,localDeclarations,predicate,predicateDescr,analysis);
  ((MVELPredicateExpression)predicate.getPredicateExpression()).compile((MVELDialectRuntimeData)pkgRegistry.getDialectRuntimeRegistry().getDialectData("mvel"));
  InternalKnowledgeBase kBase=(InternalKnowledgeBase)KnowledgeBaseFactory.newKnowledgeBase();
  StatefulKnowledgeSessionImpl ksession=(StatefulKnowledgeSessionImpl)kBase.newStatefulKnowledgeSession();
  InternalWorkingMemory wm=ksession;
  final Cheese stilton=new Cheese("stilton",10);
  final Cheese cheddar=new Cheese("cheddar",10);
  MockLeftTupleSink sink=new MockLeftTupleSink();
  final InternalFactHandle f0=(InternalFactHandle)wm.insert(cheddar);
  final InternalFactHandle f1=(InternalFactHandle)wm.insert(stilton);
  final LeftTupleImpl tuple=new LeftTupleImpl(f0,sink,true);
  f0.removeLeftTuple(tuple);
  final PredicateContextEntry predicateContext=(PredicateContextEntry)predicate.createContextEntry();
  predicateContext.leftTuple=tuple;
  predicateContext.workingMemory=wm;
  assertTrue(predicate.isAllowedCachedLeft(predicateContext,f1));
  cheddar.setPrice(9);
  wm.update(f0,cheddar);
  assertFalse(predicate.isAllowedCachedLeft(predicateContext,f1));
}
