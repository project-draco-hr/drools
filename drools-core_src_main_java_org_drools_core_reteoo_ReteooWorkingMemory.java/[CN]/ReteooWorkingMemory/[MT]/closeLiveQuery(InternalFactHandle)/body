{
  try {
    startOperation();
    this.ruleBase.readLock();
    this.lock.lock();
    final PropagationContext pCtx=new PropagationContextImpl(getNextPropagationIdCounter(),PropagationContext.INSERTION,null,null,factHandle,getEntryPoint());
    if (this.ruleBase.getConfiguration().isPhreakEnabled()) {
      LeftInputAdapterNode lian=(LeftInputAdapterNode)factHandle.getFirstLeftTuple().getLeftTupleSink().getLeftTupleSource();
      LiaNodeMemory lmem=(LiaNodeMemory)getNodeMemory((MemoryFactory)lian);
      SegmentMemory lsmem=lmem.getSegmentMemory();
      LeftTuple childLeftTuple=factHandle.getFirstLeftTuple();
      LeftInputAdapterNode.doDeleteObject(childLeftTuple,childLeftTuple.getPropagationContext(),lsmem,this,lian,false,lmem);
      List<PathMemory> rmems=lmem.getSegmentMemory().getPathMemories();
      for (int i=0, length=rmems.size(); i < length; i++) {
        PathMemory rm=rmems.get(i);
        RuleInstanceAgendaItem evaluator=agenda.createRuleInstanceAgendaItem(Integer.MAX_VALUE,rm,(TerminalNode)rm.getNetworkNode());
        evaluator.getRuleExecutor().evaluateNetwork(this,0,-1);
      }
    }
 else {
      getEntryPointNode().retractQuery(factHandle,pCtx,this);
      pCtx.evaluateActionQueue(this);
    }
    getFactHandleFactory().destroyFactHandle(factHandle);
  }
  finally {
    this.lock.unlock();
    this.ruleBase.readUnlock();
    endOperation();
  }
}
