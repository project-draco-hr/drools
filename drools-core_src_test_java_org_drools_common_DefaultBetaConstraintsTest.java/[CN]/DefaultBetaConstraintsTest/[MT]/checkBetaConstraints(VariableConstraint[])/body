{
  RuleBaseConfiguration config=new RuleBaseConfiguration();
  int depth=config.getCompositeKeyDepth();
  List list=new ArrayList();
  for (int i=0; i < constraints.length && list.size() < depth; i++) {
    if (constraints[i].getEvaluator().getOperator() == Operator.EQUAL) {
      list.add(new Integer(i));
    }
  }
  int[] indexedPositions=new int[list.size()];
  for (int i=0; i < list.size(); i++) {
    indexedPositions[i]=((Integer)list.get(i)).intValue();
  }
  DefaultBetaConstraints betaConstraints=new DefaultBetaConstraints(constraints,config);
  assertEquals((indexedPositions.length > 0),betaConstraints.isIndexed());
  assertEquals(indexedPositions.length - 1,betaConstraints.getIndexCount());
  BetaMemory betaMemory=betaConstraints.createBetaMemory(config);
  if (indexedPositions.length > 0) {
    TupleIndexHashTable tupleHashTable=(TupleIndexHashTable)betaMemory.getTupleMemory();
    assertTrue(tupleHashTable.isIndexed());
    Index index=tupleHashTable.getIndex();
    for (int i=0; i < indexedPositions.length; i++) {
      checkSameConstraintForIndex(constraints[indexedPositions[i]],index.getFieldIndex(i));
    }
    FactHandleIndexHashTable factHashTable=(FactHandleIndexHashTable)betaMemory.getFactHandleMemory();
    assertTrue(factHashTable.isIndexed());
    index=factHashTable.getIndex();
    for (int i=0; i < indexedPositions.length; i++) {
      checkSameConstraintForIndex(constraints[indexedPositions[i]],index.getFieldIndex(i));
    }
  }
 else {
    TupleHashTable tupleHashTable=(TupleHashTable)betaMemory.getTupleMemory();
    assertFalse(tupleHashTable.isIndexed());
    FactHashTable factHashTable=(FactHashTable)betaMemory.getFactHandleMemory();
    assertFalse(factHashTable.isIndexed());
  }
}
