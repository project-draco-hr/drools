{
  final AccumulateDescr accumDescr=(AccumulateDescr)descr;
  final PatternBuilder patternBuilder=(PatternBuilder)context.getDialect().getBuilder(PatternDescr.class);
  final Pattern sourcePattern=(Pattern)patternBuilder.build(context,accumDescr.getInputPattern());
  if (sourcePattern == null) {
    return null;
  }
  MVELDialect dialect=(MVELDialect)context.getDialect();
  final Declaration[] sourceDeclArr=(Declaration[])sourcePattern.getOuterDeclarations().values().toArray(new Declaration[0]);
  final DroolsMVELFactory factory=new DroolsMVELFactory(context.getDeclarationResolver().getDeclarations(),sourcePattern.getOuterDeclarations(),context.getPkg().getGlobals());
  factory.setNextFactory(dialect.getClassImportResolverFactory());
  Accumulator accumulator=null;
  Declaration[] declarations=null;
  if (accumDescr.isExternalFunction()) {
    final Dialect.AnalysisResult analysis=dialect.analyzeExpression(context,accumDescr,accumDescr.getExpression());
    int size=analysis.getBoundIdentifiers()[0].size();
    declarations=new Declaration[size];
    for (int i=0; i < size; i++) {
      declarations[i]=context.getDeclarationResolver().getDeclaration((String)analysis.getBoundIdentifiers()[0].get(i));
    }
    final Serializable expression=MVEL.compileExpression((String)accumDescr.getExpression(),dialect.getClassImportResolverFactory().getImportedClasses());
    AccumulateFunction function=context.getConfiguration().getAccumulateFunction(accumDescr.getFunctionIdentifier());
    accumulator=new MVELAccumulatorFunctionExecutor(factory,expression,function);
  }
 else {
    final MVELAnalysisResult initCodeAnalysis=(MVELAnalysisResult)dialect.analyzeBlock(context,accumDescr,accumDescr.getInitCode());
    final MVELAnalysisResult actionCodeAnalysis=(MVELAnalysisResult)dialect.analyzeBlock(context,accumDescr,null,accumDescr.getActionCode(),initCodeAnalysis.getMvelVariables());
    final MVELAnalysisResult resultCodeAnalysis=(MVELAnalysisResult)dialect.analyzeExpression(context,accumDescr,accumDescr.getResultCode(),initCodeAnalysis.getMvelVariables());
    final List requiredDeclarations=new ArrayList(initCodeAnalysis.getBoundIdentifiers()[0]);
    requiredDeclarations.addAll(actionCodeAnalysis.getBoundIdentifiers()[0]);
    requiredDeclarations.addAll(resultCodeAnalysis.getBoundIdentifiers()[0]);
    if (accumDescr.getReverseCode() != null) {
      final Dialect.AnalysisResult reverseCodeAnalysis=context.getDialect().analyzeBlock(context,accumDescr,accumDescr.getActionCode());
      requiredDeclarations.addAll(reverseCodeAnalysis.getBoundIdentifiers()[0]);
    }
    declarations=new Declaration[requiredDeclarations.size()];
    for (int i=0, size=requiredDeclarations.size(); i < size; i++) {
      declarations[i]=context.getDeclarationResolver().getDeclaration((String)requiredDeclarations.get(i));
    }
    final Serializable init=dialect.compile((String)accumDescr.getInitCode(),initCodeAnalysis,null,context);
    final Serializable action=dialect.compile((String)accumDescr.getActionCode(),actionCodeAnalysis,null,context);
    Serializable reverse=null;
    if (accumDescr.getReverseCode() != null) {
      reverse=dialect.compile((String)accumDescr.getReverseCode(),resultCodeAnalysis,null,context);
    }
    final Serializable result=dialect.compile((String)accumDescr.getResultCode(),resultCodeAnalysis,null,context);
    accumulator=new MVELAccumulator(factory,init,action,reverse,result);
  }
  final Accumulate accumulate=new Accumulate(sourcePattern,declarations,sourceDeclArr,accumulator);
  return accumulate;
}
