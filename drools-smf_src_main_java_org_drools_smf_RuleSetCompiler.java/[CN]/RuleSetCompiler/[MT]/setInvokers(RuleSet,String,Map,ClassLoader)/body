{
  Rule[] rules=ruleSet.getRules();
  Rule rule=null;
  SemanticInvokeable component=null;
  String name=null;
  String semanticPackageName=null;
  try {
    for (int i=0; i < rules.length; i++) {
      rule=rules[i];
      Condition[] conditions=(Condition[])rule.getConditions().toArray(new Condition[rule.getConditions().size()]);
      for (int j=0; j < conditions.length; j++) {
        if (!(conditions[j] instanceof SemanticInvokeable)) {
          continue;
        }
        component=(SemanticInvokeable)conditions[j];
        name=component.getName();
        semanticPackageName=packageName + "." + component.getSemanticType();
        component.setInvoker((Invoker)classLoader.loadClass(semanticPackageName + "." + ruleMap.get(rule)+ "Invoker$"+ name.toUpperCase().charAt(0)+ name.substring(1)+ "Invoker").newInstance());
      }
      if (rule.getConsequence() instanceof SemanticInvokeable) {
        component=(SemanticInvokeable)rule.getConsequence();
        name=component.getName();
        semanticPackageName=packageName + "." + component.getSemanticType();
        component.setInvoker((Invoker)classLoader.loadClass(semanticPackageName + "." + ruleMap.get(rule)+ "Invoker$"+ name.toUpperCase().charAt(0)+ name.substring(1)+ "Invoker").newInstance());
      }
    }
  }
 catch (  InstantiationException e) {
    throw new IntegrationException("Unable to bind RuleSet '" + ruleSet.getName() + "' component to Class Method: "+ e.getMessage(),e);
  }
catch (  IllegalAccessException e) {
    throw new IntegrationException("Unable to bind RuleSet '" + ruleSet.getName() + "'  component to Class Method: "+ e.getMessage(),e);
  }
catch (  ClassNotFoundException e) {
    throw new IntegrationException("Unable to bind RuleSet '" + ruleSet.getName() + "'  component to Class Method: "+ e.getMessage(),e);
  }
}
