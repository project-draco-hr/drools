{
  ByteArrayClassLoader byteArrayClassLoader=cache.getByteArrayClassLoader();
  Map<Class<?>,ClassFieldInspector> inspectors=cache.getInspectors();
  try {
    if (SELF_REFERENCE_FIELD.equals(fieldName)) {
      return new SelfReferenceClassFieldReader(clazz,fieldName);
    }
 else     if (fieldName.indexOf('.') > -1 || fieldName.indexOf('[') > -1) {
      return new MVELClassFieldReader(clazz,fieldName,cache);
    }
 else {
      ClassFieldInspector inspector=inspectors.get(clazz);
      if (inspector == null) {
        inspector=new ClassFieldInspector(clazz);
        inspectors.put(clazz,inspector);
      }
      final Class<?> fieldType=(Class<?>)inspector.getFieldTypes().get(fieldName);
      final Method getterMethod=(Method)inspector.getGetterMethods().get(fieldName);
      if (fieldType != null && getterMethod != null) {
        final String className=ClassFieldAccessorFactory.BASE_PACKAGE + "/" + Type.getInternalName(clazz)+ Math.abs(System.identityHashCode(clazz))+ "$"+ getterMethod.getName();
        final byte[] bytes=dumpReader(clazz,className,getterMethod,fieldType,clazz.isInterface());
        final Class<?> newClass=byteArrayClassLoader.defineClass(className.replace('/','.'),bytes,PROTECTION_DOMAIN);
        final Integer index=(Integer)inspector.getFieldNames().get(fieldName);
        final ValueType valueType=ValueType.determineValueType(fieldType);
        final Object[] params={index,fieldType,valueType};
        return (BaseClassFieldReader)newClass.getConstructors()[0].newInstance(params);
      }
 else {
        throw new RuntimeDroolsException("Field/method '" + fieldName + "' not found for class '"+ clazz.getName()+ "'");
      }
    }
  }
 catch (  final RuntimeDroolsException e) {
    throw e;
  }
catch (  final Exception e) {
    e.printStackTrace();
    throw new RuntimeDroolsException(e);
  }
}
