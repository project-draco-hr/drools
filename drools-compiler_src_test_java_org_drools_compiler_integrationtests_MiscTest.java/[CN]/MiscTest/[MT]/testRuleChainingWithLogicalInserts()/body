{
  KnowledgeBuilder kbuilder=KnowledgeBuilderFactory.newKnowledgeBuilder();
  kbuilder.add(ResourceFactory.newClassPathResource("test_RuleChaining.drl",getClass()),ResourceType.DRL);
  KnowledgeBuilderErrors errors=kbuilder.getErrors();
  if (errors.size() > 0) {
    for (    KnowledgeBuilderError error : errors) {
      logger.warn(error.toString());
    }
    throw new IllegalArgumentException("Could not parse knowledge.");
  }
  assertFalse(kbuilder.hasErrors());
  KnowledgeBase kbase=KnowledgeBaseFactory.newKnowledgeBase();
  kbase.addKnowledgePackages(kbuilder.getKnowledgePackages());
  StatefulKnowledgeSession ksession=createKnowledgeSession(kbase);
  org.kie.api.event.rule.WorkingMemoryEventListener wml=Mockito.mock(org.kie.api.event.rule.WorkingMemoryEventListener.class);
  org.kie.api.event.rule.AgendaEventListener ael=Mockito.mock(org.kie.api.event.rule.AgendaEventListener.class);
  ksession.addEventListener(wml);
  ksession.addEventListener(ael);
  int fired=ksession.fireAllRules();
  assertEquals(3,fired);
  ArgumentCaptor<org.kie.api.event.rule.AfterMatchFiredEvent> actvs=ArgumentCaptor.forClass(org.kie.api.event.rule.AfterMatchFiredEvent.class);
  verify(ael,times(3)).afterMatchFired(actvs.capture());
  List<org.kie.api.event.rule.AfterMatchFiredEvent> values=actvs.getAllValues();
  assertThat(values.get(0).getMatch().getRule().getName(),is("init"));
  assertThat(values.get(1).getMatch().getRule().getName(),is("r1"));
  assertThat(values.get(2).getMatch().getRule().getName(),is("r2"));
  verify(ael,never()).matchCancelled(any(org.kie.api.event.rule.MatchCancelledEvent.class));
  verify(wml,times(2)).objectInserted(any(org.kie.api.event.rule.ObjectInsertedEvent.class));
  verify(wml,never()).objectDeleted(any(ObjectDeletedEvent.class));
}
