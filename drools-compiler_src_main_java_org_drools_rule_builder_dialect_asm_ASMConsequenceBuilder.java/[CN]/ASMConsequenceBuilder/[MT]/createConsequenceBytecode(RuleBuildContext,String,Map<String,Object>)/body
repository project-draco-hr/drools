{
  final String packageName=(String)consequenceContext.get("package");
  final String invokerClassName=(String)consequenceContext.get("invokerClassName");
  final String ruleClassName=(String)consequenceContext.get("ruleClassName");
  final String internalRuleClassName=(packageName + "." + ruleClassName).replace(".","/");
  final String methodName=(String)consequenceContext.get("methodName");
  final String name=(String)consequenceContext.get("consequenceName");
  final Integer hashCode=(Integer)consequenceContext.get("hashCode");
  final Declaration[] declarations=(Declaration[])consequenceContext.get("declarations");
  final String[] declarationTypes=(String[])consequenceContext.get("declarationTypes");
  final String[] globals=(String[])consequenceContext.get("globals");
  final String[] globalTypes=(String[])consequenceContext.get("globalTypes");
  final Boolean[] notPatterns=(Boolean[])consequenceContext.get("notPatterns");
  final ClassGenerator generator=new ClassGenerator(packageName + "." + invokerClassName,ruleContext.getPackageBuilder().getRootClassLoader(),ruleContext.getDialect("java").getPackageRegistry().getTypeResolver()).setInterfaces(Consequence.class,CompiledInvoker.class);
  generator.addStaticField(ACC_PRIVATE + ACC_FINAL,"serialVersionUID",Long.TYPE,CONSEQUENCE_SERIAL_UID).addField(ACC_PRIVATE + ACC_FINAL,"consequenceName",String.class);
  generator.addDefaultConstructor(new ClassGenerator.MethodBody(){
    public void body(    MethodVisitor mv){
      mv.visitVarInsn(ALOAD,0);
      push(name);
      putField("consequenceName",String.class);
    }
  }
).addMethod(ACC_PUBLIC,"getName",generator.methodDescr(String.class),new ClassGenerator.MethodBody(){
    public void body(    MethodVisitor mv){
      mv.visitVarInsn(ALOAD,0);
      getField("consequenceName",String.class);
      mv.visitInsn(ARETURN);
    }
  }
).addMethod(ACC_PUBLIC,"hashCode",generator.methodDescr(Integer.TYPE),new ClassGenerator.MethodBody(){
    public void body(    MethodVisitor mv){
      push(hashCode);
      mv.visitInsn(IRETURN);
    }
  }
).addMethod(ACC_PUBLIC,"getMethodBytecode",generator.methodDescr(List.class),new ClassGenerator.MethodBody(){
    public void body(    MethodVisitor mv){
      mv.visitVarInsn(ALOAD,0);
      invokeVirtual(Object.class,"getClass",Class.class);
      push(ruleClassName);
      push(packageName);
      push(methodName);
      push(internalRuleClassName + ".class");
      invokeStatic(Rule.class,"getMethodBytecode",List.class,Class.class,String.class,String.class,String.class,String.class);
      mv.visitInsn(ARETURN);
    }
  }
).addMethod(ACC_PUBLIC,"equals",generator.methodDescr(Boolean.TYPE,Object.class),new ClassGenerator.MethodBody(){
    public void body(    MethodVisitor mv){
      Label l1=new Label();
      Label l2=new Label();
      mv.visitVarInsn(ALOAD,1);
      mv.visitJumpInsn(IFNULL,l1);
      mv.visitVarInsn(ALOAD,1);
      instanceOf(CompiledInvoker.class);
      mv.visitJumpInsn(IFNE,l2);
      mv.visitLabel(l1);
      mv.visitInsn(ICONST_0);
      mv.visitInsn(IRETURN);
      mv.visitLabel(l2);
      mv.visitVarInsn(ALOAD,0);
      invokeThis("getMethodBytecode",List.class);
      mv.visitVarInsn(ALOAD,1);
      cast(CompiledInvoker.class);
      invokeInterface(CompiledInvoker.class,"getMethodBytecode",List.class);
      invokeStatic(MethodComparator.class,"compareBytecode",Boolean.TYPE,List.class,List.class);
      mv.visitInsn(IRETURN);
    }
  }
).addMethod(ACC_PUBLIC,"evaluate",generator.methodDescr(null,KnowledgeHelper.class,WorkingMemory.class),new String[]{"java/lang/Exception"},new ClassGenerator.MethodBody(){
    public void body(    MethodVisitor mv){
      mv.visitVarInsn(ALOAD,1);
      invokeInterface(KnowledgeHelper.class,"getTuple",Tuple.class);
      mv.visitVarInsn(ASTORE,3);
      mv.visitVarInsn(ALOAD,1);
      invokeInterface(KnowledgeHelper.class,"getActivation",Activation.class);
      invokeInterface(Activation.class,"getTuple",LeftTuple.class);
      invokeInterface(LeftTuple.class,"getLeftTupleSink",LeftTupleSink.class);
      cast(RuleTerminalNode.class);
      invokeVirtual(RuleTerminalNode.class,"getDeclarations",Declaration[].class);
      mv.visitVarInsn(ASTORE,4);
      int[] paramsPos=new int[declarations.length];
      int offset=5;
      for (int i=0; i < declarations.length; i++) {
        int factPos=offset;
        int objPos=++offset;
        paramsPos[i]=factPos;
        mv.visitVarInsn(ALOAD,3);
        mv.visitVarInsn(ALOAD,4);
        push(i);
        mv.visitInsn(AALOAD);
        invokeInterface(Tuple.class,"get",InternalFactHandle.class,Declaration.class);
        mv.visitVarInsn(ASTORE,factPos);
        mv.visitVarInsn(ALOAD,4);
        push(i);
        mv.visitInsn(AALOAD);
        mv.visitVarInsn(ALOAD,2);
        cast(InternalWorkingMemory.class);
        mv.visitVarInsn(ALOAD,factPos);
        invokeInterface(InternalFactHandle.class,"getObject",Object.class);
        String readMethod=declarations[i].getNativeReadMethod().getName();
        boolean isObject=readMethod.equals("getValue");
        String returnedType=isObject ? "Ljava/lang/Object;" : typeDescr(declarationTypes[i]);
        mv.visitMethodInsn(INVOKEVIRTUAL,"org/drools/rule/Declaration",readMethod,"(Lorg/drools/common/InternalWorkingMemory;Ljava/lang/Object;)" + returnedType);
        if (isObject)         mv.visitTypeInsn(CHECKCAST,interalName(declarationTypes[i]));
        offset+=store(objPos,declarationTypes[i]);
        if (notPatterns[i]) {
          mv.visitVarInsn(ALOAD,1);
          invokeInterface(KnowledgeHelper.class,"getWorkingMemory",WorkingMemory.class);
          loadAsObject(objPos);
          invokeInterface(WorkingMemory.class,"getFactHandle",FactHandle.class,Object.class);
          cast(InternalFactHandle.class);
          mv.visitVarInsn(ASTORE,factPos);
        }
      }
      StringBuilder consequenceMethodDescr=new StringBuilder("(Lorg/drools/spi/KnowledgeHelper;");
      mv.visitVarInsn(ALOAD,1);
      for (int i=0; i < declarations.length; i++) {
        load(paramsPos[i] + 1);
        mv.visitVarInsn(ALOAD,paramsPos[i]);
        consequenceMethodDescr.append(typeDescr(declarationTypes[i]) + "Lorg/drools/FactHandle;");
      }
      for (int i=0; i < globals.length; i++) {
        mv.visitVarInsn(ALOAD,2);
        push(globals[i]);
        invokeInterface(WorkingMemory.class,"getGlobal",Object.class,String.class);
        mv.visitTypeInsn(CHECKCAST,interalName(globalTypes[i]));
        consequenceMethodDescr.append(typeDescr(globalTypes[i]));
      }
      consequenceMethodDescr.append(")V");
      mv.visitMethodInsn(INVOKESTATIC,internalRuleClassName,methodName,consequenceMethodDescr.toString());
      mv.visitInsn(RETURN);
    }
  }
);
  return generator.generateBytecode();
}
