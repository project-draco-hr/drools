{
  final GroupElement cloned=(GroupElement)and.clone();
  processTree(cloned);
  cloned.pack();
  GroupElement[] ands=null;
  if (cloned.isAnd()) {
    ands=new GroupElement[]{cloned};
  }
 else   if (cloned.isOr()) {
    ands=new GroupElement[cloned.getChildren().size()];
    int i=0;
    for (final Iterator it=cloned.getChildren().iterator(); it.hasNext(); ) {
      final RuleConditionElement branch=(RuleConditionElement)it.next();
      if ((branch instanceof GroupElement) && (((GroupElement)branch).isAnd())) {
        ands[i++]=(GroupElement)branch;
      }
 else {
        ands[i]=GroupElementFactory.newAndInstance();
        ands[i].addChild(branch);
        i++;
      }
    }
  }
 else {
    final GroupElement wrapper=GroupElementFactory.newAndInstance();
    wrapper.addChild(cloned);
    ands=new GroupElement[]{wrapper};
  }
  for (int i=0; i < ands.length; i++) {
    this.fixClonedDeclarations(ands[i]);
  }
  return ands;
}
