{
  buf.append("\t\t");
  if (pattern.boundName != null) {
    buf.append(pattern.boundName);
    buf.append(" : ");
  }
  if (pattern.factType != null) {
    buf.append(pattern.factType);
  }
  buf.append("( ");
  for (int i=0; i < pattern.constraints.length; i++) {
    if (i > 0) {
      buf.append(", ");
    }
    final Constraint constr=pattern.constraints[i];
    if (constr.constraintValueType == IConstraint.TYPE_PREDICATE) {
      buf.append("( ");
      buf.append(constr.value);
      buf.append(" )");
    }
 else {
      if (constr.fieldBinding != null) {
        buf.append(constr.fieldBinding);
        buf.append(" : ");
      }
      buf.append(constr.fieldName);
      addFieldRestriction(buf,constr.constraintValueType,constr.operator,constr.value);
      if (constr.connectives != null) {
        for (int j=0; j < constr.connectives.length; j++) {
          final ConnectiveConstraint conn=constr.connectives[j];
          if (conn.isANDConnective()) {
            buf.append(" &");
          }
 else           if (conn.isORConnective()) {
            buf.append(" |");
          }
 else {
            throw new IllegalStateException("Unknown connective type/operator: [" + conn.operator + "]");
          }
          addFieldRestriction(buf,conn.constraintValueType,conn.operator,conn.value);
        }
      }
    }
  }
  buf.append(")\n");
}
