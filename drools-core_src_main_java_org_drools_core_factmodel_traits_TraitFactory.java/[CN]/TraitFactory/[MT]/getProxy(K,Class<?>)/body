{
  String traitName=trait.getName();
  if (core.hasTrait(traitName)) {
    return (T)core.getTrait(traitName);
  }
  String key=getKey(core.getClass(),trait);
  Constructor<T> konst=factoryCache.get(key);
  if (konst == null) {
    konst=cacheConstructor(key,core,trait);
  }
  T proxy=null;
  try {
switch (mode) {
case MAP:
      proxy=konst.newInstance(core,core._getDynamicProperties());
    break;
case TRIPLES:
  proxy=konst.newInstance(core,ruleBase.getTripleStore(),getTripleFactory());
break;
default :
throw new RuntimeException(" This should not happen : unexpected property wrapping method " + mode);
}
HierarchyEncoder hier=ruleBase.getConfiguration().getComponentFactory().getTraitRegistry().getHierarchy();
((TraitProxy)proxy).setTypeCode(hier.getCode(trait.getName()));
core._setBottomTypeCode(hier.getBottom());
core.addTrait(traitName,proxy);
return proxy;
}
 catch (InstantiationException e) {
e.printStackTrace();
}
catch (IllegalAccessException e) {
e.printStackTrace();
}
catch (InvocationTargetException e) {
e.printStackTrace();
}
return null;
}
