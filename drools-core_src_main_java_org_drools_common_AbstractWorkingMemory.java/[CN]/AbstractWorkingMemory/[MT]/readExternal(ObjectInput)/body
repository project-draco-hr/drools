{
  id=in.readLong();
  evaluatingActionQueue=in.readBoolean();
  discardOnLogicalOverride=in.readBoolean();
  propagationIdCounter=(AtomicLong)in.readObject();
  maintainTms=in.readBoolean();
  sequential=in.readBoolean();
  firing=in.readBoolean();
  halt=in.readBoolean();
  processCounter=in.readInt();
  addRemovePropertyChangeListenerArgs=(Object[])in.readObject();
  nodeMemories=(NodeMemories)in.readObject();
  objectStore=(ObjectStore)in.readObject();
  queryResults=(Map)in.readObject();
  globalResolver=(GlobalResolver)in.readObject();
  workingMemoryEventSupport=(WorkingMemoryEventSupport)in.readObject();
  agendaEventSupport=(AgendaEventSupport)in.readObject();
  workflowEventSupport=(RuleFlowEventSupport)in.readObject();
  __ruleBaseEventListeners=(List)in.readObject();
  ruleBase=(InternalRuleBase)in.readObject();
  handleFactory=(FactHandleFactory)in.readObject();
  tms=(TruthMaintenanceSystem)in.readObject();
  agenda=(DefaultAgenda)in.readObject();
  lock=(ReentrantLock)in.readObject();
  actionQueue=(Queue<WorkingMemoryAction>)in.readObject();
  liaPropagations=(List)in.readObject();
  processInstances=(Map)in.readObject();
  workItemManager=(WorkItemManager)in.readObject();
  processInstanceFactories=(Map<String,ProcessInstanceFactory>)in.readObject();
  timeMachine=(TimeMachine)in.readObject();
  entryPoint=(EntryPoint)in.readObject();
  entryPoints=(Map<String,WorkingMemoryEntryPoint>)in.readObject();
  initTransient();
}
