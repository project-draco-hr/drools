{
  final CollectMemory memory=(CollectMemory)workingMemory.getNodeMemory(this);
  final Collection<Object> result=(Collection<Object>)this.collect.instantiateResultObject(workingMemory);
  final InternalFactHandle resultHandle=workingMemory.getFactHandleFactory().newFactHandle(result,workingMemory.getObjectTypeConfigurationRegistry().getObjectTypeConf(context.getEntryPoint(),result),workingMemory);
  final CollectContext colctx=new CollectContext();
  colctx.resultTuple=new RightTuple(resultHandle,this);
  if (this.tupleMemoryEnabled) {
    memory.betaMemory.getLeftTupleMemory().add(leftTuple);
    memory.betaMemory.getCreatedHandles().put(leftTuple,colctx,false);
  }
  this.constraints.updateFromTuple(memory.betaMemory.getContext(),workingMemory,leftTuple);
  for (RightTuple rightTuple=memory.betaMemory.getRightTupleMemory().getFirst(leftTuple); rightTuple != null; rightTuple=(RightTuple)rightTuple.getNext()) {
    InternalFactHandle handle=rightTuple.getFactHandle();
    if (this.constraints.isAllowedCachedLeft(memory.betaMemory.getContext(),handle)) {
      addMatch(leftTuple,rightTuple,colctx);
    }
  }
  this.constraints.resetTuple(memory.betaMemory.getContext());
  evaluateResultConstraints(ActivitySource.LEFT,leftTuple,context,workingMemory,memory,colctx);
}
