{
  StringBuilderAppendable appendable=new StringBuilderAppendable();
  FunctionHandlers.dump(lispForm,appendable);
  ParserContext context=new ParserContext();
  String namespace=this.session.getAgenda().getFocus().getName();
  Package pkg=this.ruleBase.getPackage(namespace);
  if (pkg == null) {
    this.packageBuilder.addPackage(createPackageDescr(namespace));
    pkg=this.ruleBase.getPackage(namespace);
  }
  if (pkg != null) {
    try {
      for (Iterator it=pkg.getImports().entrySet().iterator(); it.hasNext(); ) {
        Entry entry=(Entry)it.next();
        String importName=((ImportDeclaration)entry.getValue()).getTarget();
        if (importName.endsWith("*")) {
          context.addPackageImport(importName.substring(0,importName.length() - 2));
        }
 else {
          Class cls=pkg.getDialectRuntimeRegistry().getClassLoader().loadClass(importName);
          context.addImport(cls.getSimpleName(),(Class)cls);
        }
      }
    }
 catch (    Exception e) {
      e.printStackTrace();
    }
    MVELDialectRuntimeData data=(MVELDialectRuntimeData)pkg.getDialectRuntimeRegistry().getDialectData("clips");
    this.factory.setNextFactory(data.getFunctionFactory());
  }
  ClassLoader tempClassLoader=Thread.currentThread().getContextClassLoader();
  Thread.currentThread().setContextClassLoader(pkg.getPackageScopeClassLoader());
  ExpressionCompiler expr=new ExpressionCompiler(appendable.toString());
  Serializable executable=expr.compile(context);
  MVEL.executeExpression(executable,this,this.factory);
  Thread.currentThread().setContextClassLoader(tempClassLoader);
}
