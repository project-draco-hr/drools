{
  final BetaMemory memory=(BetaMemory)workingMemory.getNodeMemory(this);
  final Iterator tupleIter=memory.getLeftTupleMemory().iterator();
  for (LeftTuple leftTuple=(LeftTuple)tupleIter.next(); leftTuple != null; leftTuple=(LeftTuple)tupleIter.next()) {
    this.constraints.updateFromTuple(memory.getContext(),workingMemory,leftTuple);
    for (RightTuple rightTuple=memory.getRightTupleMemory().getFirst(leftTuple); rightTuple != null; rightTuple=(RightTuple)rightTuple.getNext()) {
      if (this.constraints.isAllowedCachedLeft(memory.getContext(),rightTuple.getFactHandle())) {
        sink.assertLeftTuple(new LeftTuple(leftTuple,rightTuple,sink,this.tupleMemoryEnabled),context,workingMemory);
      }
    }
    this.constraints.resetTuple(memory.getContext());
  }
}
