{
  final BetaMemory memory=(BetaMemory)workingMemory.getNodeMemory(this);
  memory.remove(workingMemory,leftTuple);
  final Map matches=leftTuple.getTupleMatches();
  if (matches.isEmpty()) {
    assertTuple(leftTuple,context,workingMemory);
  }
 else {
    final Map oldMatches=new HashMap(matches);
    leftTuple.getTupleMatches().clear();
    memory.add(workingMemory,leftTuple);
    final BetaNodeConstraints binder=getJoinNodeBinder();
    for (final Iterator rightIterator=memory.rightObjectIterator(workingMemory,leftTuple); rightIterator.hasNext(); ) {
      final ObjectMatches objectMatches=(ObjectMatches)rightIterator.next();
      final InternalFactHandle handle=objectMatches.getFactHandle();
      if (binder.isAllowed(handle,leftTuple,workingMemory)) {
        TupleMatch tupleMatch=(TupleMatch)oldMatches.remove(handle);
        if (tupleMatch != null) {
          objectMatches.remove(tupleMatch);
          objectMatches.add(tupleMatch);
          leftTuple.addTupleMatch(handle,tupleMatch);
          tupleMatch.propagateModifyTuple(context,workingMemory);
        }
 else {
          tupleMatch=this.tupleMatchFactory.newTupleMatch(leftTuple,objectMatches);
          objectMatches.add(tupleMatch);
          leftTuple.addTupleMatch(handle,tupleMatch);
          this.sink.propagateAssertTuple(leftTuple,handle,tupleMatch,context,workingMemory);
        }
      }
 else {
        final TupleMatch tupleMatch=leftTuple.removeMatch(handle);
        if (tupleMatch != null) {
          oldMatches.remove(handle);
          objectMatches.remove(tupleMatch);
          tupleMatch.propagateRetractTuple(context,workingMemory);
        }
      }
    }
    if (!oldMatches.isEmpty()) {
      for (Iterator it=oldMatches.values().iterator(); it.hasNext(); ) {
        final TupleMatch tupleMatch=(TupleMatch)it.next();
        tupleMatch.getObjectMatches().remove(tupleMatch);
        tupleMatch.propagateRetractTuple(context,workingMemory);
      }
    }
  }
}
