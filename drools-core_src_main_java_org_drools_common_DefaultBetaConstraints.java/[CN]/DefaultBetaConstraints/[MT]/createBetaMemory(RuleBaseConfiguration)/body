{
  BetaMemory memory;
  if (this.indexed > 0) {
    LinkedListEntry entry=(LinkedListEntry)this.constraints.getFirst();
    final List list=new ArrayList();
    for (int pos=0; pos < this.indexed; pos++) {
      final Constraint constraint=(Constraint)entry.getObject();
      final VariableConstraint variableConstraint=(VariableConstraint)constraint;
      final FieldIndex index=new FieldIndex(variableConstraint.getFieldExtractor(),variableConstraint.getRequiredDeclarations()[0],variableConstraint.getEvaluator());
      list.add(index);
      entry=(LinkedListEntry)entry.getNext();
    }
    final FieldIndex[] indexes=(FieldIndex[])list.toArray(new FieldIndex[list.size()]);
    TupleMemory tupleMemory;
    if (config.isIndexLeftBetaMemory()) {
      tupleMemory=new TupleIndexHashTable(indexes);
    }
 else {
      tupleMemory=new TupleHashTable();
    }
    FactHandleMemory factHandleMemory;
    if (config.isIndexRightBetaMemory()) {
      factHandleMemory=new FactHandleIndexHashTable(indexes);
    }
 else {
      factHandleMemory=config.isSequential() ? (FactHandleMemory)new FactList() : (FactHandleMemory)new FactHashTable();
    }
    memory=new BetaMemory(config.isSequential() ? null : tupleMemory,factHandleMemory);
  }
 else {
    memory=new BetaMemory(config.isSequential() ? null : new TupleHashTable(),config.isSequential() ? (FactHandleMemory)new FactList() : (FactHandleMemory)new FactHashTable());
  }
  return memory;
}
