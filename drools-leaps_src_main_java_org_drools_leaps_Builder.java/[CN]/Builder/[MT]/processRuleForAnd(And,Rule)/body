{
  ColumnConstraints constraints;
  final ArrayList leapsRules=new ArrayList();
  final ArrayList cols=new ArrayList();
  final ArrayList notCols=new ArrayList();
  final ArrayList existsCols=new ArrayList();
  final ArrayList evalConditions=new ArrayList();
  for (final Iterator it=and.getChildren().iterator(); it.hasNext(); ) {
    final Object object=it.next();
    if (object instanceof EvalCondition) {
      final EvalCondition eval=(EvalCondition)object;
      evalConditions.add(eval);
    }
 else {
      if (object instanceof Column) {
        constraints=Builder.processColumn((Column)object,true);
      }
 else {
        GroupElement ce=(GroupElement)object;
        while (!(ce.getChildren().get(0) instanceof Column)) {
          ce=(GroupElement)ce.getChildren().get(0);
        }
        constraints=Builder.processColumn((Column)ce.getChildren().get(0),false);
      }
      if (object instanceof Not) {
        notCols.add(constraints);
      }
 else       if (object instanceof Exists) {
        existsCols.add(constraints);
      }
 else {
        cols.add(constraints);
      }
    }
  }
  checkEvalUnboundDeclarations(rule,evalConditions);
  leapsRules.add(new LeapsRule(rule,cols,notCols,existsCols,evalConditions));
  return leapsRules;
}
