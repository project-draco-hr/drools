{
  TraitFactory builder=TraitFactory.getTraitBuilderForKnowledgeBase(this.getKnowledgeRuntime().getKieBase());
  TraitableBean inner=makeTraitable(core,builder,logical);
  Collection<Thing> mostSpecificTraits=inner.getMostSpecificTraits();
  boolean newTraitsAdded=false;
  T firstThing=null;
  Map<Thing,BitSet> things=new HashMap<Thing,BitSet>(traits.size());
  checkStaticTypeCode(inner);
  for (  Class<?> trait : traits) {
    boolean needsProxy=trait.isAssignableFrom(inner.getClass());
    boolean hasTrait=inner.hasTrait(trait.getName());
    boolean needsUpdate=needsProxy || core != inner;
    if (!hasTrait) {
      BitSet boundary=inner.getCurrentTypeCode() != null ? (BitSet)inner.getCurrentTypeCode().clone() : null;
      T thing=(T)asTrait(core,inner,trait,needsProxy,hasTrait,needsUpdate,builder,logical);
      configureTrait(thing,value);
      things.put((Thing)thing,boundary);
      if (!newTraitsAdded && trait != Thing.class) {
        firstThing=thing;
        newTraitsAdded=true;
      }
    }
  }
  for (  Thing t : things.keySet()) {
    doInsertTrait(t,core,logical,things.get(t));
  }
  if (newTraitsAdded) {
    if (mostSpecificTraits != null) {
      updateCore(inner,core,null,logical);
      if (!mostSpecificTraits.isEmpty()) {
        updateManyTraits(inner,Long.MIN_VALUE,things.keySet(),core.getClass(),null,mostSpecificTraits);
      }
    }
  }
  return firstThing;
}
