{
  List<BaseDescr> victims=new LinkedList<BaseDescr>();
  for (  BaseDescr baseDescr : descrs) {
    ExprConstraintDescr descr=(ExprConstraintDescr)baseDescr;
    if (descr.getType() == ExprConstraintDescr.Type.POSITIONAL && pattern.getObjectType() instanceof ClassObjectType) {
      Class klazz=((ClassObjectType)pattern.getObjectType()).getClassType();
      TypeDeclaration tDecl=context.getPackageBuilder().getTypeDeclaration(klazz);
      if (tDecl == null) {
        context.getErrors().add(new DescrBuildError(context.getParentDescr(),descr,klazz,"Unable to find @positional definitions for :" + klazz + "\n"));
        continue;
      }
      FieldDefinition field=tDecl.getTypeClassDef().getField(descr.getPosition());
      if (field == null) {
        context.getErrors().add(new DescrBuildError(context.getParentDescr(),descr,null,"Unable to find @positional field " + descr.getPosition()) + "\n");
        continue;
      }
      DRLLexer lex=new DRLLexer(new ANTLRStringStream(descr.getExpression()));
      boolean isSimpleIdentifier=false;
      try {
        lex.mID();
        isSimpleIdentifier=lex.getCharIndex() >= descr.getExpression().length();
      }
 catch (      RecognitionException e) {
      }
      if (isSimpleIdentifier) {
        BindingDescr binder=new BindingDescr();
        binder.setExpression(field.getName());
        binder.setVariable(descr.getExpression());
        patternDescr.addBinding(binder);
        victims.add(descr);
        continue;
      }
 else {
        descr.setText(field.getName() + " == " + descr.getExpression());
        descr.setType(ExprConstraintDescr.Type.NAMED);
      }
    }
  }
  return victims;
}
