{
  Map<String,Class<?>> declarations=getDeclarationsMap(predicateDescr,context,true);
  Map<String,Class<?>> globals=context.getPackageBuilder().getGlobals();
  Map<String,EvaluatorWrapper> operators=new HashMap<String,EvaluatorWrapper>();
  for (  Map.Entry<String,OperatorDescr> entry : aliases.entrySet()) {
    OperatorDescr op=entry.getValue();
    String leftStr=op.getLeftString();
    String rightStr=op.getRightString();
    Declaration leftDecl=context.getDeclarationResolver().getDeclaration(context.getRule(),leftStr);
    if (leftDecl == null && "this".equals(leftStr)) {
      leftDecl=this.createDeclarationObject(context,"this",pattern);
    }
    Declaration rightDecl=context.getDeclarationResolver().getDeclaration(context.getRule(),rightStr);
    if (rightDecl == null && "this".equals(rightStr)) {
      rightDecl=this.createDeclarationObject(context,"this",pattern);
    }
    Target left=leftDecl != null && leftDecl.isPatternDeclaration() ? Target.HANDLE : Target.FACT;
    Target right=rightDecl != null && rightDecl.isPatternDeclaration() ? Target.HANDLE : Target.FACT;
    op.setLeftIsHandle(left == Target.HANDLE);
    op.setRightIsHandle(right == Target.HANDLE);
    Evaluator evaluator=getEvaluator(context,predicateDescr,ValueType.OBJECT_TYPE,op.getOperator(),false,op.getParametersText(),left,right);
    EvaluatorWrapper wrapper=new EvaluatorWrapper(evaluator,left == Target.HANDLE ? leftDecl : null,right == Target.HANDLE ? rightDecl : null);
    operators.put(entry.getKey(),wrapper);
  }
  Class<?> thisClass=null;
  if (pattern.getObjectType() instanceof ClassObjectType) {
    thisClass=((ClassObjectType)pattern.getObjectType()).getClassType();
  }
  final AnalysisResult analysis=context.getDialect().analyzeExpression(context,predicateDescr,predicateDescr.getContent(),new BoundIdentifiers(declarations,globals,operators,thisClass));
  if (analysis == null) {
    return;
  }
  final BoundIdentifiers usedIdentifiers=analysis.getBoundIdentifiers();
  final List tupleDeclarations=new ArrayList();
  final List factDeclarations=new ArrayList();
  for (  String id : usedIdentifiers.getDeclrClasses().keySet()) {
    final Declaration decl=context.getDeclarationResolver().getDeclaration(context.getRule(),id);
    if (decl.getPattern() == pattern) {
      factDeclarations.add(decl);
    }
 else {
      tupleDeclarations.add(decl);
    }
  }
  this.createImplicitBindings(context,pattern,analysis.getNotBoundedIdentifiers(),analysis.getBoundIdentifiers(),factDeclarations);
  final Declaration[] previousDeclarations=(Declaration[])tupleDeclarations.toArray(new Declaration[tupleDeclarations.size()]);
  final Declaration[] localDeclarations=(Declaration[])factDeclarations.toArray(new Declaration[factDeclarations.size()]);
  final String[] requiredGlobals=usedIdentifiers.getGlobals().keySet().toArray(new String[usedIdentifiers.getGlobals().size()]);
  final String[] requiredOperators=usedIdentifiers.getOperators().keySet().toArray(new String[usedIdentifiers.getOperators().size()]);
  Arrays.sort(previousDeclarations,SortDeclarations.instance);
  Arrays.sort(localDeclarations,SortDeclarations.instance);
  final PredicateConstraint predicateConstraint=new PredicateConstraint(null,previousDeclarations,localDeclarations,requiredGlobals,requiredOperators);
  if (container == null) {
    pattern.addConstraint(predicateConstraint);
  }
 else {
    if (predicateConstraint.getType().equals(Constraint.ConstraintType.UNKNOWN)) {
      this.setConstraintType(pattern,predicateConstraint);
    }
    container.addConstraint(predicateConstraint);
  }
  final PredicateBuilder builder=context.getDialect().getPredicateBuilder();
  builder.build(context,usedIdentifiers,previousDeclarations,localDeclarations,predicateConstraint,predicateDescr,analysis);
}
