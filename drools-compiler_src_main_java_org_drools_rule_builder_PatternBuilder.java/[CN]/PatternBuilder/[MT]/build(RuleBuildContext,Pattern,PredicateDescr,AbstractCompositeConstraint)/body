{
  Map<String,Class<?>> declarations=getDeclarationsMap(predicateDescr,context);
  Map<String,Class<?>> globals=context.getPackageBuilder().getGlobals();
  final Dialect.AnalysisResult analysis=context.getDialect().analyzeExpression(context,predicateDescr,predicateDescr.getContent(),new Map[]{declarations,globals});
  if (analysis == null) {
    return;
  }
  final List[] usedIdentifiers=analysis.getBoundIdentifiers();
  final List tupleDeclarations=new ArrayList();
  final List factDeclarations=new ArrayList();
  for (int i=0, size=usedIdentifiers[0].size(); i < size; i++) {
    final Declaration decl=context.getDeclarationResolver().getDeclaration(context.getRule(),(String)usedIdentifiers[0].get(i));
    if (decl.getPattern() == pattern) {
      factDeclarations.add(decl);
    }
 else {
      tupleDeclarations.add(decl);
    }
  }
  this.createImplicitBindings(context,pattern,analysis.getNotBoundedIdentifiers(),factDeclarations);
  final Declaration[] previousDeclarations=(Declaration[])tupleDeclarations.toArray(new Declaration[tupleDeclarations.size()]);
  final Declaration[] localDeclarations=(Declaration[])factDeclarations.toArray(new Declaration[factDeclarations.size()]);
  final String[] requiredGlobals=(String[])usedIdentifiers[1].toArray(new String[usedIdentifiers[1].size()]);
  final PredicateConstraint predicateConstraint=new PredicateConstraint(null,previousDeclarations,localDeclarations,requiredGlobals);
  if (container == null) {
    pattern.addConstraint(predicateConstraint);
  }
 else {
    if (predicateConstraint.getType().equals(Constraint.ConstraintType.UNKNOWN)) {
      this.setConstraintType(pattern,(MutableTypeConstraint)predicateConstraint);
    }
    container.addConstraint(predicateConstraint);
  }
  final PredicateBuilder builder=context.getDialect().getPredicateBuilder();
  builder.build(context,usedIdentifiers,previousDeclarations,localDeclarations,predicateConstraint,predicateDescr);
}
