{
  DrlExprParser parser=new DrlExprParser();
  ConstraintConnectiveDescr result=parser.parse(descr.getText());
  if (parser.hasErrors()) {
    for (    DroolsParserException error : parser.getErrors()) {
      context.getErrors().add(new DescrBuildError(context.getParentDescr(),descr,null,"Unable to parser pattern expression:\n" + error.getMessage()));
    }
    return;
  }
  for (Iterator<BaseDescr> it=result.getDescrs().iterator(); it.hasNext(); ) {
    BaseDescr d=it.next();
    boolean simple=false;
    String expr=null;
    RelationalExprDescr relDescr=null;
    if (d instanceof AtomicExprDescr) {
      expr=((AtomicExprDescr)d).getExpression();
    }
 else {
      if (d instanceof RelationalExprDescr) {
        relDescr=(RelationalExprDescr)d;
        if (relDescr.getLeft() instanceof AtomicExprDescr && relDescr.getRight() instanceof AtomicExprDescr) {
          simple=true;
        }
      }
      StringBuilder sbuilder=new StringBuilder();
      renderConstraint(sbuilder,d,0);
      expr=sbuilder.toString().trim();
    }
    if (expr.startsWith("eval")) {
      int startParen=expr.indexOf('(') + 1;
      int endParen=expr.lastIndexOf(')');
      expr=expr.substring(startParen,endParen);
      PredicateDescr pdescr=new PredicateDescr(expr);
      buildEval(context,pattern,pdescr,null);
      continue;
    }
    if (!simple || !context.isTypesafe()) {
      Dialect dialect=context.getDialect();
      MVELDialect mvelDialect=(MVELDialect)context.getDialect("mvel");
      context.setDialect(mvelDialect);
      PredicateDescr pdescr=new PredicateDescr(expr);
      buildEval(context,pattern,pdescr,null);
      context.setDialect(dialect);
      continue;
    }
    if (!(d instanceof RelationalExprDescr)) {
      throw new RuntimeException("What caused this?: " + d);
    }
    RelationalExprDescr exprDescr=(RelationalExprDescr)d;
    AtomicExprDescr rdescr=((AtomicExprDescr)exprDescr.getRight());
    String fieldName=((AtomicExprDescr)exprDescr.getLeft()).getExpression();
    String value=rdescr.getExpression().trim();
    ExprBindings rightExpr=new ExprBindings();
    setInputs(context,rightExpr,((ClassObjectType)pattern.getObjectType()).getClassType(),value);
    String[] parts=fieldName.split("\\.");
    if (parts.length == 2) {
      if ("this".equals(parts[0].trim())) {
        if (parts[1].trim().startsWith("[")) {
          Dialect dialect=context.getDialect();
          MVELDialect mvelDialect=(MVELDialect)context.getDialect("mvel");
          context.setDialect(mvelDialect);
          PredicateDescr pdescr=new PredicateDescr(expr);
          buildEval(context,pattern,pdescr,null);
          context.setDialect(dialect);
          continue;
        }
 else {
          fieldName=parts[1];
        }
      }
 else       if (pattern.getDeclaration() != null && parts[0].trim().equals(pattern.getDeclaration().getIdentifier())) {
        fieldName=parts[1];
      }
    }
    if (fieldName.indexOf('.') >= 0 || fieldName.indexOf('[') >= 0 || fieldName.indexOf('(') >= 0) {
      ExprBindings leftExpr=new ExprBindings();
      setInputs(context,leftExpr,((ClassObjectType)((Pattern)context.getBuildStack().peek()).getObjectType()).getClassType(),fieldName);
      if (!leftExpr.getRuleBindings().isEmpty()) {
        Dialect dialect=context.getDialect();
        MVELDialect mvelDialect=(MVELDialect)context.getDialect("mvel");
        context.setDialect(mvelDialect);
        PredicateDescr pdescr=new PredicateDescr(expr);
        buildEval(context,pattern,pdescr,null);
        context.setDialect(dialect);
        continue;
      }
    }
    final InternalReadAccessor extractor=getFieldReadAccessor(context,d,pattern.getObjectType(),fieldName,null,false);
    if (extractor == null) {
      context.getErrors().add(new DescrBuildError(context.getParentDescr(),d,null,"Unable to build constraint as  '" + fieldName + "' is invalid"));
      continue;
    }
    String operator=relDescr.getOperator().trim();
    boolean negatedOperator=operator.startsWith("not ");
    if (negatedOperator) {
      operator=operator.substring(4);
    }
    Restriction restriction=null;
    if (rdescr.isLiteral()) {
      restriction=buildLiteralRestriction(context,extractor,new LiteralRestrictionDescr(operator,negatedOperator,value));
    }
 else {
      int dotPos=value.indexOf('.');
      if (dotPos >= 0) {
        final String className=value.substring(0,dotPos);
        String enumName=value.substring(dotPos + 1);
        try {
          final Class cls=context.getDialect().getTypeResolver().resolveType(className);
          if (enumName.indexOf('(') < 0 && enumName.indexOf('.') < 0 && enumName.indexOf('[') < 0) {
            restriction=buildLiteralRestriction(context,extractor,new LiteralRestrictionDescr(operator,negatedOperator,value));
          }
        }
 catch (        ClassNotFoundException e) {
        }
      }
    }
    if (restriction != null) {
      pattern.addConstraint(new LiteralConstraint(extractor,(LiteralRestriction)restriction));
      continue;
    }
    Declaration declr=null;
    if (value.indexOf('(') < 0 && value.indexOf('.') < 0 && value.indexOf('[') < 0) {
      declr=context.getDeclarationResolver().getDeclaration(context.getRule(),value);
      if (declr == null) {
        final Pattern thisPattern=(Pattern)context.getBuildStack().peek();
        declr=this.createDeclarationObject(context,value,thisPattern);
        if (declr == null) {
          context.getErrors().add(new DescrBuildError(context.getParentDescr(),d,null,"Unable to return Declaration for identifier '" + value + "'"));
          continue;
        }
      }
    }
    if (declr == null) {
      parts=value.split("\\.");
      if (parts.length == 2) {
        if ("this".equals(parts[0].trim())) {
          declr=this.createDeclarationObject(context,parts[1].trim(),(Pattern)context.getBuildStack().peek());
          value=parts[1].trim();
        }
 else {
          declr=context.getDeclarationResolver().getDeclaration(context.getRule(),parts[0].trim());
          if (declr != null) {
            if (declr.isPatternDeclaration()) {
              declr=this.createDeclarationObject(context,parts[1].trim(),declr.getPattern());
              value=parts[1].trim();
            }
 else {
              context.getErrors().add(new DescrBuildError(context.getParentDescr(),d,"","Not possible to directly access the property '" + parts[1] + "' of declaration '"+ parts[0]+ "' since it is not a pattern"));
              continue;
            }
          }
        }
      }
    }
    if (declr != null) {
      Target right=getRightTarget(extractor);
      Target left=(declr.isPatternDeclaration() && !(Date.class.isAssignableFrom(declr.getExtractor().getExtractToClass()) || Number.class.isAssignableFrom(declr.getExtractor().getExtractToClass()))) ? Target.HANDLE : Target.FACT;
      final Evaluator evaluator=getEvaluator(context,d,extractor.getValueType(),operator,negatedOperator,null,left,right);
      if (evaluator == null) {
        continue;
      }
      restriction=new VariableRestriction(extractor,declr,evaluator);
    }
    if (restriction == null) {
      Dialect dialect=context.getDialect();
      if (!value.startsWith("(")) {
        MVELDialect mvelDialect=(MVELDialect)context.getDialect("mvel");
        context.setDialect(mvelDialect);
      }
      restriction=buildRestriction(context,(Pattern)context.getBuildStack().peek(),extractor,new ReturnValueRestrictionDescr(operator,negatedOperator,null,value));
      context.setDialect(dialect);
    }
    if (restriction == null || extractor == null) {
      return;
    }
    pattern.addConstraint(new VariableConstraint(extractor,restriction));
  }
}
