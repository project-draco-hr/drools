{
  DrlExprParser parser=new DrlExprParser();
  ConstraintConnectiveDescr result=parser.parse(descr.getText());
  if (parser.hasErrors()) {
    for (    DroolsParserException error : parser.getErrors()) {
      context.getErrors().add(new DescrBuildError(context.getParentDescr(),descr,null,"Unable to parser pattern expression:\n" + error.getMessage()));
    }
    return;
  }
  for (Iterator<BaseDescr> it=result.getDescrs().iterator(); it.hasNext(); ) {
    BaseDescr d=it.next();
    boolean simple=false;
    String expr=null;
    RelationalExprDescr relDescr=null;
    if (d instanceof AtomicExprDescr) {
      expr=((AtomicExprDescr)d).getExpression();
    }
 else {
      relDescr=(RelationalExprDescr)d;
      if (relDescr.getLeft() instanceof AtomicExprDescr && relDescr.getRight() instanceof AtomicExprDescr) {
        simple=true;
      }
      StringBuilder sbuilder=new StringBuilder();
      renderConstraint(sbuilder,d);
      expr=sbuilder.toString().trim();
    }
    if (expr.startsWith("eval")) {
      int startParen=expr.indexOf('(') + 1;
      int endParen=expr.lastIndexOf(')');
      expr=expr.substring(startParen,endParen);
    }
    if (!simple) {
      PredicateDescr pdescr=new PredicateDescr(expr);
      buildEval(context,pattern,pdescr,null);
      return;
    }
    if (Map.class.isAssignableFrom(((ClassObjectType)pattern.getObjectType()).getClassType())) {
      Dialect dialect=context.getDialect();
      MVELDialect mvelDialect=(MVELDialect)context.getDialect("mvel");
      boolean strictMode=mvelDialect.isStrictMode();
      mvelDialect.setStrictMode(false);
      context.setDialect(mvelDialect);
      PredicateDescr pdescr=new PredicateDescr(expr);
      buildEval(context,pattern,pdescr,null);
      context.setDialect(dialect);
      return;
    }
    if (!(d instanceof RelationalExprDescr)) {
      throw new RuntimeException("What caused this?: " + d);
    }
    RelationalExprDescr exprDescr=(RelationalExprDescr)d;
    AtomicExprDescr rdescr=((AtomicExprDescr)exprDescr.getRight());
    String fieldName=((AtomicExprDescr)exprDescr.getLeft()).getExpression();
    String value=rdescr.getExpression().trim();
    DescrBranch rightExpr=new DescrBranch();
    setInputs(context,rightExpr,((ClassObjectType)((Pattern)context.getBuildStack().peek()).getObjectType()).getClassType(),value);
    if (fieldName.indexOf('.') >= 0 || fieldName.indexOf('[') >= 0 || fieldName.indexOf('(') >= 0) {
      DescrBranch leftExpr=new DescrBranch();
      setInputs(context,leftExpr,((ClassObjectType)((Pattern)context.getBuildStack().peek()).getObjectType()).getClassType(),fieldName);
      if (!leftExpr.getRuleBindings().isEmpty()) {
        PredicateDescr pdescr=new PredicateDescr(expr);
        buildEval(context,pattern,pdescr,null);
        return;
      }
    }
    final InternalReadAccessor extractor=getFieldReadAccessor(context,d,pattern.getObjectType(),fieldName,null,false);
    String operator=relDescr.getOperator();
    int notPos=operator.indexOf("not");
    boolean negatedOperator=false;
    if (notPos >= 0) {
      negatedOperator=true;
      operator=operator.substring(notPos + 3).trim();
    }
    Restriction restriction=null;
    if (rdescr.isLiteral()) {
      restriction=buildRestriction(context,extractor,new LiteralRestrictionDescr(operator,notPos >= 0,value));
    }
 else {
      int dotPos=value.indexOf('.');
      if (dotPos >= 0) {
        final String className=value.substring(0,dotPos);
        String enumName=value.substring(dotPos + 1);
        try {
          final Class cls=context.getDialect().getTypeResolver().resolveType(className);
          if (enumName.indexOf('(') < 0 && enumName.indexOf('.') < 0 && enumName.indexOf('[') < 0) {
            restriction=buildRestriction(context,extractor,new LiteralRestrictionDescr(operator,negatedOperator,value));
          }
        }
 catch (        ClassNotFoundException e) {
        }
      }
    }
    if (restriction != null) {
      pattern.addConstraint(new LiteralConstraint(extractor,(LiteralRestriction)restriction));
      return;
    }
    Declaration declr=null;
    if (value.indexOf('(') < 0 && value.indexOf('.') < 0 && value.indexOf('[') < 0) {
      declr=context.getDeclarationResolver().getDeclaration(context.getRule(),value);
      if (declr == null) {
        final Pattern thisPattern=(Pattern)context.getBuildStack().peek();
        declr=this.createDeclarationObject(context,value,thisPattern);
        if (declr == null) {
          context.getErrors().add(new DescrBuildError(context.getParentDescr(),d,null,"Unable to return Declaration for identifier '" + value + "'"));
          return;
        }
      }
    }
    if (declr == null) {
      String[] parts=value.split("\\.");
      if (parts.length == 2) {
        if ("this".equals(parts[0])) {
          declr=this.createDeclarationObject(context,parts[1],(Pattern)context.getBuildStack().peek());
        }
 else {
          declr=context.getDeclarationResolver().getDeclaration(context.getRule(),parts[0]);
          if (declr != null) {
            if (declr.isPatternDeclaration()) {
              declr=this.createDeclarationObject(context,parts[0],parts[1],declr.getPattern());
            }
 else {
              context.getErrors().add(new DescrBuildError(context.getParentDescr(),d,"","Not possible to directly access the property '" + parts[1] + "' of declaration '"+ parts[0]+ "' since it is not a pattern"));
              return;
            }
          }
        }
      }
    }
    if (declr != null) {
      Target right=getRightTarget(extractor);
      Target left=(declr.isPatternDeclaration() && !(Date.class.isAssignableFrom(declr.getExtractor().getExtractToClass()) || Number.class.isAssignableFrom(declr.getExtractor().getExtractToClass()))) ? Target.HANDLE : Target.FACT;
      final Evaluator evaluator=getEvaluator(context,d,extractor.getValueType(),operator,negatedOperator,null,left,right);
      if (evaluator == null) {
        return;
      }
      restriction=new VariableRestriction(extractor,declr,evaluator);
    }
    if (restriction == null) {
      restriction=buildRestriction(context,(Pattern)context.getBuildStack().peek(),extractor,new ReturnValueRestrictionDescr(operator,(notPos >= 0),null,value));
    }
    pattern.addConstraint(new VariableConstraint(extractor,restriction));
  }
}
