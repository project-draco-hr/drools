{
  if (branch.isSimple()) {
    RelationalExprDescr red=(RelationalExprDescr)branch.getDescr();
    String fieldName=((AtomicExprDescr)red.getLeft()).getExpression();
    AtomicExprDescr right=(AtomicExprDescr)red.getRight();
    String[] identifiers=fieldName.split("\\.");
    if (identifiers.length == 2 && "this".equals(identifiers[0])) {
      fieldName=identifiers[1];
    }
    final InternalReadAccessor extractor=getFieldReadAccessor(context,red,pattern.getObjectType(),fieldName,null,false);
    FieldValue field=null;
    try {
      String value=right.getExpression();
      int dotPos=right.getExpression().indexOf('.');
      int parenPos=right.getExpression().indexOf('(');
      if ((!right.isLiteral()) && dotPos >= 0 && parenPos < 0) {
        final String className=value.substring(0,dotPos);
        String classFieldName=value.substring(dotPos + 1);
        try {
          final Class staticClass=context.getDialect().getTypeResolver().resolveType(className);
          field=FieldFactory.getFieldValue(staticClass.getField(classFieldName).get(null),extractor.getValueType(),context.getPackageBuilder().getDateFormats());
          if (field.isObjectField()) {
            ((ObjectFieldImpl)field).setEnum(true);
            ((ObjectFieldImpl)field).setEnumName(staticClass.getName());
            ((ObjectFieldImpl)field).setFieldName(classFieldName);
          }
        }
 catch (        final ClassNotFoundException e) {
        }
catch (        final Exception e) {
          context.getErrors().add(new DescrBuildError(context.getParentDescr(),red,e,"Unable to create a Field value of type  '" + extractor.getValueType() + "' and value '"+ value+ "'"));
        }
      }
 else {
        if (right.isLiteral() && value.startsWith("\"") && context.getConfiguration().isProcessStringEscapes()) {
          value=StringUtils.unescapeJava((String)value);
        }
        field=FieldFactory.getFieldValue(value,extractor.getValueType(),context.getPackageBuilder().getDateFormats());
      }
    }
 catch (    final Exception e) {
      context.getErrors().add(new DescrBuildError(context.getParentDescr(),red,e,"Unable to create a Field value of type  '" + extractor.getValueType() + "' and value '"+ right.getExpression()+ "'"));
    }
    if (field == null) {
      return;
    }
    Target rightTarget=getRightTarget(extractor);
    Target leftTarget=Target.FACT;
    String operator=red.getOperator();
    int notPos=operator.indexOf("not");
    if (notPos >= 0) {
      operator=red.getOperator().substring(notPos + 3);
    }
    final Evaluator evaluator=getEvaluator(context,red,extractor.getValueType(),operator,(notPos >= 0),null,leftTarget,rightTarget);
    if (evaluator == null) {
      context.getErrors().add(new DescrBuildError(context.getParentDescr(),red,null,"Unable to create Evaluator for type '" + extractor.getValueType() + "' on expression '"+ branch.getExpression()+ "'"));
      return;
    }
    LiteralRestriction restriction=new LiteralRestriction(field,evaluator,extractor);
    LiteralConstraint constraint=new LiteralConstraint(extractor,(LiteralRestriction)restriction);
    registerReadAccessor(context,pattern.getObjectType(),fieldName,(LiteralConstraint)constraint);
    registerReadAccessor(context,pattern.getObjectType(),fieldName,restriction);
    pattern.addConstraint(constraint);
  }
 else {
    PredicateDescr pdescr=new PredicateDescr(branch.getExpression());
    build(context,pattern,pdescr,container);
  }
}
