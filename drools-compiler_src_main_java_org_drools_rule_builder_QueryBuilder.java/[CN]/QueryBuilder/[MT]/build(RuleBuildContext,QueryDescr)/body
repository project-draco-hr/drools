{
  ObjectType queryObjectType=new ClassObjectType(DroolsQuery.class);
  final Pattern pattern=new Pattern(context.getNextPatternId(),0,queryObjectType,null);
  final InternalReadAccessor extractor=PatternBuilder.getFieldReadAccessor(context,queryDescr,queryObjectType,"name",null,true);
  final FieldValue field=FieldFactory.getFieldValue(queryDescr.getName(),ValueType.STRING_TYPE,context.getPackageBuilder().getDateFormats());
  final LiteralConstraint constraint=new LiteralConstraint(extractor,context.getConfiguration().getEvaluatorRegistry().getEvaluator(ValueType.STRING_TYPE,Operator.EQUAL),field);
  PatternBuilder.registerReadAccessor(context,queryObjectType,"name",constraint);
  pattern.addConstraint(constraint);
  ObjectType argsObjectType=new ClassObjectType(Arguments.class);
  InternalReadAccessor arrayExtractor=PatternBuilder.getFieldReadAccessor(context,queryDescr,argsObjectType,"arguments",null,true);
  String[] params=queryDescr.getParameters();
  String[] types=queryDescr.getParameterTypes();
  int i=0;
  Declaration[] declarations=new Declaration[params.length];
  try {
    for (i=0; i < params.length; i++) {
      Declaration declr=pattern.addDeclaration(params[i]);
      ArrayElementReader reader=new ArrayElementReader(arrayExtractor,i,context.getDialect().getTypeResolver().resolveType(types[i]));
      PatternBuilder.registerReadAccessor(context,argsObjectType,"arguments",reader);
      declr.setReadAccessor(reader);
      declarations[i]=declr;
    }
    ((Query)context.getRule()).setParameters(declarations);
  }
 catch (  ClassNotFoundException e) {
    context.getErrors().add(new DescrBuildError(context.getParentDescr(),queryDescr,e,"Unable to resolve type '" + types[i] + " for parameter"+ params[i]));
  }
  return pattern;
}
